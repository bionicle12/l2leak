/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

DBConn *__thiscall DBConn::DBConn(DBConn *this);
int __thiscall DBConn::DestructorDBConn(DBConn *this); // idb
int DBConn::AllocSQLPool();
int DBConn::AllocSQLPool2();
int DBConn::AllocSQLPool3();
BOOL __stdcall DBConn::loginDlgProc(HWND hDlg, UINT msgType, WPARAM wparam, LPARAM a4); // idb
BOOL __stdcall DBConn::loginBBSDlgProc(HWND hDlg, UINT msgType, WPARAM wparam, LPARAM a4); // idb
bool __cdecl DBConn::Login();
bool __thiscall DBConn::Fetch(DBConn *this);
int __stdcall DBConn::Error(SQLSMALLINT handleType, SQLHANDLE handle, const wchar_t *query); // idb
int __thiscall DBConn::Bind(DBConn *this, wchar_t *value, int length);
int __thiscall DBConn::ResetHtmt(DBConn *this); // idb
int __thiscall DBConn::BindNullable(DBConn *this, int *value, SQLINTEGER *indicator);
int __cdecl DBConn::Init();
bool DBConn::Execute(DBConn *this, const wchar_t *format, ...);
bool __cdecl Config::ExceptionMailing();
// CHAR *__usercall Utils::UnicodeToMultibyte_WithoutAllocation@<eax>(const WCHAR *wideMsg@<edi>); idb
BOOL CoreDump::WriteToFile(HANDLE hFile, wchar_t *format, ...); // idb
const char *__thiscall CoreDump::ExceptionToString(int exceptionCode);
// wchar_t *__usercall Utils::GetFileName@<eax>(const wchar_t *str@<esi>);
char __cdecl CExceptionInit::SendFile(SOCKET socket, const wchar_t *fileToSend); // idb
// bool __usercall CExceptionInit::SendMail@<al>(const char *mailTo@<eax>, const char *mailServer, const char *mailFrom, const wchar_t *errorLogPath);
// BOOL __usercall CoreDump::WriteCallStack@<eax>(ThreadIndices threadIndex@<eax>, HANDLE hFile@<ebx>, const wchar_t *threadName);
void __thiscall CoreDump::CreateReport(EXCEPTION_POINTERS *ex);
int CallStack::ReportCallStack();
LONG __stdcall CExceptionInit::RecordExceptionInfo(struct _EXCEPTION_POINTERS *exceptionInfo); // idb
void __cdecl CExceptionInit::InstallTopLevelFilter(); // idb
LPTOP_LEVEL_EXCEPTION_FILTER CExceptionInit::RestoreTopLevelFilter();
void *__thiscall CExceptionInit::CExceptionInit(void *this);
void CExceptionInit::LogException(const wchar_t *format, ...); // idb
MACRO_EXCEPTION __cdecl CExceptionInit::ExceptionFilter(EXCEPTION_POINTERS *ex);
char __cdecl CExceptionInit::SendExceptionLog(bool fatal); // idb
int EASSERT();
void *__thiscall guard(void *this, wchar_t *funcName);
int unguard();
int __cdecl MainWindow::MessageLoop_common(HACCEL hAccTable); // idb
int __cdecl MainWindow::MessageLoop_mailing(HACCEL hAccTable); // idb
MACRO_FALSE __stdcall MainWindow::AboutDlgProc(HWND hDlg, UINT msgType, WPARAM wparam, LPARAM a4);
unsigned int __stdcall Threads::ServerListeningThread(void *param);
void __noreturn PerfMonitor::Job();
void __noreturn CSQLQueue::Job();
void __cdecl __noreturn CBCPLogFile::Job(int bcpSlot); // idb
LRESULT __stdcall MainWindow::WndProc(HWND hWnd, UINT mstType, WPARAM wParam, LPARAM lParam); // idb
void __noreturn Threads::PerfMonitorThread_mailing();
int Threads::PerfMonitorThread_common(void); // weak
void __stdcall __noreturn Threads::PerfMonitorThread(void *a1); // idb
void __noreturn Threads::SqlQueueThread_mailing();
void __noreturn Threads::SqlQueueThread_common(void);
void __stdcall __noreturn Threads::SqlQueueThread(void *param); // idb
void __cdecl __noreturn Threads::BCPThread_mailing(int bcpSlot); // idb
void __cdecl __noreturn Threads::BCPThread_common(int bcpSlot); // idb
unsigned int __stdcall __noreturn Threads::BCPThread(void *bcpSlot);
ATOM __cdecl MainWindow::RegisterLogDClass(HINSTANCE hInstance);
bool __cdecl MainWindow::InitInstance(HINSTANCE hInstance, int nCmdShow);
int __stdcall WinMain(HINSTANCE instance, HINSTANCE hPrevInstance, char *lpCmdLine, int nShowCmd);
MemSmth *__thiscall MemSmth::MemSmth(MemSmth *this);
void __thiscall MemSmth::Destructor(MemSmth *this); // idb
LONG __thiscall MMU::deallocate(void *this, void *memory);
MemoryPool *__thiscall MemoryPool::MemoryPool(MemoryPool *this); // idb
// _DWORD *__userpurge MemoryPool::Allocate@<eax>(MemoryPool *this@<ecx>, void *a2@<esi>, int size);
int __thiscall MemoryPool::Destructor(MemoryPool *this); // idb
void *__thiscall Allocator::allocate(void *this, int size, int blockSize, const wchar_t *name);
MemoryPool *__thiscall MemoryPool::DeletingDestructor(MemoryPool *this, char a2);
MemSmth *__thiscall MemSmth::sub_404CF0(MemSmth *this);
void __thiscall MemSmth::sub_404D40(MemSmth *this, unsigned int a2); // idb
int __thiscall sub_404EA0(int this, int a2);
int __thiscall sub_404F30(int this, unsigned int a2);
void __thiscall MemSmth::Internal::Destructor(MemSmth *this); // idb
SmallBufferBlock *__thiscall SmallBufferBlock::SmallBufferBlock(SmallBufferBlock *this); // idb
char *__thiscall sub_405020(int this, int a2);
int __thiscall sub_405100(void *this);
void __thiscall SmallBufferBlock::Destructor(SmallBufferBlock *this); // idb
MemSmth *__thiscall MemSmth::Internal::DeletingDestructor(MemSmth *this, char a2);
SmallBufferBlock *__thiscall SmallBufferBlock::DeletingDestructor(SmallBufferBlock *this, char a2);
int __cdecl sub_405190(int a1);
_DWORD *__cdecl sub_4051B0(_DWORD *a1);
int __thiscall sub_4051D0(int this, int a2);
int __thiscall sub_405230(int this, int a2);
// int __thiscall Utils__isNumber(void *this);
// int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::assign(_DWORD); weak
char __stdcall sub_405330(void *a1);
_BYTE *__thiscall sub_405370(void *this, int a2, unsigned int a3);
// void __usercall __noreturn sub_40545D(int a1@<ebp>);
int __thiscall sub_4054C0(int this, unsigned int a2, char a3);
int __thiscall sub_4055A0(int this, unsigned int a2, unsigned int a3);
void *__thiscall sub_405660(void *this, int a2, unsigned int a3, unsigned int a4);
void *__thiscall sub_405710(int this, const void *a2, unsigned int a3);
void *__thiscall sub_4057B0(void *this, int a2);
void *__thiscall sub_405810(void *this, char a2);
// int __cdecl _ismbbkana(unsigned int);
int __thiscall sub_405870(int this, const void *a2);
void *__thiscall sub_4058B0(void *this, int a2);
int *__thiscall sub_405920(void *this, int *a2, int a3);
int *__thiscall sub_405C30(int this, int *a2, int a3, int a4);
void __thiscall CQsCheck::Destructor(struct _RTL_CRITICAL_SECTION *lpCriticalSection);
LPCRITICAL_SECTION __thiscall CQsCheck::CQsCheck(LPCRITICAL_SECTION lpCriticalSection);
LONG __thiscall LockStack::Push(LockStack *this, int recurent, int deep, const wchar_t *lockName, int line);
LONG __thiscall LockStack::Pop(LockStack *this, int recurent, int m_deep, const wchar_t *unlockName, int line);
int CThreadManager::SetThisThreadAsMainThread();
BOOL CThreadManager::isMainThread();
bool __cdecl CThreadManager::isListenThread();
int CThreadManager::GetIOThreadNumber();
int __cdecl CThreadManager::SetIOThreadNumber(int maxIOThreadNumber); // idb
int __cdecl CThreadManager::RegisterThisThread(ThreadIndices threadIndex);
HANDLE __cdecl CThreadManager::SetThread(int index, HANDLE threadId); // idb
HANDLE __cdecl CThreadManager::GetThread(ThreadIndices index);
int tls::GetCurrentThreadIndex();
bool __cdecl DBConn::LoadStrFromReg(WCHAR *str, const WCHAR *keyStr, const WCHAR *regEntry);
int __cdecl DBConn::SaveStrToReg(WCHAR *str, const WCHAR *keyStr, const WCHAR *regEntry);
int __cdecl Utils::UnicodeToAnsi(WCHAR *unistr, int maxunilen, char *ansistr, int maxansilen);
int __cdecl Utils::AnsiToUnicode(const char *ansistr, int maxansilen, wchar_t *unistr, int maxunilen);
int __cdecl sub_406340(wchar_t *, int); // idb
bool __cdecl Utils::IsNumber(wchar_t chr);
int __cdecl Config::SetPrivateProfile(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName); // idb
BOOL __cdecl Config::SetPrivateProfile2(const wchar_t *section, const wchar_t *keyName, int value, const wchar_t *fileName); // idb
wchar_t *__thiscall sub_406470(std::wstring *this);
int __stdcall Mybase::_Alval_deallocate(int a1, int a2);
int __thiscall Traits::assign(std::wstring *this, int a2); // idb
void *__stdcall sub_4064E0(int a1, int a2);
char __thiscall sub_406500(int this, char a2);
_WORD *__thiscall std::string::_Copy(void *this, int a2, int a3);
// void __usercall __noreturn sub_40666E(int a1@<ebp>);
int __thiscall std::string::_Grow(std::wstring *this, unsigned int _Newsize, char _Trim); // idb
LONG __thiscall MMU::Allocator::destroy(std::wstring *this); // idb
std::wstring *__thiscall std::string::assign_char(std::wstring *this, unsigned int _Count, wchar_t _Ch); // idb
int __thiscall std::string::erase(int this, unsigned int a2, unsigned int a3);
std::wstring *__thiscall std::string::assign(std::wstring *this, std::wstring *_Right, unsigned int _Roff, unsigned int _Count); // idb
int __thiscall std::string::assign_c_str(std::wstring *this, const wchar_t *msg, int len);
__int32 __cdecl Utils::GetIntFromString(wchar_t *strWithNum); // idb
void __thiscall CBCPLogFile::DestructorCBCPLogFile(CBCPLogFile *this); // idb
char __thiscall CBCPLogFile::Init(CBCPLogFile *this, int slot); // idb
int __stdcall CBCPLogFile::BulkInsert(const wchar_t *logCategory, const wchar_t *filePath, const wchar_t *logTableName);
char CBCPLogFile::CheckFmtFile();
bool __stdcall CBCPLogFile::GetMaxFileNo(const wchar_t *file, wchar_t *clearFileName, int *max);
bool __stdcall CBCPLogFile::CheckLogTimeTable(int year, int month, int day, int world);
CBCPLogFile *__thiscall CBCPLogFile::CBCPLogFile(CBCPLogFile *this);
bool __stdcall CBCPLogFile::GetMoveFileName(const wchar_t *dirName, const wchar_t *originFileName, wchar_t *newFileName);
char __thiscall CBCPLogFile::InsertLogFiles(CBCPLogFile *this, wchar_t *dirPath); // idb
int Config::Init();
int Config::Save();
MACRO_FALSE __stdcall MainWindow::ConfigDlgProc(HWND hDlg, UINT msgType, WPARAM wparam, LPARAM a4);
DWORD CThreadManager::GetMaxIOThreadNumber();
int __thiscall SpinLock::Wait(SpinLock *this); // idb
int __thiscall CIOObject::OnTimerCallback(CIOObject *this, int id);
int __thiscall CIOObject::OnIOCallback(CIOObject *this, BOOL bSucess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped);
bool __cdecl CIOObject::SetShortTimeStamp(DWORD *pTimeVar, DWORD nAdditional);
CIOBuffer *__thiscall CIOBuffer::CIOBuffer(_DWORD *this);
__int32 __thiscall MemoryObject::AddRef(MemoryObject *this, const char *fileName, int line, int workType);
int __thiscall CIOSocket::OnClose(CIOSocket *this); // idb
int __thiscall CIOSocket::Close(CIOSocket *this); // idb
int __thiscall CIOSocket::OnCreate(CIOSocket *this); // idb
int __thiscall CIOSocket::ReadCallback(CIOSocket *this, int dwTransferred); // idb
int __thiscall CIOServer::Close(CIOServer *this); // idb
int __thiscall CIOServer::OnWaitCallback(CIOServer *this); // idb
int __thiscall CIOSocket::Initialize(CIOSocket *this); // idb
int AddLog(char *arg0, ...);
_BYTE *__cdecl StrNChr(_BYTE *a1, char a2, int a3);
int __cdecl WcsNLen(int a1, int a2);
const unsigned __int8 *PacketUtils::Disassemble(const unsigned __int8 *packet, const char *format, ...);
int __cdecl PacketUtils::VAssemble(char *buff, int size, const char *format, va_list ap);
CIOBufferPool *__thiscall CIOBufferPool::CIOBufferPool(CIOBufferPool *this, int size); // idb
int __thiscall sub_4091D0(int this);
int MemoryObject::IsUser();
__int32 __thiscall MemoryObject::RefCount(MemoryObject *this); // idb
MemoryObject *__thiscall MemoryObject::DeletingDestructor(MemoryObject *this, char a2);
void __stdcall CIOObject::TimerExpired(CIOObject *this); // idb
int __thiscall CIOObject::OnTimer(CIOObject *this, int id);
void __thiscall CIOObject::OnWaitCallback(CIOObject *);
BOOL __thiscall CIOObject::PostObject(CIOObject *this, DWORD id); // idb
CIODeadlockChecker *__thiscall CIODeadlockChecker::CIODeadlockChecker(CIODeadlockChecker *this);
int CPacket::operator_delete();
int CIOBufferPool::getFreeSlotsNumberFromAllPools();
LONG __thiscall CIODeadlockChecker::Release(CIODeadlockChecker *this, const char *file, int line, int nWorkType, bool flag);
CIOBuffer *__cdecl CIOBuffer::Alloc();
CIOBuffer **__thiscall CIOBuffer::Free(CIOBuffer *this);
LONG __thiscall CIOSocket::Release(CIOSocket *this, const char *file, int line, int nWorkType, bool flag);
CIOSocket *__thiscall CIOSocket::CIOSocket(CIOSocket *this, SOCKET socket); // idb
LONG __thiscall CIOServer::Release(CIOServer *this, const char *file, int line, int nWorkType);
CIOServer *__thiscall CIOServer::CIOServer(CIOServer *this);
int __thiscall CIOServer::Destructor(CIOServer *this); // idb
int __thiscall CIOServer::OnIOCallback(CIOServer *this, BOOL bSuccess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped);
LONG __thiscall CPacket::Release(CPacket *this, const char *file, int line, int nWorkType, bool flag);
int CPacket::FreeAll();
_DWORD *__cdecl sub_409C00(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_409C40(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_409C70(int a1, int a2, int a3);
LONG __thiscall CIOBuffer::Release(CIOBuffer *this); // idb
CIODeadlockChecker *__thiscall CIODeadlockChecker::DeletingDestructor(CIODeadlockChecker *this, char a2);
int __thiscall CIOSocket::Destructor(CIOSocket *this); // idb
int __thiscall CIOSocket::Read(CIOSocket *this, size_t dwLeft); // idb
void __thiscall CIOSocket::WriteCallback(CIOSocket *this, DWORD dwTransferred);
int __thiscall CIOSocket::Write(CIOSocket *this, CIOBuffer *buffer); // idb
CIOServer *__thiscall CIOServer::DeletingDestructor(CIOServer *this, char a2);
CPacket *__thiscall CPacket::DeletingDestructor(CPacket *this, char a2);
void __thiscall CIOObject::Destructor(CIOObject *this); // idb
int __thiscall CPacket::OnIOCallback(CPacket *this, BOOL bSuccess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped);
_DWORD *__cdecl sub_40A550(_DWORD *a1, int a2, int a3, _DWORD *a4);
_DWORD *__cdecl sub_40A580(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_40A5A0(int a1, int a2, int a3);
_DWORD *__cdecl sub_40A5E0(_DWORD *a1, int a2, int a3, int a4);
int __cdecl std::vector_CIOTimer::_Ufill(int a1, int a2, int a3);
int __cdecl std::_Push_heap(std::vector_CIOTimer::iterator *_First, int _Hole, int _Top, int m_dwTime, int a5, int a6); // idb
int __cdecl std::pop_heap(int a1, int a2, int a3, int a4, int a5, int a6);
CIOSocket *__thiscall CIOSocket::DeletingDestructor(CIOSocket *this, char a2);
int __thiscall CIOSocket::OnIOCallback(CIOSocket *this, BOOL bSuccess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped);
_DWORD *__stdcall sub_40A8A0(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __stdcall sub_40A8D0(int a1, int a2, int a3);
_DWORD *__stdcall sub_40A900(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __stdcall sub_40A930(int a1, int a2, int a3);
unsigned int __cdecl std::push_heap(int a1, int a2, int c);
void __thiscall std::vector_HANDLE::Destructor(std::vector_HANDLE *this); // idb
int __cdecl CIOObject::TimerDispatch();
void __noreturn Threads::WaitThread();
void __cdecl __noreturn Threads::IOThread__common(void *threadId);
void __cdecl __noreturn Threads::IOThread__mailing(void *arglist);
void __cdecl __noreturn Threads::IOThread__debug(void *arglist); // idb
void __stdcall __noreturn Threads::IOThread(void *threadIndex); // idb
signed int __cdecl Threads::CreateIOThread(signed __int32 threadNumber); // idb
void __noreturn sub_40B030();
unsigned int __thiscall sub_40B0B0(void *this, _DWORD *a2, unsigned int a3, _DWORD *a4);
int __thiscall sub_40B370(void *this, char *a2, unsigned int a3, int *a4);
_DWORD *__thiscall std::vector_CIOTimer::insert(int this, _DWORD *a2, char *a3, int *a4);
_DWORD *__thiscall std::vector_HANDLE::push_back(std::vector_HANDLE *this, _DWORD *a2); // idb
std::vector_HANDLE *__thiscall std::vector_HANDLE::std::vector_HANDLE(std::vector_HANDLE *this);
_DWORD *__thiscall std::vector_CIOTimer::push_back(std::vector_CIOTimer *this, CIOTimer *timer); // idb
MACRO_FALSE __thiscall CIOObject::RegisterWait(CIOObject *this, HANDLE handle); // idb
MACRO_FALSE __thiscall CIOServer::Create(CIOServer *this, int port);
bool __thiscall CIOObject::AddTimer(CIOObject *this, unsigned int time, int id);
std::priority_queue_CIOTimer *__thiscall sub_40BB90(std::priority_queue_CIOTimer *this, _BYTE *a2, int a3);
bool __thiscall CIODeadlockChecker::TimerExpired(CIODeadlockChecker *this, int id); // idb
std::priority_queue_CIOTimer *__thiscall std::priority_queue::priority_queue(std::priority_queue_CIOTimer *this);
CIOCriticalSection *__thiscall CIOCriticalSection::CIOCriticalSection(CIOCriticalSection *this); // idb
CIOCriticalSection *__thiscall CIOCriticalSection::CIOCriticalSection2(CIOCriticalSection *this, DWORD spinCount); // idb
int __thiscall CIOCriticalSection::Destructor(CIOCriticalSection *this); // idb
void __thiscall CIOCriticalSection::Enter(CIOCriticalSection *this, const wchar_t *lockName, int line); // idb
void __thiscall CIOCriticalSection::Leave(CIOCriticalSection *this, const wchar_t *unlockName, int line);
int __thiscall CLog::Set(CLog *this, HWND logWnd); // idb
// CHAR *__usercall Utils::UnicodeToMultibyte@<eax>(const WCHAR *wideMsg1@<ebx>);
bool __thiscall CLog::CanAppend(CLog *this, int nYear, int nMonth, int nDay, int nHour, int nHalf);
void __thiscall CLog::LockBuffer(CLog *this, int bufferIndex);
void __thiscall CLog::UnlockBuffer(CLog *this, int bufferIndex); // idb
int __thiscall CLog::Redraw(CLog *this); // idb
int __thiscall CLog::Enable(CLog *this, bool enable); // idb
int __thiscall CLog::Sendable(CLog *this, bool sendable); // idb
int __thiscall CLog::FlushLogFile(CLog *this); // idb
int __thiscall CLog::CreateNewLogFile(CLog *this, int nYear, int nMonth, int nDay, int nHour, int nHalf);
void __noreturn CLogCli::Job();
void __noreturn Threads::CliLogThread_mailing();
void __noreturn Threads::CliLogThread_common(void);
int __thiscall CLog::AddV(CLog *this, LogType severity, const char *format, va_list params);
int __thiscall CLog::AddVW(CLog *this, LogType severity, const wchar_t *format, va_list params);
void __stdcall __noreturn Threads::CliLogThread(int a1);
CLog *__thiscall CLog::CLog(CLog *this, int size); // idb
int CLog::Add_Ansi(CLog *this, LogType severity, const char *format, ...);
int CLog::Add(CLog *this, LogType severity, const wchar_t *format, ...);
void *__cdecl CLogSocket::operator_new(int size); // idb
int CLogSocket::operator_delete();
CLogCli *__thiscall CLogCli::CLogCli(CLogCli *this);
bool __thiscall CLogCli::Connect(CLogCli *this);
int __thiscall CLogCli::LogSendMsg(CLogCli *this, LogType logType, const wchar_t *msg);
bool __thiscall CLogCli::Init(CLogCli *this); // idb
bool __cdecl static CLogSocket::packet0_SendMsg(CLogSocket *socket, const unsigned __int8 *packet);
bool __cdecl static CLogSocket::packet1_CheckStatus(CLogSocket *socket, const unsigned __int8 *packet);
bool __cdecl static CLogSocket::packet2_TestPacket(CLogSocket *socket, const unsigned __int8 *packet);
CLogSocket *__thiscall CLogSocket::CLogSocket(CLogSocket *this, SOCKET socket, bool (__cdecl **packetTable)(CLogSocket *, const unsigned __int8 *)); // idb
int __thiscall CLogSocket::Destructor(CLogSocket *this); // idb
int __thiscall CLogSocket::OnClose(CLogSocket *this); // idb
int CLogSocket::Send(CLogSocket *this, const char *format, ...);
LONG __thiscall CLogSocket::Release(CLogSocket *this, const char *file, int line, int nWorkType, bool flag);
CLogSocket *__thiscall CLogSocket::DeletingDestructor(CLogSocket *this, char a2);
int __thiscall CLogSocket::OnRead(CLogSocket *this); // idb
MemoryObject *__thiscall MemoryObject::MemoryObject(MemoryObject *this);
int __thiscall MemoryObject::ReportOrt(MemoryObject *this, int a2, int a3); // idb
LONG __thiscall MemoryObject::Release(MemoryObject *this, const char *file, int line, int nWorkType, bool flag);
PerfMonitor *__thiscall PerfMonitor::PerfMonitor(PerfMonitor *this);
bool __thiscall PerfMonitor::Init(PerfMonitor *this);
char __thiscall PerfMonitor::Clean(PerfMonitor *this); // idb
bool __thiscall PerfMonitor::Reload(PerfMonitor *this);
bool __thiscall PerfMonitor::CheckPerformance(PerfMonitor *this);
void *__thiscall CReadFile::CReadFile(void *this);
char CReadFile::ParseItemName();
char CReadFile::ParseNPCName();
char CReadFile::ParseQuestName();
char CReadFile::ParseSkillName();
CServer *__thiscall CServer::CServer(CServer *this);
int __thiscall CServer::Destructor(CServer *this); // idb
int __thiscall CServer::Run(CServer *this, int port, CServerSocket *(__cdecl *allocator)(SOCKET s), bool restrict, int reader, int worker);
int __thiscall CServer::CreateSocket(CServer *this, SOCKET newSocket, sockaddr_in *address);
LONG __thiscall CServer::Release(CServer *this, const char *file, int line, int nWorkType, bool flag);
CServer *__thiscall CServer::DeletingDestructor(CServer *this, char a2);
int CServerSocket::operator_delete();
bool __thiscall CServerSocket::CanAppend(CServerSocket *this, int year, int month, int day, int hour, int half); // idb
void __thiscall CServerSocket::LockBuffer(CServerSocket *this, int fileIndex); // idb
void __thiscall CServerSocket::UnlockBuffer(CServerSocket *this, int fileIndex); // idb
const unsigned __int8 *CServerSocket::ParseLogData(const wchar_t *logMessage, const char *format, ...);
bool __cdecl CServerSocket::packet01_SetCheckStatus(CServerSocket *socket, const unsigned __int8 *packet);
bool __cdecl CServerSocket::packet04_DummyPacket(CServerSocket *socket, const unsigned __int8 *packet);
CServerSocket *__thiscall CServerSocket::CServerSocket(CServerSocket *this, SOCKET socket, size_t buffSize); // idb
// char empty_stub();
int __thiscall CServerSocket::Destructor(CServerSocket *this); // idb
CServerSocket *__cdecl CServerSocket::Allocate(SOCKET socket);
int __thiscall CServerSocket::OnCreate(CServerSocket *this); // idb
int __thiscall CServerSocket::OnClose(CServerSocket *this); // idb
char *__cdecl Utils::UnicodeToMultibyte2(const wchar_t *wideMsg);
int __thiscall CServerSocket::WriteLogFile(CServerSocket *this, LogType logType, const wchar_t *msg); // idb
bool __thiscall CServerSocket::CheckLogTimeTable(CServerSocket *this, int worldId);
int __thiscall CServerSocket::SetAddress(CServerSocket *this, in_addr addr); // idb
in_addr __thiscall CServerSocket::GetAddress(CServerSocket *this, in_addr *unused);
LONG __thiscall CServerSocket::Release(CServerSocket *this, const char *file, int line, int nWorkType, bool flag);
CServerSocket *__thiscall CServerSocket::DeletingDestructor(CServerSocket *this, char a2);
int __thiscall CServerSocket::CreateNewLogFile(CServerSocket *this, int year, int month, int day, int hour, int half);
void CServerSocket::Send(CServerSocket *this, const char *format, ...);
bool __cdecl CServerSocket::packet00_SendLog(CServerSocket *socket, const unsigned __int8 *packet);
bool __cdecl CServerSocket::packet02_CheckLogD(CServerSocket *socket, const unsigned __int8 *packet);
bool __cdecl CServerSocket::packet03_ServerStarted(CServerSocket *socket, const unsigned __int8 *packet);
int __thiscall CServerSocket::TimerExpired(CServerSocket *this, int timerId); // idb
int __thiscall CServerSocket::OnRead(CServerSocket *this); // idb
int __thiscall CSQLQueue::SpaceUsed(CSQLQueue *this, int force); // idb
_DWORD *__cdecl sub_4116C0(_DWORD *a1, _DWORD *a2, _DWORD *a3);
std::wstring *__cdecl MMU::Allocator::construct(std::wstring *a1, std::wstring *_Right); // idb
void __thiscall std::dequeue_string::Destructor(std::dequeue_string *this); // idb
void __noreturn sub_4117D0();
char __thiscall CSQLQueue::ExecSQL(CSQLQueue *this); // idb
std::vector_string::iterator *__thiscall std::dequeue_string::_Growmap(std::dequeue_string *this, unsigned int a2);
void __thiscall j_std::dequeue_string::Destructor(std::dequeue_string *this); // idb
int __thiscall std::dequeue_string::push(std::dequeue_string *this, std::wstring *str); // idb
CSQLQueue *__thiscall CSQLQueue::CSQLQueue(CSQLQueue *this); // idb
char CSQLQueue::PushSQL(CSQLQueue *this, const wchar_t *format, ...); // idb
// SQLRETURN __stdcall SQLFreeStmt(SQLHSTMT StatementHandle, SQLUSMALLINT Option);
// SQLRETURN __stdcall SQLDisconnect(SQLHDBC ConnectionHandle);
// SQLRETURN __stdcall SQLFreeHandle(SQLSMALLINT HandleType, SQLHANDLE Handle);
// SQLRETURN __stdcall SQLDriverConnectW(SQLHDBC hdbc, SQLHWND hwnd, SQLWCHAR *szConnStrIn, SQLSMALLINT cchConnStrIn, SQLWCHAR *szConnStrOut, SQLSMALLINT cchConnStrOutMax, SQLSMALLINT *pcchConnStrOut, SQLUSMALLINT fDriverCompletion);
// SQLRETURN __stdcall SQLSetConnectAttrW(SQLHDBC hdbc, SQLINTEGER fAttribute, SQLPOINTER rgbValue, SQLINTEGER cbValue);
// SQLRETURN __stdcall SQLAllocHandle(SQLSMALLINT HandleType, SQLHANDLE InputHandle, SQLHANDLE *OutputHandle);
// SQLRETURN __stdcall SQLSetStmtAttrW(SQLHSTMT hstmt, SQLINTEGER fAttribute, SQLPOINTER rgbValue, SQLINTEGER cbValueMax);
// SQLRETURN __stdcall SQLGetDiagRecW(SQLSMALLINT fHandleType, SQLHANDLE handle, SQLSMALLINT iRecord, SQLWCHAR *szSqlState, SQLINTEGER *pfNativeError, SQLWCHAR *szErrorMsg, SQLSMALLINT cchErrorMsgMax, SQLSMALLINT *pcchErrorMsg);
// SQLRETURN __stdcall SQLExecDirectW(SQLHSTMT hstmt, SQLWCHAR *szSqlStr, SQLINTEGER TextLength);
// SQLRETURN __stdcall SQLFetch(SQLHSTMT StatementHandle);
// SQLRETURN __stdcall SQLBindCol(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType, SQLPOINTER TargetValue, SQLINTEGER BufferLength, SQLINTEGER *StrLen_or_Ind);
// SQLRETURN __stdcall SQLCloseCursor(SQLHSTMT StatementHandle);
// SQLRETURN __stdcall SQLSetEnvAttr(SQLHENV EnvironmentHandle, SQLINTEGER Attribute, SQLPOINTER Value, SQLINTEGER StringLength);
// PDH_STATUS __stdcall PdhAddCounterW(PDH_HQUERY hQuery, LPCWSTR szFullCounterPath, DWORD_PTR dwUserData, PDH_HCOUNTER *phCounter);
// PDH_STATUS __stdcall PdhMakeCounterPathW(PPDH_COUNTER_PATH_ELEMENTS_W pCounterPathElements, LPWSTR szFullPathBuffer, LPDWORD pcchBufferSize, DWORD dwFlags);
// PDH_STATUS __stdcall PdhOpenQueryW(LPCWSTR szDataSource, DWORD_PTR dwUserData, PDH_HQUERY *phQuery);
// PDH_STATUS __stdcall PdhCloseQuery(PDH_HQUERY hQuery);
// PDH_STATUS __stdcall PdhRemoveCounter(PDH_HCOUNTER hCounter);
// PDH_STATUS __stdcall PdhGetFormattedCounterValue(PDH_HCOUNTER hCounter, DWORD dwFormat, LPDWORD lpdwType, PPDH_FMT_COUNTERVALUE pValue);
// PDH_STATUS __stdcall PdhCollectQueryData(PDH_HQUERY hQuery);
// BOOL __stdcall GetProcessMemoryInfo(HANDLE Process, PPROCESS_MEMORY_COUNTERS ppsmemCounters, DWORD cb);
void *__cdecl operator new(size_t); // idb
// void *__cdecl operator new(size_t); idb
// void __noreturn std::_Xran();
// void __noreturn String_base::_Xlen__();
void __thiscall sub_411F67(int this);
void *__thiscall sub_411F72(void *this, char a2);
// void __cdecl __noreturn std::_Nomemory();
// _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD); weak
// enum _EXCEPTION_DISPOSITION __cdecl CatchGuardHandler(struct EHExceptionRecord *a1, struct CatchGuardRN *a2, void *a3);
// const struct _s_TryBlockMapEntry *__cdecl _GetRangeOfTrysToCheck(const struct _s_FuncInfo *, int, int, unsigned int *, unsigned int *); idb
int __cdecl sub_4121D5(int a1, int a2);
// int __cdecl IsExceptionObjectToBeDestroyed(void *); idb
int __cdecl sub_41221E(int a1);
// void *__cdecl _CallCatchBlock2(struct EHRegistrationNode *, const struct _s_FuncInfo *, void *, int, unsigned __int32); idb
// int __cdecl _CallSETranslator(struct EHExceptionRecord *, struct EHRegistrationNode *, void *, void *, const struct _s_FuncInfo *, int, struct EHRegistrationNode *); idb
// int __cdecl _abnormal_termination();
void __cdecl j_j__free(void *);
// wchar_t *__cdecl wcscat(wchar_t *, const wchar_t *);
// wchar_t *__cdecl wcscpy(wchar_t *, const wchar_t *);
// wchar_t *__cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
// size_t __cdecl wcslen(const wchar_t *);
// int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
// int __cdecl atexit(void (__cdecl *)());
// wchar_t *__cdecl wcsrchr(const wchar_t *, wchar_t);
// char *__cdecl Utils::TimeToString(time_t *time); idb
// time_t __cdecl time(time_t *);
// int sprintf(char *, const char *, ...);
// struct tm *__cdecl localtime(const time_t *);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
// int _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
// int __cdecl _endthreadex(DWORD dwExitCode); idb
// void __stdcall __noreturn _threadstartex(LPVOID lpThreadParameter);
// HANDLE __cdecl _beginthreadex(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, int a3, int a4, DWORD dwCreationFlags, LPDWORD lpThreadId);
// void __cdecl free(void *);
// void __stdcall __ArrayUnwind(void *, unsigned int, int, void (__thiscall *)(void *)); idb
// int __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *)); idb
void __stdcall Static_Init_For_Arrays(void *this_, unsigned int a2, int size, int initFunc, void (__thiscall *a5)(void *));
// void *__cdecl malloc(size_t);
void __cdecl j__free(void *);
LPVOID __cdecl calloc_crt(int a1, int a2);
// int __cdecl wcscmp(const wchar_t *, const wchar_t *);
// _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD); weak
// int exception::exception(void); weak
// exception *__thiscall exception::exception(exception *this, const char *const *a2);
// _DWORD __stdcall exception::exception(_DWORD); weak
// void __thiscall exception::~exception(int this);
exception *__thiscall sub_41343D(exception *this, char *a2);
_DWORD *__thiscall sub_413456(_DWORD *this, int a2);
exception *__thiscall sub_41346E(exception *this, char *a2);
void __thiscall sub_41349E(void *this);
void *__thiscall sub_4134A9(void *this, char a2);
void *__thiscall sub_4134C5(void *this, char a2);
// _DWORD __thiscall type_info::~type_info(#97 *__hidden this); weak
void *__thiscall sub_41350A(void *this, char a2);
// BOOL __thiscall unknown_libname_3(type_info *this, int a2); idb
wchar_t *__cdecl Utils::ToWString(int number, wchar_t *outStr, int maxSize); // idb
__int32 __cdecl j___wtol(const wchar_t *);
// int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
// wchar_t *__cdecl wcsstr(const wchar_t *, const wchar_t *);
wchar_t *__cdecl Utils::TimeToStr(time_t *a1);
// wchar_t *__cdecl wcschr(const wchar_t *, wchar_t);
// int swscanf(const wchar_t *, const wchar_t *, ...);
// int __cdecl _waccess(const wchar_t *, int);
// int __cdecl vsprintf(char *, const char *, va_list);
// char *__cdecl strncpy(char *, const char *, size_t);
int __cdecl typeid(CIOSocket *this_, int a);
// void __cdecl srand(unsigned int);
// int swprintf(wchar_t *, const wchar_t *, ...);
// int __cdecl fclose(FILE *);
// int __cdecl _getwc_lk(wchar_t); idb
// wint_t __cdecl fgetwc(FILE *);
// int __cdecl fseek(FILE *, __int32, int);
// FILE *__cdecl _wfopen(const wchar_t *, const wchar_t *);
// wchar_t *__cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
// int __cdecl _amsg_exit(DWORD NumberOfBytesWritten); idb
// int __cdecl fast_error_exit(DWORD NumberOfBytesWritten); idb
int start();
// _DWORD __cdecl _callnewh(_DWORD); weak
// size_t __cdecl strlen(const char *);
// int __cdecl TypeMatch(const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_ThrowInfo *); idb
int __cdecl sub_414B5C(int a1, int a2, int a3, int a4);
// _DWORD __cdecl __DestructExceptionObject(_DWORD, char); weak
void *__cdecl sub_414C8C(int a1, struct EHRegistrationNode *a2, int a3, struct _s_FuncInfo *a4, int a5, unsigned __int32 a6);
// void __cdecl CatchIt(struct EHExceptionRecord *, struct EHRegistrationNode *, struct _CONTEXT *, void *, const struct _s_FuncInfo *, const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_TryBlockMapEntry *, int, struct EHRegistrationNode *, unsigned __int8); idb
// void __usercall sub_415016(unsigned __int8 a1@<cl>, const struct _s_TryBlockMapEntry *a2@<ebx>, int a3@<edi>, struct EHExceptionRecord *a4, struct EHRegistrationNode *a5, struct EHRegistrationNode *a6, struct _CONTEXT *a7, struct _s_FuncInfo *a8, int a9, struct _s_FuncInfo *a10, struct EHRegistrationNode *a11);
// void __usercall sub_4150D6(struct EHRegistrationNode *a1@<ebx>, int a2@<edi>, const struct _s_ThrowInfo *a3@<esi>, struct EHExceptionRecord *a4, struct EHRegistrationNode *a5, struct EHRegistrationNode *a6, struct _CONTEXT *a7, struct _s_FuncInfo *a8, char a9, struct _s_FuncInfo *a10, struct EHRegistrationNode *a11);
// _DWORD __cdecl __InternalCxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void __cdecl terminate(); idb
// void __cdecl _inconsistency(); weak
// int _mtterm(void); weak
// _DWORD __cdecl _initptd(_DWORD); weak
// int __cdecl _getptd();
signed int winApi::initTls();
// _DWORD __stdcall _CallSettingFrame(_DWORD, _DWORD, _DWORD); weak
// int __cdecl _flsbuf(int, FILE *);
// int __cdecl write_char(_DWORD); weak
// _DWORD __cdecl write_multi_char(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl write_string(_DWORD); weak
int __cdecl sub_41582C(int a1, int a2, int a3);
int Static_Objects_initialization();
// void __cdecl __noreturn exit(int);
// void __cdecl __noreturn _exit(int);
// void __cdecl _cexit();
// char *__cdecl asctime(const struct tm *);
// int __thiscall write_char_0(FILE *); idb
// int __cdecl write_multi_char_0(char, int, FILE *); idb
// int __cdecl write_string_0(_DWORD); weak
int __cdecl sub_416636(FILE *, int, int); // idb
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
// _DWORD __cdecl _heap_init(_DWORD); weak
// signed int _mtinitlocks();
// _DWORD __cdecl _unlock(_DWORD); weak
signed int __cdecl sub_4177DB(int a1);
// _DWORD __cdecl _lock(_DWORD); weak
// _DWORD __cdecl __sbh_alloc_block(_DWORD); weak
// void *__cdecl memset(void *, int, size_t);
LPTOP_LEVEL_EXCEPTION_FILTER sub_418469();
// char *__cdecl strcpy(char *, const char *);
// char *__cdecl strcat(char *, const char *);
// int __cdecl strcmp(const char *, const char *);
// int __cdecl _lseek_lk(int, LONG lDistanceToMove, DWORD dwMoveMethod); idb
// int _ioinit(void); weak
// __int32 __cdecl _get_osfhandle(int);
signed int __cdecl sub_418A61(signed int a1);
// _DWORD __cdecl _unlock_fhandle(_DWORD); weak
int sub_418AF6();
// int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
// int report_failure(void); weak
void __thiscall sub_418D82(void *this);
int __cdecl sub_418D90(int, LONG lDistanceToMove); // idb
// int __cdecl __mbstowcs_mt(int, LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int cchWideChar); idb
// size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
// char *__cdecl _itoa(int, char *, int);
// int __cdecl iswctype(wint_t, wctype_t);
// wchar_t *__cdecl _wasctime(const struct tm *);
// int _hextodec(void); weak
// _DWORD __cdecl _un_inc(__int16); weak
// int __cdecl _whiteout(wchar_t); idb
int __cdecl sub_419AD8(int a1, int a2, int a3);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
_BYTE *sub_41AFAC();
// int _setenvp(void); weak
// _DWORD __cdecl parse_cmdline(_DWORD, _DWORD); weak
signed int sub_41B248();
// int __crtGetEnvironmentStringsA(void); weak
void sub_41B40C();
void __cdecl sub_41B450(); // idb
// int __cdecl _ValidateRead(const void *lp, UINT_PTR ucb); idb
// int __updatetlocinfo(void); weak
// int CPtoLCID(void); weak
// int setSBCS(void); weak
// int setSBUpLow(void); weak
void *sub_41B8AD();
int __cdecl sub_41B91C(UINT CodePage); // idb
// int __initmbctable(void); weak
int __cdecl sub_41BC20(int, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite); // idb
int __cdecl sub_41BDC5(int, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite); // idb
// _DWORD __cdecl _getbuf(_DWORD); weak
wchar_t __cdecl sub_41BEDE(wchar_t a1, FILE *a2);
// int __cdecl wctomb(char *, wchar_t);
// __int32 __cdecl atol(const char *);
// _DWORD __cdecl __crtInitCritSecAndSpinCount(_DWORD, _DWORD); weak
void __cdecl __noreturn sub_41C52F(int a1, int a2);
// _DWORD __cdecl _setmode_lk(_DWORD, _DWORD); weak
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_41CDF6(int a1, int a2);
int __cdecl sub_41CE0C(int a1, int a2);
int __cdecl sub_41CE22(int a1, int a2);
int __cdecl sub_41CE65(int a1, int a2);
// _DWORD __cdecl __dtold(_DWORD, _DWORD); weak
int __cdecl sub_41CFD9(char, int, int, char *); // idb
wchar_t __cdecl sub_41D1BC(wchar_t a1, int a2);
// int __cdecl iswspace(wint_t);
signed int sub_41D2E3();
int __cdecl sub_41D3B4(int, LPSTR lpMultiByteStr, LPCWSTR lpWideCharStr, int cchWideChar); // idb
int __cdecl sub_41D56B(LPSTR lpMultiByteStr, LPCWSTR lpWideCharStr, int cchWideChar); // idb
// _DWORD __cdecl __crtMessageBoxA(_DWORD, _DWORD, __int16); weak
// int __cdecl _ismbblead(unsigned int);
// int __cdecl _lseeki64_lk(int, int, int, DWORD dwMoveMethod); idb
// int __cdecl _flswbuf(int, int Buffer); idb
__int32 __cdecl sub_41E5E7(LCID Locale);
void *__cdecl sub_41E630(UINT CodePage, UINT a2, LPCSTR lpMultiByteStr, int a4, LPSTR a5, int a6);
// _DWORD __cdecl __add_12(_DWORD, _DWORD); weak
// _DWORD __cdecl __shl_12(_DWORD); weak
// _DWORD __cdecl __shr_12(_DWORD); weak
__int16 __cdecl sub_41E8D9(_BYTE *a1, int a2, int a3);
// _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
signed int __cdecl sub_41EDF7(__int64 a1, __int16 a2, int a3, char a4, int a5);
// _DWORD __cdecl strncnt(_DWORD); weak
int __cdecl sub_41F0FA(LCID Locale, DWORD dwCmpFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpString2, int cchCount2, UINT CodePage); // idb
// _DWORD __cdecl __ld12mul(_DWORD, _DWORD); weak
unsigned int __cdecl sub_41F91F(_WORD *a1, signed int a2, int a3);
int sub_41FBA0();
int sub_41FBC0();
int sub_41FBE0();
int sub_41FC00();
int sub_41FC20();
int sub_41FC40();
void sub_41FC60();
// int __usercall sub_41FC80@<eax>(int a1@<ebp>);
// void __usercall sub_41FCA0(MemSmth *a1@<ebp>); idb
int __cdecl SEH_404800(int a1, int a2, int a3, int a4);
// int __usercall sub_41FCC0@<eax>(int a1@<ebp>);
// int __usercall sub_41FCD6@<eax>(int a1@<ebp>);
// void __usercall sub_41FD30(int a1@<ebp>);
// int __usercall sub_41FD50@<eax>(int a1@<ebp>);
int __cdecl SEH_405920(int a1, int a2, int a3, int a4);
// int __usercall sub_41FD70@<eax>(int a1@<ebp>);
// void __usercall sub_41FD7E(int a1@<ebp>);
int __cdecl SEH_405D20(int a1, int a2, int a3, int a4);
int sub_41FDB0();
// LONG __usercall sub_41FDBB@<eax>(int a1@<ebp>);
int sub_41FDD0();
// int __usercall sub_41FDDB@<eax>(int a1@<ebp>);
int sub_41FDF0();
// int __usercall sub_41FDFB@<eax>(int a1@<ebp>);
int sub_41FE10();
int __cdecl SEH_407800(int a1, int a2, int a3, int a4);
int sub_41FE30();
int sub_41FE50();
int sub_41FE70();
int sub_41FE90();
int __cdecl SEH_408310(int a1, int a2, int a3, int a4);
int sub_41FEB0();
int __cdecl SEH_4084B0(int a1, int a2, int a3, int a4);
// void __usercall unknown_libname_24(int a1@<ebp>);
// int __usercall sub_41FED8@<eax>(int a1@<ebp>);
int sub_41FEE3();
// void __usercall sub_41FF00(int a1@<ebp>);
int __cdecl SEH_409860(int a1, int a2, int a3, int a4);
// void __usercall sub_41FF20(int a1@<ebp>);
int sub_41FF28();
int __cdecl SEH_4098D0(int a1, int a2, int a3, int a4);
int sub_41FF40();
int __cdecl SEH_409940(int a1, int a2, int a3, int a4);
// void __usercall sub_41FF60(int a1@<ebp>);
// int __usercall sub_41FF68@<eax>(int a1@<ebp>);
int sub_41FF80();
int sub_41FF88();
int sub_41FF90();
int __cdecl SEH_409DD0(int a1, int a2, int a3, int a4);
int sub_41FFB0();
int sub_41FFB8();
int __cdecl SEH_40A460(int a1, int a2, int a3, int a4);
int sub_41FFD0();
int sub_41FFD8();
int sub_41FFF0();
int sub_420010();
void sub_420030();
int __cdecl SEH_40B370(int a1, int a2, int a3, int a4);
int sub_420070();
int sub_420090();
int sub_4200B0();
int sub_4200D0();
int __cdecl SEH_40BF30(int a1, int a2, int a3, int a4);
int sub_4200F0();
int sub_420110();
int sub_42011B();
int sub_420130();
void sub_42013B();
int sub_420150();
int sub_420170();
// int __usercall sub_420178@<eax>(CLogSocket *a1@<ebp>); idb
int sub_420190();
int sub_4201B0();
int __cdecl SEH_40D450(int a1, int a2, int a3, int a4);
// int __usercall sub_4201D0@<eax>(int a1@<ebp>);
int sub_4201F0();
int __cdecl SEH_40D570(int a1, int a2, int a3, int a4);
int sub_420210();
// void __usercall sub_420218(int a1@<ebp>);
int sub_420230();
// int __usercall unknown_libname_41@<eax>(int a1@<ebp>);
int __cdecl SEH_40D870(int a1, int a2, int a3, int a4);
int sub_420250();
// int __usercall sub_42025B@<eax>(int a1@<ebp>);
int __cdecl SEH_40E330(int a1, int a2, int a3, int a4);
int sub_420270();
// int __usercall sub_42027B@<eax>(int a1@<ebp>);
int __cdecl SEH_40E680(int a1, int a2, int a3, int a4);
int sub_420290();
// int __usercall sub_42029B@<eax>(int a1@<ebp>);
int __cdecl SEH_40E980(int a1, int a2, int a3, int a4);
int sub_4202B0();
// int __usercall sub_4202BB@<eax>(int a1@<ebp>);
int __cdecl SEH_40ECE0(int a1, int a2, int a3, int a4);
// int __usercall sub_4202D0@<eax>(CIOServer *a1@<ebp>); idb
int __cdecl SEH_40F080(int a1, int a2, int a3, int a4);
int sub_4202F0();
// int __usercall sub_420310@<eax>(int a1@<ebp>);
// int __usercall sub_420318@<eax>(int a1@<ebp>);
// int __usercall sub_420326@<eax>(int a1@<ebp>);
int sub_420334();
int __cdecl SEH_40F6B0(int a1, int a2, int a3, int a4);
// int __usercall sub_420350@<eax>(int a1@<ebp>);
// int __usercall sub_420358@<eax>(int a1@<ebp>);
// int __usercall sub_420366@<eax>(int a1@<ebp>);
int __cdecl SEH_40F890(int a1, int a2, int a3, int a4);
int sub_420380();
// int __usercall unknown_libname_43@<eax>(CServerSocket *a1@<ebp>); idb
int __cdecl SEH_40F9A0(int a1, int a2, int a3, int a4);
int sub_4203A0();
int __cdecl SEH_40FAD0(int a1, int a2, int a3, int a4);
int sub_4203C0();
int sub_4203E0();
int sub_420400();
int __cdecl SEH_410620(int a1, int a2, int a3, int a4);
int sub_420420();
int __cdecl SEH_411020(int a1, int a2, int a3, int a4);
int sub_420440();
int sub_420460();
// int __usercall unknown_libname_47@<eax>(int a1@<ebp>);
int __cdecl SEH_411280(int a1, int a2, int a3, int a4);
int sub_420480();
// int __usercall sub_42048B@<eax>(int a1@<ebp>);
// void __usercall sub_4204A0(CIOObject *a1@<ebp>); idb
void sub_4204C0();
int sub_4204E0();
// int __usercall sub_4204EB@<eax>(int a1@<ebp>);
// LONG __usercall sub_4204F6@<eax>(int a1@<ebp>);
// void __usercall sub_420510(int a1@<ebp>);
int __cdecl SEH_411C90(int a1, int a2, int a3, int a4);
int sub_420530();
// LONG __usercall sub_42053B@<eax>(int a1@<ebp>);
void sub_420550();
int DBConn::s_lock_StaticInit();
int DBConn::s_lock2::Static_Init();
int CoreDump::s_lock::StaticInit();
int CExceptionInit::Static_Init();
int __cdecl CQsCheck::StaticInit();
int CBCPLogFile::Static_Init();
int sub_420640();
int CServer::StaticInit();
int g_globalLockTimer::StaticInit();
int timerQueue::Static_Init();
int g_vHandle::StaticInit();
int g_vObject::StaticInit();
int CIODeadlockChecker::StaticInit();
void __cdecl __CxxSetUnhandledExceptionFilter(); // idb
void __cdecl __CxxSetUnhandledExceptionFilter(); // idb
void __cdecl CIODeadlockChecker::s_nAlloc::Init(); // idb
void __cdecl CIOSocket::s_nAlloc::Init(); // idb
void __cdecl CIOServer::s_nAlloc::Init(); // idb
CSlot *CPacketPool::CPacketPool();
int CPacketPool::Static_Init();
void __cdecl CPacket::g_nAlloc::Init(); // idb
int CLog::StaticInit();
int CLogCli::StaticInit();
void __cdecl CLogSocket::s_nAlloc::Init(); // idb
void __cdecl MemoryObject::s_nAlloc::Init(); // idb
int PerfMonitor::Static_Init();
int sub_4208B0();
// void __cdecl CServer::s_nAlloc::Init(); idb
// void __cdecl CServerSocket::s_nAlloc::Init(); idb
int CSQLQueue::StaticInit();
void __cdecl DBConn::s_lock_StaticDeInit(); // idb
// void __cdecl DBConn::s_lock2::Static_DeInit(); idb
// void __cdecl CoreDump::s_lock::StaticDeInit(); idb
void __cdecl CExceptionInit::Destructor(); // idb
// void __cdecl CQsCheck::StaticDeInit(); idb
void __cdecl CBCPLogFile::Static_DeInit(); // idb
void __cdecl CServer::StaticDeInit(); // idb
// void __cdecl g_globalLockTimer::StaticDeInit(); idb
// void __cdecl CIODeadlockChecker::StaticDeInit(); idb
void __cdecl CPacketPool::Destructor(); // idb
// void __cdecl g_vHandle::CallDtor(); idb
// void __cdecl g_vObject::CallDtor(); idb
void __cdecl g_timerQueue::StaticDeinit(); // idb
void __cdecl CLog::Destructor();
void __cdecl CLogCli::Destructor(); // idb
void __cdecl PerfMonitor::Destructor(); // idb
// void __cdecl unknown_libname_66(); idb
void __cdecl CSQLQueue::Destructor();
void __cdecl sub_420A70(); // idb
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// LSTATUS __stdcall RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// LSTATUS __stdcall RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// LSTATUS __stdcall RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// HGDIOBJ __stdcall GetStockObject(int i);
// HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
// BOOL __stdcall GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl);
// BOOL __stdcall TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c);
// COLORREF __stdcall SetTextColor(HDC hdc, COLORREF color);
// BOOL __stdcall GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// DWORD __stdcall TlsAlloc();
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
// LPSTR __stdcall GetCommandLineA();
// void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// BOOL __stdcall IsBadReadPtr(const void *lp, UINT_PTR ucb);
// void __stdcall Sleep(DWORD dwMilliseconds);
// int __stdcall lstrlenW(LPCWSTR lpString);
// LPWSTR __stdcall lstrcatW(LPWSTR lpString1, LPCWSTR lpString2);
// LPWSTR __stdcall lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);
// DWORD __stdcall GetTickCount();
// DWORD __stdcall GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// DWORD __stdcall GetLastError();
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// BOOL __stdcall GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize);
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// DWORD __stdcall SuspendThread(HANDLE hThread);
// DWORD __stdcall GetCurrentThreadId();
// void __stdcall GetLocalTime(LPSYSTEMTIME lpSystemTime);
// BOOL __stdcall SetEndOfFile(HANDLE hFile);
// void __stdcall OutputDebugStringW(LPCWSTR lpOutputString);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// DWORD __stdcall ResumeThread(HANDLE hThread);
// DWORD __stdcall GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);
// HANDLE __stdcall CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
// LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend);
// LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// BOOL __stdcall WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);
// BOOL __stdcall FindClose(HANDLE hFindFile);
// BOOL __stdcall FlushFileBuffers(HANDLE hFile);
// HANDLE __stdcall FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// BOOL __stdcall FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// BOOL __stdcall MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
// BOOL __stdcall CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// UINT __stdcall GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName);
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
// BOOL __stdcall SwitchToThread();
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);
// BOOL __stdcall PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped);
// LONG __stdcall InterlockedExchangeAdd(volatile LONG *Addend, LONG Value);
// DWORD __stdcall WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// BOOL __stdcall GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds);
// DWORD_PTR __stdcall SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask);
// HANDLE __stdcall CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// BOOL __stdcall InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
// BOOL __stdcall DeleteFileW(LPCWSTR lpFileName);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// DWORD __stdcall GetCurrentProcessId();
// HANDLE __stdcall OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// BOOL __stdcall GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// int __stdcall GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData);
// int __stdcall CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2);
// int __stdcall CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// HANDLE __stdcall CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads);
// BOOL __stdcall GetProcessMemoryInfo(HANDLE Process, PPROCESS_MEMORY_COUNTERS ppsmemCounters, DWORD cb);
// int __stdcall TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
// BOOL __stdcall TranslateMessage(const MSG *lpMsg);
// void __stdcall PostQuitMessage(int nExitCode);
// LRESULT __stdcall SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall EndDialog(HWND hDlg, INT_PTR nResult);
// int wsprintfW(LPWSTR, LPCWSTR, ...);
// LRESULT __stdcall DispatchMessageW(const MSG *lpMsg);
// BOOL __stdcall GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// BOOL __stdcall DestroyWindow(HWND hWnd);
// LRESULT __stdcall DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// int __stdcall LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax);
// ATOM __stdcall RegisterClassExW(const WNDCLASSEXW *);
// HCURSOR __stdcall LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName);
// HICON __stdcall LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName);
// BOOL __stdcall UpdateWindow(HWND hWnd);
// BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow);
// HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// HACCEL __stdcall LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName);
// int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// BOOL __stdcall EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint);
// int __stdcall FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr);
// HDC __stdcall BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);
// BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase);
// BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect);
// INT_PTR __stdcall DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// int __stdcall WSASend(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// int __stdcall WSARecv(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// SOCKET __stdcall accept(SOCKET s, struct sockaddr *addr, int *addrlen);
// int __stdcall WSAGetLastError();
// BOOL __stdcall WSAResetEvent(HANDLE hEvent);
// BOOL __stdcall WSACloseEvent(HANDLE hEvent);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// SOCKET __stdcall socket(int af, int type, int protocol);
// int __stdcall WSACleanup();
// int __stdcall setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen);
// int __stdcall bind(SOCKET s, const struct sockaddr *name, int namelen);
// unsigned __int32 __stdcall inet_addr(const char *cp);
// struct hostent *__stdcall gethostbyname(const char *name);
// char *__stdcall inet_ntoa(struct in_addr in);
// u_short __stdcall htons(u_short hostshort);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// int __stdcall getsockname(SOCKET s, struct sockaddr *name, int *namelen);
// int __stdcall closesocket(SOCKET s);
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// int __stdcall WSAEventSelect(SOCKET s, HANDLE hEventObject, __int32 lNetworkEvents);
// HANDLE __stdcall WSACreateEvent();
// int __stdcall listen(SOCKET s, int backlog);
// u_long __stdcall htonl(u_long hostlong);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_405490; // weak
_UNKNOWN loc_40BED0; // weak
int (__thiscall *MemoryPool_vtable_off_422584[3])(void *, char) =
{
  &MemoryPool::DeletingDestructor,
  &MemSmth::Internal::DeletingDestructor,
  &SmallBufferBlock::DeletingDestructor
}; // weak
int (__thiscall *MemSmth::Internal::vtable_off_422588[2])(void *, char) =
{
  &MemSmth::Internal::DeletingDestructor,
  &SmallBufferBlock::DeletingDestructor
}; // weak
int (__thiscall *SmallBufferBlock__vtable)(void *, char) = &SmallBufferBlock::DeletingDestructor; // weak
wchar_t name = 120u; // idb
WCHAR aClass[] = { 0u };
_UNKNOWN unk_422EA4; // weak
wchar_t a_L2logd_ini[13] = L".\\l2logd.ini"; // weak
void *MemoryObject_Vtable_off_424CC0 = &MemoryObject::Release; // weak
void *CIODeadlockChecker::vtable = &CIODeadlockChecker::Release; // weak
CIOSocket_Vtable *CIOSocket_vtable_425060 = &CIOSocket::Release;
void *CIOServer_vtable_offset = &CIOServer::Release; // weak
void *CLogPacket_vtable_425334 = &CPacket::Release; // weak
int *CLogSocket_vtable_426588 = &CLogSocket::Release;
void *CServer_vtable_427984 = &CServer::Release; // weak
void *CServerSocket::vtable = &CServerSocket::Release; // weak
int (__thiscall *std::logic_error::`vftable')(void *, char) = &sub_405810; // weak
int (__thiscall *std::length_error::`vftable')(void *, char) = &sub_405810; // weak
int (__thiscall *std::out_of_range::`vftable')(void *, char) = &sub_405810; // weak
int (__thiscall *std::bad_alloc::`vftable')(void *, char) = &sub_411F72; // weak
int (__thiscall *bad_typeid::`vftable')(void *, char) = &sub_4134C5; // weak
int (__thiscall *__non_rtti_object::`vftable')(void *, char) = &sub_4134C5; // weak
char byte_4296A0[] = { 's' }; // weak
char byte_4296C0[] = { '\x06' }; // weak
const WCHAR String1 = 0u; // idb
_UNKNOWN unk_42A840; // weak
_UNKNOWN unk_42A848; // weak
_UNKNOWN unk_42AC38; // weak
_UNKNOWN unk_42AC98; // weak
_UNKNOWN unk_42BC88; // weak
_UNKNOWN unk_42BC98; // weak
void (**static_initialization_begin)(void) = NULL;
void (**static_initialization_end)(void) = NULL;
char byte_42D084 = '\0'; // weak
char *dword_42D095 = (char *)0x4184;
char ExceptionHandler::s_good = '\x01'; // weak
wchar_t *aExecuteLin_setinserte2 = L"EXECUTE lin_SetInserted '%s','%s',%d,%d,%d,%d,%d,'%s','%s',%d, %d"; // idb
const wchar_t *aExecuteLin_checklogtim2[4] =
{
  L"EXECUTE lin_CheckLogTimeTable2 '%s', %d ",
  L"EXECUTE lin_BulkInsert '%s', '%s' ",
  L"exec sp_spaceused ",
  L"linworld"
};
LPCWSTR aExec_lin_BulkInsert = L"EXECUTE lin_BulkInsert '%s', '%s' "; // idb
wchar_t *aExecSp_spaceused = L"exec sp_spaceused "; // idb
LPARAM aLinworldText = 4342828; // idb
DWORD Config::s_BCPLogFileInterval = 300000u; // idb
unsigned int Config::s_serverReportInterval = 6000u; // idb
int SQL_ATTR_CURSOR_TYPE = 6;
DWORD Config::s_pollingInterval = 6000u; // idb
int Config::s_makeOut = 1;
int Config::s_dbConnectionNum1 = 16;
int dword_42D814 = 1; // weak
int (__thiscall **off_42D820)(void *, char) = &type_info::`vftable'; // weak
COLORREF color[7] = { 0u, 16711680u, 255u, 36095u, 36095u, 36095u, 36095u };
wchar_t *CLog::s_logComponents[7] = { &aClass, L"authd", L"cached", L"server", L"npc", L"logd", L"updated" };
wchar_t *CLog::s_logCategories[8] = { L"system", L"in", L"out", L"db", L"audit", L"err", L"chat", L"chatout" };
bool (__cdecl *CLogSocket::s_packetHandlers[3])(CLogSocket *, const unsigned __int8 *) =
{
  &CLogSocket::packet0_SendMsg,
  &CLogSocket::packet1_CheckStatus,
  &CLogSocket::packet2_TestPacket
};
int (__cdecl *CServerSocket::s_packetHandlers[4])(int, char *) =
{
  &CServerSocket::packet00_SendLog,
  &CServerSocket::packet01_SetCheckStatus,
  &CServerSocket::packet02_CheckLogD,
  &CServerSocket::packet03_ServerStarted
}; // weak
wchar_t *CServerSocket::s_logCategories[8] = { L"system", L"in", L"out", L"db", L"audit", L"err", L"chat", L"chatout" };
wchar_t *CServerSocket::s_logComponents[7] = { &aClass, L"authd", L"cached", L"server", L"npc", L"logd", L"updated" };
int (*off_42D990)(void) = &_fpmath; // weak
DWORD dwTlsIndex = 4294967295u; // idb
char *off_42D9C0 = "(null)"; // idb
wchar_t *off_42D9C4 = L"(null)"; // weak
_UNKNOWN unk_42DA78; // weak
LPCRITICAL_SECTION lpCriticalSection = NULL; // idb
_UNKNOWN unk_42DD90; // weak
int dword_42DDB4 = 3141592654; // weak
int (__cdecl *off_42E040)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &_fptrap; // weak
int (__cdecl *off_42E048)(_DWORD, _DWORD, _DWORD) = &_fptrap; // weak
void *off_42E058 = (void *)0x429822; // weak
void *off_42E14C = &unk_42E0F8; // weak
char byte_42E288[] = { '\x01' }; // weak
int dword_42E290[] = { 932 }; // weak
char aVyv[6] = "`y!"; // weak
char aJ[3] = ""; // weak
size_t cbMultiByte = 1u; // idb
char byte_42E384 = '.'; // idb
_UNKNOWN unk_42E3FC; // weak
_UNKNOWN unk_42E414; // weak
_UNKNOWN unk_42E520; // weak
_UNKNOWN unk_42E680; // weak
SqlConnection *DBConn::s_sqlConnections3 = NULL;
SqlConnection *DBConn::s_sqlConnections2 = NULL;
SqlConnection *DBConn::s_sqlConnections1 = NULL;
wchar_t DBConn::s_connStrBBS[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
};
wchar_t DBConn::s_connStr[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
};
SQLHANDLE DBConn::s_sqlEnvHandle = NULL; // idb
SqlConnection *DBConn::s_connectionsHead1 = NULL;
SqlConnection *DBConn::s_connectionsHead2 = NULL;
SqlConnection *DBConn::s_connectionsHead3 = NULL;
CIOCriticalSection DBConn::s_lock1 = { { NULL, 0, 0, NULL, NULL, 0u }, false };
CIOCriticalSection DBConn::s_lock2 = { { NULL, 0, 0, NULL, NULL, 0u }, false }; // idb
wchar_t *CallStack::s_functions_pre[13];
wchar_t *CallStack::s_functions[13][1000];
int CallStack::s_threadStackSizes[];
char subjectTemplate[256]; // idb
LPTOP_LEVEL_EXCEPTION_FILTER CExceptionInit::s_oldFilter; // idb
WCHAR CExceptionInit::s_logPath[260];
time_t CExceptionInit::s_startTime; // idb
struct _RTL_CRITICAL_SECTION CExceptionInit::s_lock; // idb
char *Config::s_mailServer; // idb
int CExceptionInit::s_errorReported;
CIOCriticalSection CoreDump::s_lock; // idb
_UNKNOWN g_exeptionHalder; // weak
char localBuffer[]; // idb
wchar_t CoreDump::s_writeBuffer[20000];
WCHAR CoreDump::s_stackBuffer[1000];
int CExceptionInit::bBeenHere; // weak
DWORD SqlPooling::s_unusedThreadId2; // idb
int SqlPooling::s_unusedThreadId1; // weak
DWORD g_ThreadId_unused; // idb
HANDLE PerfMonitor_s_thread; // idb
int CBCPLogFile::s_worldIds[10];
HANDLE BCPThread_s_threads[10];
WCHAR MainWindow::s_windowClass[100];
WCHAR MainWindow::s_title[100];
HINSTANCE g_instance; // idb
struct _RTL_CRITICAL_SECTION MemoryPool::s_lock; // idb
wchar_t *CoreDump::s_stackBuffer_limit;
char *Allocator::g_allocatedObjName[65536];
int Allocator::g_allocatedMemory[65536];
int dword_800000; // weak
_UNKNOWN unk_800AC0; // weak
_UNKNOWN unk_800ACC; // weak
int dword_CF0000; // weak
std::vector_string::iterator stru_E07038; // idb
MemoryPool *MMU::s_memPool;
struct _RTL_CRITICAL_SECTION g_qsCheck; // idb
HANDLE CThreadManager::s_threadIds[13];
int CThreadManager::s_IOThreadNumber; // weak
CRITICAL_SECTION CBCPLogFile::s_lock;
int CSQLQueue::s_lastSpaceCheck; // weak
int CSQLQueue::s_dbSize; // weak
int CSQLQueue::s_dbUnusedSize; // weak
CBCPLogFile g_bcpFiles[10];
u_short Config::s_port; // idb
in_addr Config::s_ipAddr;
int Threading::s_ioThreadNumber;
int Config::s_dbConnectionNum2;
WPARAM Config::s_autoBCP;
int Config::s_worldId; // idb
int Config::s_dbConn; // weak
int Config::s_BCPFolder; // idb
int Config::s_sqlExecLimit;
int Config::s_dbBBS;
int Config::s_BCPThreadCount; // weak
int Config::s_dbConnectionNum3;
LockStack LockStack::g_stacks[13];
int g_mmu; // weak
volatile LONG MemoryObject::s_refCountSlots; // idb
CServer g_logServer;
volatile LONG CPacket::g_nPendingPacket; // idb
HANDLE Threads::s_timer;
bool Threads::g_bTerminating;
HANDLE IOCP::g_hWorldCompletionPort;
HANDLE IOCP::g_hCompletionPort; // idb
volatile LONG CIOSocket::s_pendingWriteBytes; // idb
volatile LONG dword_1BD3BD0; // idb
CIOBufferPool *g_IOBufferPools[13];
volatile LONG CReporter::g_nRunningThread; // idb
volatile LONG CIOObject::s_objectInTimer; // idb
CIOCriticalSection g_globalLockTimer; // idb
std::priority_queue_CIOTimer g_timerQueues[13]; // weak
std::vector_HANDLE g_vHandle;
std::vector_Object g_vObject;
CIODeadlockChecker g_deadlock_checker;
int dword_1BD3D70; // weak
int dword_1BD3D74; // weak
volatile __int32 CIODeadlockChecker::s_nAlloc;
int CIOSocket::s_nAlloc;
LONG CIOServer::s_nAlloc;
CSlot CPacketPool::s_slots[16];
int CPacketPool::s_size;
volatile __int32 CPacket::s_nAlloc;
int s_count; // weak
int CLog::s_stackSizes[14];
CLog g_winlog;
CLogCli g_cliLog;
int CLogSocket::s_nAlloc;
volatile LONG MemoryObject::s_instances; // idb
int MemoryObject::s_nAlloc; // weak
PerfMonitor g_perfMonitor;
_UNKNOWN unk_1BD5020; // weak
int CServer::s_nAlloc; // weak
int CServerSocket::s_nAlloc;
CSQLQueue g_sqlPollingQueue;
int dword_1BD5468; // weak
int TlsIndex; // weak
char *dword_1BD5484; // idb
int dword_1BD5498; // weak
int dword_1BD549C; // weak
int dword_1BD54A0; // weak
int dword_1BD54A4; // weak
int dword_1BD54A8; // weak
int dword_1BD54AC; // weak
int dword_1BD54B0; // weak
int dword_1BD54C8; // weak
int dword_1BD5728; // idb
FARPROC lpTopLevelExceptionFilter; // idb
CHAR Filename[260]; // idb
char byte_1BD5874; // weak
int dword_1BD5888; // weak
int dword_1BD5894; // weak
UINT CodePage; // idb
int (__cdecl *dword_1BD58B4)(_DWORD, _DWORD); // weak
int dword_1BD594C; // weak
LCID Locale; // idb
void *dword_1BD5968; // idb
int dword_1BD596C; // weak
char byte_1BD5980; // weak
char byte_1BD5981[]; // weak
UINT dword_1BD5A84; // idb
__int16 word_1BD5A90; // weak
UINT uNumber; // idb
int dword_1BD6BE0[]; // weak
void *dword_1BD6CE0; // idb
int dword_1BD6CEC; // weak
HANDLE hHeap; // idb
int dword_1BD6D00; // weak
int dword_1BD6D10; // weak
int dword_1BD6D14; // weak


//----- (00401000) --------------------------------------------------------
DBConn *__thiscall DBConn::DBConn(DBConn *this)
{
  DBConn *this_; // esi@1
  int sleepCount; // edi@1
  char v4; // [sp+Ch] [bp-10h]@1
  int unused; // [sp+18h] [bp-4h]@1

  this_ = this;
  guard(&v4, L"DBConn::DBConn");
  unused = 0;
  this_->m_sqlConnection = 0;
  sleepCount = 0;
  while ( 1 )
  {
    CIOCriticalSection::Enter(&DBConn::s_lock1, NULL, 0);
    if ( DBConn::s_connectionsHead1->nextConnection )
    {
      this_->m_sqlConnection = DBConn::s_connectionsHead1;
      DBConn::s_connectionsHead1 = DBConn::s_connectionsHead1->nextConnection;
    }
    CIOCriticalSection::Leave(&DBConn::s_lock1, NULL, 0);
    if ( this_->m_sqlConnection )
    {
      break;
    }
    CLog::Add(&g_winlog, LOG_ERROR, L"DBConn::DBConn no available freeSqlPool. Sleep 1 second. (%d times)", ++sleepCount);
    Sleep(1000u);
  }
  this_->m_sqlHandler = this_->m_sqlConnection->stmtSqlHandler;
  this_->m_currentCollumn = 1;
  this_->m_poolIndex = Pool_1;
  memset(this_->m_lastQuery, 0, sizeof(this_->m_lastQuery));
  unused = -1;
  unguard();
  return this_;
}

//----- (004010F0) --------------------------------------------------------
int __thiscall DBConn::DestructorDBConn(DBConn *this)
{
  DBConn *this_; // esi@1
  int poolType; // eax@1
  CIOCriticalSection *v3; // ecx@3
  char v5; // [sp+4h] [bp-10h]@1
  int v6; // [sp+10h] [bp-4h]@1

  this_ = this;
  guard(&v5, L"DBConn::DBConn::~DBConn");
  poolType = this_->m_poolIndex;
  v6 = 0;
  if ( poolType == Pool_2 )
  {
    if ( Config::s_dbConnectionNum2 > 0 )
    {
      SQLFreeStmt(this_->m_sqlHandler, SQL_HANDLE_DBC);
      SQLFreeStmt(this_->m_sqlHandler, SQL_NULL_HANDLE);
      SQLFreeStmt(this_->m_sqlHandler, SQL_HANDLE_STMT);
      CIOCriticalSection::Enter(&DBConn::s_lock2, 0, 0);
      this_->m_sqlConnection->nextConnection = DBConn::s_connectionsHead2;
      DBConn::s_connectionsHead2 = this_->m_sqlConnection;
      v3 = &DBConn::s_lock2;
LABEL_8:
      CIOCriticalSection::Leave(v3, 0, 0);
      goto LABEL_9;
    }
  }
  else
  {
    if ( poolType != Pool_3 )
    {
      SQLFreeStmt(this_->m_sqlHandler, SQL_HANDLE_DBC);
      SQLFreeStmt(this_->m_sqlHandler, SQL_NULL_HANDLE);
      SQLFreeStmt(this_->m_sqlHandler, SQL_HANDLE_STMT);
      CIOCriticalSection::Enter(&DBConn::s_lock1, 0, 0);
      this_->m_sqlConnection->nextConnection = DBConn::s_connectionsHead1;
      DBConn::s_connectionsHead1 = this_->m_sqlConnection;
      v3 = &DBConn::s_lock1;
      goto LABEL_8;
    }
    if ( Config::s_dbConnectionNum3 > 0 )
    {
      SQLFreeStmt(this_->m_sqlHandler, SQL_HANDLE_DBC);
      SQLFreeStmt(this_->m_sqlHandler, SQL_NULL_HANDLE);
      SQLFreeStmt(this_->m_sqlHandler, SQL_HANDLE_STMT);
      CIOCriticalSection::Enter(&DBConn::s_lock2, 0, 0);// FIX ME!!
      this_->m_sqlConnection->nextConnection = DBConn::s_connectionsHead3;
      DBConn::s_connectionsHead3 = this_->m_sqlConnection;
      v3 = &DBConn::s_lock2;
      goto LABEL_8;
    }
  }
LABEL_9:
  v6 = -1;
  return unguard();
}

//----- (00401250) --------------------------------------------------------
int DBConn::AllocSQLPool()
{
  SqlConnection *sqlConnections; // eax@1
  int dbConnectionNum; // edi@1
  int i; // esi@2
  SQLRETURN sqlResult; // ax@3
  SQLSMALLINT outLen; // ST14_2@6
  SQLSMALLINT len; // ax@6
  SQLRETURN sqlResult2; // ax@6
  SQLRETURN sqlResult3; // ax@9
  int v8; // eax@13
  bool v9; // sf@13
  unsigned __int8 v10; // of@13
  int j; // ebx@14
  SqlConnection *nextConn; // esi@15
  int ii; // edx@15
  int v15; // [sp+14h] [bp-81Ch]@1
  char guard; // [sp+18h] [bp-818h]@1
  SQLSMALLINT pcchConnStrOut; // [sp+1Ch] [bp-814h]@6
  WCHAR connStrOut[1024]; // [sp+20h] [bp-810h]@6
  int unused; // [sp+82Ch] [bp-4h]@1

  ::guard(&guard, L"DBConn::DBConn::AllocSQLPool");
  unused = NULL;
  sqlConnections = (SqlConnection *)operator new(12 * Config::s_dbConnectionNum1);
  dbConnectionNum = Config::s_dbConnectionNum1;
  DBConn::s_sqlConnections1 = sqlConnections;
  v15 = NULL;
  if ( Config::s_dbConnectionNum1 > NULL )
  {
    i = 0;
    do                                          // for int i = 0 loop
    {
      sqlConnections[i].nextConnection = NULL;
      sqlResult = SQLAllocHandle(SQL_HANDLE_DBC, DBConn::s_sqlEnvHandle, &DBConn::s_sqlConnections1[i].dbcSqlHandler);
      if ( sqlResult && sqlResult != SQL_SUCCESS_WITH_INFO )
      {
        CLog::Add(&g_winlog, LOG_ERROR, L"hdbc allocation failed");
        DBConn::s_sqlConnections1[i].stmtSqlHandler = NULL;
        DBConn::s_sqlConnections1[i].dbcSqlHandler = NULL;
      }
      else
      {
        SQLSetConnectAttrW(DBConn::s_sqlConnections1[i].dbcSqlHandler, SQL_ATTR_LOGIN_TIMEOUT, (SQLPOINTER)60, NULL);
        SQLSetConnectAttrW(DBConn::s_sqlConnections1[i].dbcSqlHandler, SQL_ATTR_CONNECTION_TIMEOUT, (SQLPOINTER)60, NULL);
        connStrOut[0] = NULL;
        memset(&connStrOut[1], 0, 2044u);
        connStrOut[1023] = 0;
        outLen = lstrlenW(connStrOut);
        len = lstrlenW(DBConn::s_connStr);
        sqlResult2 = SQLDriverConnectW(DBConn::s_sqlConnections1[i].dbcSqlHandler, NULL, DBConn::s_connStr, len, connStrOut, outLen, &pcchConnStrOut, NULL);
        if ( sqlResult2 && sqlResult2 != SQL_SUCCESS_WITH_INFO )
        {
          CLog::Add(&g_winlog, LOG_ERROR, L"hdbc connection failed");
        }
        else
        {
          sqlResult3 = SQLAllocHandle(SQL_HANDLE_STMT, DBConn::s_sqlConnections1[i].dbcSqlHandler, &DBConn::s_sqlConnections1[i].stmtSqlHandler);
          if ( !sqlResult3 || sqlResult3 == SQL_SUCCESS_WITH_INFO )
          {
            goto LABEL_13;
          }
          CLog::Add(&g_winlog, LOG_ERROR, L"stmt allocation failed");
        }
        SQLFreeHandle(SQL_HANDLE_DBC, DBConn::s_sqlConnections1[i].dbcSqlHandler);
        DBConn::s_sqlConnections1[i].stmtSqlHandler = NULL;
        DBConn::s_sqlConnections1[i].dbcSqlHandler = NULL;
      }
LABEL_13:
      dbConnectionNum = Config::s_dbConnectionNum1;
      v8 = v15 + 1;
      ++i;
      v15 = v8;
      v10 = __OFSUB__(v8, Config::s_dbConnectionNum1);
      v9 = v8 - Config::s_dbConnectionNum1 < 0;
      sqlConnections = DBConn::s_sqlConnections1;
    }
    while ( v9 ^ v10 );
  }
  j = 0;
  if ( dbConnectionNum > NULL )
  {
    nextConn = DBConn::s_connectionsHead1;
    ii = 0;
    do
    {
      if ( sqlConnections[ii].stmtSqlHandler )
      {
        if ( nextConn )
        {
          sqlConnections[ii].nextConnection = nextConn;
          sqlConnections = DBConn::s_sqlConnections1;
          dbConnectionNum = Config::s_dbConnectionNum1;
          nextConn = &DBConn::s_sqlConnections1[ii];
        }
        else
        {
          nextConn = &sqlConnections[ii];
        }
        DBConn::s_connectionsHead1 = nextConn;
      }
      ++j;
      ++ii;
    }
    while ( j < dbConnectionNum );
  }
  unused = -1;
  return unguard();
}
// 421428: using guessed type wchar_t aHdbcConnection[23];

//----- (00401470) --------------------------------------------------------
int DBConn::AllocSQLPool2()
{
  SqlConnection *sqlConnections; // eax@2
  int dbConnectionNum; // ecx@2
  int i; // esi@3
  SQLRETURN sqlResult; // ax@4
  SQLSMALLINT outLen; // ST14_2@7
  SQLSMALLINT len; // ax@7
  SQLRETURN sqlResult2; // ax@7
  SQLRETURN sqlResult3; // ax@10
  int v8; // eax@14
  bool v9; // sf@14
  unsigned __int8 v10; // of@14
  int jj; // edi@15
  int ii; // esi@16
  SQLHANDLE nextConn; // ecx@17
  int v15; // [sp+14h] [bp-81Ch]@2
  char v16; // [sp+18h] [bp-818h]@1
  SQLSMALLINT pcchConnStrOut; // [sp+1Ch] [bp-814h]@7
  WCHAR connStrOut[1024]; // [sp+20h] [bp-810h]@7
  int v19; // [sp+82Ch] [bp-4h]@1

  guard(&v16, L"DBConn::DBConn::AllocSQLPool2");
  v19 = NULL;
  if ( Config::s_dbConnectionNum2 )
  {
    sqlConnections = (SqlConnection *)operator new(12 * Config::s_dbConnectionNum2);
    dbConnectionNum = Config::s_dbConnectionNum2;
    DBConn::s_sqlConnections2 = sqlConnections;
    v15 = NULL;
    if ( Config::s_dbConnectionNum2 > NULL )
    {
      i = 0;
      do
      {
        sqlConnections[i].nextConnection = NULL;
        sqlResult = SQLAllocHandle(SQL_HANDLE_DBC, DBConn::s_sqlEnvHandle, &DBConn::s_sqlConnections2[i].dbcSqlHandler);
        if ( sqlResult && sqlResult != SQL_SUCCESS_WITH_INFO )
        {
          CLog::Add(&g_winlog, LOG_ERROR, L"hdbc allocation failed");
          DBConn::s_sqlConnections2[i].stmtSqlHandler = NULL;
          DBConn::s_sqlConnections2[i].dbcSqlHandler = NULL;
        }
        else
        {
          SQLSetConnectAttrW(DBConn::s_sqlConnections2[i].dbcSqlHandler, SQL_ATTR_LOGIN_TIMEOUT, (SQLPOINTER)60, NULL);
          SQLSetConnectAttrW(DBConn::s_sqlConnections2[i].dbcSqlHandler, SQL_ATTR_CONNECTION_TIMEOUT, (SQLPOINTER)60, NULL);
          connStrOut[0] = NULL;
          memset(&connStrOut[1], 0, 2044u);
          connStrOut[1023] = 0;
          outLen = lstrlenW(connStrOut);
          len = lstrlenW(DBConn::s_connStrBBS);
          sqlResult2 = SQLDriverConnectW(DBConn::s_sqlConnections2[i].dbcSqlHandler, NULL, DBConn::s_connStrBBS, len, connStrOut, outLen, &pcchConnStrOut, NULL);
          if ( sqlResult2 && sqlResult2 != SQL_SUCCESS_WITH_INFO )
          {
            CLog::Add(&g_winlog, LOG_ERROR, L"hdbc connection failed");
          }
          else
          {
            sqlResult3 = SQLAllocHandle(SQL_HANDLE_STMT, DBConn::s_sqlConnections2[i].dbcSqlHandler, &DBConn::s_sqlConnections2[i].stmtSqlHandler);
            if ( !sqlResult3 || sqlResult3 == SQL_SUCCESS_WITH_INFO )
            {
              goto LABEL_14;
            }
            CLog::Add(&g_winlog, LOG_ERROR, L"stmt allocation failed");
          }
          SQLFreeHandle(SQL_HANDLE_DBC, DBConn::s_sqlConnections2[i].dbcSqlHandler);
          DBConn::s_sqlConnections2[i].stmtSqlHandler = NULL;
          DBConn::s_sqlConnections2[i].dbcSqlHandler = NULL;
        }
LABEL_14:
        dbConnectionNum = Config::s_dbConnectionNum2;
        v8 = v15 + 1;
        ++i;
        v15 = v8;
        v10 = __OFSUB__(v8, Config::s_dbConnectionNum2);
        v9 = v8 - Config::s_dbConnectionNum2 < 0;
        sqlConnections = DBConn::s_sqlConnections2;
      }
      while ( v9 ^ v10 );
    }
    jj = 0;
    if ( dbConnectionNum > NULL )
    {
      ii = 0;
      do
      {
        nextConn = sqlConnections[ii].stmtSqlHandler;
        if ( nextConn )
        {
          SQLSetStmtAttrW(nextConn, NULL, (SQLPOINTER)SQL_ATTR_CURSOR_TYPE, NULL);// 6
          if ( DBConn::s_connectionsHead2 )
          {
            DBConn::s_sqlConnections2[ii].nextConnection = DBConn::s_connectionsHead2;
            sqlConnections = DBConn::s_sqlConnections2;
            DBConn::s_connectionsHead2 = &DBConn::s_sqlConnections2[ii];
          }
          else
          {
            sqlConnections = DBConn::s_sqlConnections2;
            DBConn::s_connectionsHead2 = &DBConn::s_sqlConnections2[ii];
          }
        }
        ++jj;
        ++ii;
      }
      while ( jj < Config::s_dbConnectionNum2 );
    }
  }
  v19 = -1;
  return unguard();
}
// 421428: using guessed type wchar_t aHdbcConnection[23];

//----- (004016C0) --------------------------------------------------------
int DBConn::AllocSQLPool3()
{
  SqlConnection *sqlConnections; // eax@2
  int dbConnectionNum; // ecx@2
  int i; // esi@3
  SQLRETURN sqlResult; // ax@4
  SQLSMALLINT outLen; // ST14_2@7
  SQLSMALLINT len; // ax@7
  SQLRETURN sqlResult2; // ax@7
  SQLRETURN sqlResult3; // ax@10
  int v8; // eax@14
  bool v9; // sf@14
  unsigned __int8 v10; // of@14
  int jj; // edi@15
  int i_1; // esi@16
  SQLHANDLE nextConn; // ecx@17
  int v15; // [sp+14h] [bp-81Ch]@2
  char v16; // [sp+18h] [bp-818h]@1
  SQLSMALLINT pcchConnStrOut; // [sp+1Ch] [bp-814h]@7
  WCHAR connStrOut[1024]; // [sp+20h] [bp-810h]@7
  int v19; // [sp+82Ch] [bp-4h]@1

  guard(&v16, L"DBConn::DBConn::AllocSQLPool3");
  v19 = 0;
  if ( Config::s_dbConnectionNum2 )             // todo FIX ME!
  {
    sqlConnections = (SqlConnection *)operator new(12 * Config::s_dbConnectionNum3);
    dbConnectionNum = Config::s_dbConnectionNum3;
    DBConn::s_sqlConnections3 = sqlConnections;
    v15 = 0;
    if ( Config::s_dbConnectionNum3 > 0 )
    {
      i = 0;
      do
      {
        sqlConnections[i].nextConnection = 0;
        sqlResult = SQLAllocHandle(SQL_HANDLE_DBC, DBConn::s_sqlEnvHandle, &DBConn::s_sqlConnections3[i].dbcSqlHandler);
        if ( sqlResult && sqlResult != SQL_SUCCESS_WITH_INFO )
        {
          CLog::Add(&g_winlog, LOG_ERROR, L"hdbc allocation failed");
          DBConn::s_sqlConnections3[i].stmtSqlHandler = 0;
          DBConn::s_sqlConnections3[i].dbcSqlHandler = 0;
        }
        else
        {
          SQLSetConnectAttrW(DBConn::s_sqlConnections3[i].dbcSqlHandler, SQL_ATTR_LOGIN_TIMEOUT, (SQLPOINTER)60, 0);
          SQLSetConnectAttrW(DBConn::s_sqlConnections3[i].dbcSqlHandler, SQL_ATTR_CONNECTION_TIMEOUT, (SQLPOINTER)60, 0);
          connStrOut[0] = 0;
          memset(&connStrOut[1], 0, 2044u);
          connStrOut[1023] = 0;
          outLen = lstrlenW(connStrOut);
          len = lstrlenW(DBConn::s_connStrBBS);
          sqlResult2 = SQLDriverConnectW(DBConn::s_sqlConnections3[i].dbcSqlHandler, 0, DBConn::s_connStrBBS, len, connStrOut, outLen, &pcchConnStrOut, 0);
          if ( sqlResult2 && sqlResult2 != SQL_SUCCESS_WITH_INFO )
          {
            CLog::Add(&g_winlog, LOG_ERROR, L"hdbc connection failed");
          }
          else
          {
            sqlResult3 = SQLAllocHandle(SQL_HANDLE_STMT, DBConn::s_sqlConnections3[i].dbcSqlHandler, &DBConn::s_sqlConnections3[i].stmtSqlHandler);
            if ( !sqlResult3 || sqlResult3 == SQL_SUCCESS_WITH_INFO )
            {
              goto LABEL_14;
            }
            CLog::Add(&g_winlog, LOG_ERROR, L"stmt allocation failed");
          }
          SQLFreeHandle(SQL_HANDLE_DBC, DBConn::s_sqlConnections3[i].dbcSqlHandler);
          DBConn::s_sqlConnections3[i].stmtSqlHandler = 0;
          DBConn::s_sqlConnections3[i].dbcSqlHandler = 0;
        }
LABEL_14:
        dbConnectionNum = Config::s_dbConnectionNum3;
        v8 = v15 + 1;
        ++i;
        v15 = v8;
        v10 = __OFSUB__(v8, Config::s_dbConnectionNum3);
        v9 = v8 - Config::s_dbConnectionNum3 < 0;
        sqlConnections = DBConn::s_sqlConnections3;
      }
      while ( v9 ^ v10 );
    }
    jj = 0;
    if ( dbConnectionNum > 0 )
    {
      i_1 = 0;
      do
      {
        nextConn = sqlConnections[i_1].stmtSqlHandler;
        if ( nextConn )
        {
          SQLSetStmtAttrW(nextConn, 0, (SQLPOINTER)SQL_ATTR_CURSOR_TYPE, 0);// 6
          if ( DBConn::s_connectionsHead3 )
          {
            DBConn::s_sqlConnections3[i_1].nextConnection = DBConn::s_connectionsHead3;
            sqlConnections = DBConn::s_sqlConnections3;
            DBConn::s_connectionsHead3 = &DBConn::s_sqlConnections3[i_1];
          }
          else
          {
            sqlConnections = DBConn::s_sqlConnections3;
            DBConn::s_connectionsHead3 = &DBConn::s_sqlConnections3[i_1];
          }
        }
        ++jj;
        ++i_1;
      }
      while ( jj < Config::s_dbConnectionNum3 );
    }
  }
  v19 = -1;
  return unguard();
}
// 421428: using guessed type wchar_t aHdbcConnection[23];

//----- (00401910) --------------------------------------------------------
BOOL __stdcall DBConn::loginDlgProc(HWND hDlg, UINT msgType, WPARAM wparam, LPARAM a4)
{
  char v5; // [sp+0h] [bp-90h]@1
  wchar_t buffer[68]; // [sp+4h] [bp-8Ch]@4
  int v7; // [sp+8Ch] [bp-4h]@1

  guard(&v5, L"DBConn::DBConn::loginDlgProc");
  v7 = 0;
  if ( msgType == WM_INITDIALOG )
  {
    SendDlgItemMessageW(hDlg, CONTROL_LOGDB_LOGIN_EDIT_BOX_FILE_DB, WM_SETTEXT, 0, aLinworldText);
  }
  else if ( msgType == WM_COMMAND && wparam == 1 )// IDOK
  {
    SendDlgItemMessageW(hDlg, CONTROL_LOGDB_LOGIN_EDIT_BOX_FILE_DB, WM_GETTEXT, 64u, (LPARAM)buffer);
    lstrcpyW(DBConn::s_connStr, L"FILEDSN=");
    lstrcatW(DBConn::s_connStr, buffer);
    SendDlgItemMessageW(hDlg, CONTROL_LOGDB_LOGIN_EDIT_BOX_LOGIN_NAME, WM_GETTEXT, 64u, (LPARAM)buffer);
    lstrcatW(DBConn::s_connStr, L";UID=");
    lstrcatW(DBConn::s_connStr, buffer);
    SendDlgItemMessageW(hDlg, CONTROL_LOGDB_LOGIN_EDIT_BOX_PASSWORD, WM_GETTEXT, 64u, (LPARAM)buffer);
    lstrcatW(DBConn::s_connStr, L";PWD=");
    lstrcatW(DBConn::s_connStr, buffer);
    DBConn::SaveStrToReg(DBConn::s_connStr, L"connStr", L"Software\\PROJECT_L2\\L2LOGD");
    EndDialog(hDlg, 0);
  }
  v7 = -1;
  unguard();
  return 0;
}

//----- (00401A70) --------------------------------------------------------
BOOL __stdcall DBConn::loginBBSDlgProc(HWND hDlg, UINT msgType, WPARAM wparam, LPARAM a4)
{
  char v5; // [sp+0h] [bp-90h]@1
  wchar_t buffer[68]; // [sp+4h] [bp-8Ch]@4
  int v7; // [sp+8Ch] [bp-4h]@1

  guard(&v5, L"DBConn::DBConn::loginBBSDlgProc");
  v7 = 0;
  if ( msgType == WM_INITDIALOG )
  {
    SendDlgItemMessageW(hDlg, CONTROL_BBS_LOGIN_EDIT_BOX_FILE_DB, WM_SETTEXT, 0, aLinworldText);
  }
  else if ( msgType == WM_COMMAND && wparam == 1 )
  {
    SendDlgItemMessageW(hDlg, CONTROL_BBS_LOGIN_EDIT_BOX_FILE_DB, WM_GETTEXT, 64u, (LPARAM)buffer);
    lstrcpyW(DBConn::s_connStrBBS, L"FILEDSN=");
    lstrcatW(DBConn::s_connStrBBS, buffer);
    SendDlgItemMessageW(hDlg, CONTROL_BBS_LOGIN_EDIT_BOX_LOGIN_NAME, WM_GETTEXT, 64u, (LPARAM)buffer);
    lstrcatW(DBConn::s_connStrBBS, L";UID=");
    lstrcatW(DBConn::s_connStrBBS, buffer);
    SendDlgItemMessageW(hDlg, CONTROL_BBS_LOGIN_EDIT_BOX_PASSWORD, WM_GETTEXT, 64u, (LPARAM)buffer);
    lstrcatW(DBConn::s_connStrBBS, L";PWD=");
    lstrcatW(DBConn::s_connStrBBS, buffer);
    DBConn::SaveStrToReg(DBConn::s_connStrBBS, L"connStrBBS", L"Software\\PROJECT_L2\\L2LOGD");
    EndDialog(hDlg, 0);
  }
  v7 = -1;
  unguard();
  return 0;
}

//----- (00401BD0) --------------------------------------------------------
bool __cdecl DBConn::Login()
{
  SQLRETURN allocRes; // ax@7
  bool result; // al@9
  SQLSMALLINT sizeConnStrOut; // ST14_2@10
  SQLSMALLINT len; // ax@10
  SQLRETURN sqlResult; // ax@10
  SQLSMALLINT sizeConnStrOut2; // ST14_2@12
  SQLSMALLINT len2; // ax@12
  SQLSMALLINT bbsSizeConnStrOut; // ST14_2@14
  SQLSMALLINT bbsLen; // ax@14
  SQLRETURN i; // ax@14
  SQLSMALLINT bbsSizeConnStrOut2; // ST14_2@16
  SQLSMALLINT bbsLen2; // ax@16
  SQLHANDLE hdbc; // [sp+10h] [bp-1828h]@7
  SQLSMALLINT textLength; // [sp+14h] [bp-1824h]@12
  SQLSMALLINT pcchConnStrOut; // [sp+18h] [bp-1820h]@10
  char v15; // [sp+1Ch] [bp-181Ch]@1
  SQLINTEGER nativeError; // [sp+20h] [bp-1818h]@12
  SQLINTEGER v17; // [sp+24h] [bp-1814h]@16
  SQLWCHAR sqlState[512]; // [sp+28h] [bp-1810h]@12
  SQLWCHAR errorText[512]; // [sp+428h] [bp-1410h]@12
  WCHAR connStrOut[1024]; // [sp+828h] [bp-1010h]@10
  WCHAR connStrOutBBS[1024]; // [sp+1028h] [bp-810h]@14
  int unused; // [sp+1834h] [bp-4h]@1

  guard(&v15, L"DBConn::Login");
  unused = 0;
  if ( !DBConn::LoadStrFromReg(DBConn::s_connStr, L"connStr", L"Software\\PROJECT_L2\\L2LOGD") )
  {
    DialogBoxParamW(g_instance, (LPCWSTR)DIALOG_LOGDB_LOGIN, NULL, DBConn::loginDlgProc, 0);
  }
  if ( Config::s_dbBBS == true )
  {
    if ( !DBConn::LoadStrFromReg(DBConn::s_connStrBBS, L"connStrBBS", L"Software\\PROJECT_L2\\L2LOGD") )
    {
      DialogBoxParamW(g_instance, (LPCWSTR)DIALOG_BBS_LOGIN, 0, DBConn::loginBBSDlgProc, 0);
    }
  }
  else
  {
    wcscpy(DBConn::s_connStrBBS, DBConn::s_connStr);
  }
  allocRes = SQLAllocHandle(SQL_HANDLE_DBC, DBConn::s_sqlEnvHandle, &hdbc);
  if ( allocRes && allocRes != SQL_SUCCESS_WITH_INFO )
  {
    CLog::Add(&g_winlog, LOG_ERROR, L"hdbc allocation failed");
    unused = -1;
    unguard();
    result = 0;
  }
  else
  {
    SQLSetConnectAttrW(hdbc, SQL_ATTR_LOGIN_TIMEOUT, (SQLPOINTER)60, 0);
    SQLSetConnectAttrW(hdbc, SQL_ATTR_CONNECTION_TIMEOUT, (SQLPOINTER)60, 0);
    connStrOut[0] = 0;
    memset(&connStrOut[1], 0, 0x7FCu);
    connStrOut[1023] = 0;
    sizeConnStrOut = lstrlenW(connStrOut);
    len = lstrlenW(DBConn::s_connStr);
    for ( sqlResult = SQLDriverConnectW(hdbc, 0, DBConn::s_connStr, len, connStrOut, sizeConnStrOut, &pcchConnStrOut, 0); sqlResult; sqlResult = SQLDriverConnectW(hdbc, 0, DBConn::s_connStr, len2, connStrOut, sizeConnStrOut2, &pcchConnStrOut, 0) )
    {
      if ( sqlResult == SQL_SUCCESS_WITH_INFO )
      {
        break;
      }
      SQLGetDiagRecW(SQL_HANDLE_DBC, hdbc, 1, sqlState, &nativeError, errorText, 512, &textLength);
      CLog::Add(&g_winlog, LOG_ERROR, L"%s", sqlState);
      CLog::Add(&g_winlog, LOG_ERROR, L"%s", errorText);
      DialogBoxParamW(g_instance, (LPCWSTR)DIALOG_LOGDB_LOGIN, 0, DBConn::loginDlgProc, 0);
      sizeConnStrOut2 = lstrlenW(connStrOut);
      len2 = lstrlenW(DBConn::s_connStr);
    }
    SQLDisconnect(hdbc);
    if ( Config::s_dbBBS == true )
    {
      SQLSetConnectAttrW(hdbc, SQL_ATTR_LOGIN_TIMEOUT, (SQLPOINTER)60, 0);
      SQLSetConnectAttrW(hdbc, SQL_ATTR_CONNECTION_TIMEOUT, (SQLPOINTER)60, 0);
      connStrOutBBS[0] = 0;
      memset(&connStrOutBBS[1], 0, 0x7FCu);
      connStrOutBBS[1023] = 0;
      bbsSizeConnStrOut = lstrlenW(connStrOutBBS);
      bbsLen = lstrlenW(DBConn::s_connStrBBS);
      for ( i = SQLDriverConnectW(hdbc, 0, DBConn::s_connStrBBS, bbsLen, connStrOutBBS, bbsSizeConnStrOut, &textLength, 0); i; i = SQLDriverConnectW(hdbc, 0, DBConn::s_connStrBBS, bbsLen2, connStrOutBBS, bbsSizeConnStrOut2, &textLength, 0) )
      {
        if ( i == SQL_SUCCESS_WITH_INFO )
        {
          break;
        }
        SQLGetDiagRecW(SQL_HANDLE_DBC, hdbc, 1, errorText, &v17, sqlState, 512, (SQLSMALLINT *)&nativeError);
        CLog::Add(&g_winlog, LOG_ERROR, L"%s", errorText);
        CLog::Add(&g_winlog, LOG_ERROR, L"%s", sqlState);
        DialogBoxParamW(g_instance, (LPCWSTR)DIALOG_BBS_LOGIN, 0, DBConn::loginBBSDlgProc, 0);
        bbsSizeConnStrOut2 = lstrlenW(connStrOutBBS);
        bbsLen2 = lstrlenW(DBConn::s_connStrBBS);
      }
      SQLDisconnect(hdbc);
    }
    SQLFreeHandle(SQL_HANDLE_DBC, hdbc);
    unused = -1;
    unguard();
    result = 1;
  }
  return result;
}

//----- (00401FC0) --------------------------------------------------------
bool __thiscall DBConn::Fetch(DBConn *this)
{
  DBConn *this_; // esi@1
  SQLHANDLE handler; // eax@1
  bool empty; // zf@1
  SQLRETURN sqlResult; // ax@3
  char v6; // [sp+4h] [bp-818h]@1
  SQLSMALLINT pcchErrorMsg; // [sp+8h] [bp-814h]@6
  SQLINTEGER pfNativeError; // [sp+Ch] [bp-810h]@6
  wchar_t szSqlState[512]; // [sp+10h] [bp-80Ch]@6
  wchar_t szErrorMsg[512]; // [sp+410h] [bp-40Ch]@6
  int unused; // [sp+818h] [bp-4h]@1

  this_ = this;
  guard(&v6, L"DBConn::Fetch");
  handler = this_->m_sqlHandler;
  empty = this_->m_sqlHandler == SQL_NULL_HANDLE;
  unused = 0;
  if ( empty )
  {
    CLog::Add(&g_winlog, LOG_ERROR, L"Fetch error = (STMT)");
LABEL_7:
    unused = -1;
    unguard();
    return false;
  }
  sqlResult = SQLFetch(handler);
  if ( sqlResult && sqlResult != SQL_SUCCESS_WITH_INFO )
  {
    if ( sqlResult != SQL_NO_DATA )
    {
      SQLGetDiagRecW(SQL_HANDLE_STMT, this_->m_sqlHandler, SQL_HANDLE_ENV, szSqlState, &pfNativeError, szErrorMsg, 512, &pcchErrorMsg);
      CLog::Add(&g_winlog, LOG_ERROR, L"fetch error");
      CLog::Add(&g_winlog, LOG_ERROR, L"sqlstate %s", szSqlState);
      CLog::Add(&g_winlog, LOG_ERROR, L"msgText %s", szErrorMsg);
      CLog::Add(&g_winlog, LOG_ERROR, L"sql %s", this_->m_lastQuery);
    }
    goto LABEL_7;
  }
  unused = -1;
  unguard();
  return true;
}

//----- (00402120) --------------------------------------------------------
int __stdcall DBConn::Error(SQLSMALLINT handleType, SQLHANDLE handle, const wchar_t *query)
{
  SQLRETURN sqlResult; // bx@1
  signed int maxLen; // eax@3
  SQLSMALLINT pcchErrorMsg; // [sp+Ch] [bp-C1Ch]@1
  char v7; // [sp+10h] [bp-C18h]@1
  SQLINTEGER pfNativeError; // [sp+14h] [bp-C14h]@1
  wchar_t truncatedQuery[512]; // [sp+18h] [bp-C10h]@2
  wchar_t szErrorMsg[512]; // [sp+418h] [bp-810h]@1
  wchar_t szSqlState[512]; // [sp+818h] [bp-410h]@1
  int v12; // [sp+C24h] [bp-4h]@1

  guard(&v7, L"DBConn::Error");
  v12 = 0;
  sqlResult = SQLGetDiagRecW(handleType, handle, 1, szSqlState, &pfNativeError, szErrorMsg, 1024, &pcchErrorMsg);
  if ( query )
  {
    truncatedQuery[0] = 0;
    memset(&truncatedQuery[1], 0, 1020u);
    truncatedQuery[511] = 0;
    if ( wcslen(query) >= 511 )
    {
      maxLen = 511;
    }
    else
    {
      maxLen = wcslen(query);
    }
    wcsncpy(truncatedQuery, query, maxLen);
    CLog::Add(&g_winlog, LOG_ERROR, L"Error sql: %s (%d)", truncatedQuery, sqlResult);
  }
  if ( !sqlResult )
  {
    CLog::Add(&g_winlog, LOG_ERROR, L"Error %s:%s", szSqlState, szErrorMsg);
  }
  v12 = -1;
  return unguard();
}

//----- (00402250) --------------------------------------------------------
int __thiscall DBConn::Bind(DBConn *this, wchar_t *value, int length)
{
  DBConn *this_; // esi@1
  SQLUSMALLINT curCollumn; // ax@1
  char v6; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v6, L"DBConn::Bind");
  curCollumn = this_->m_currentCollumn;
  ++this_->m_currentCollumn;
  SQLBindCol(this_->m_sqlHandler, curCollumn, 0xFFF8, value, length, NULL);// SQL_C_WCHAR 
  return unguard();
}

//----- (004022A0) --------------------------------------------------------
int __thiscall DBConn::ResetHtmt(DBConn *this)
{
  DBConn *this_; // esi@1
  SQLHSTMT handler; // ST00_4@1
  char v4; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v4, L"DBConn::Bind");                  // FIX ME!
  handler = this_->m_sqlHandler;
  this_->m_currentCollumn = 1;
  SQLFreeStmt(handler, SQL_UNBIND);
  SQLFreeStmt(this_->m_sqlHandler, SQL_HANDLE_STMT);
  SQLCloseCursor(this_->m_sqlHandler);
  return unguard();
}

//----- (004022F0) --------------------------------------------------------
int __thiscall DBConn::BindNullable(DBConn *this, int *value, SQLINTEGER *indicator)
{
  DBConn *this_; // esi@1
  SQLUSMALLINT curCollumn; // ax@1
  char v6; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v6, L"void DBConn::BindNullable(int *pValue, SQLLEN *pIndicator)");
  curCollumn = this_->m_currentCollumn;
  ++this_->m_currentCollumn;
  SQLBindCol(this_->m_sqlHandler, curCollumn, SQL_INTEGER, value, 4, indicator);
  return unguard();
}

//----- (00402340) --------------------------------------------------------
int __cdecl DBConn::Init()
{
  DBConn *v0; // ecx@0
  SQLRETURN allocRes; // ax@1
  SQLRETURN allocRes2; // ax@3
  DBConn *this_; // [sp+0h] [bp-10h]@1
  int unused; // [sp+Ch] [bp-4h]@1

  this_ = v0;
  guard(&this_, L"DBConn::DBConn::Init");
  unused = 0;
  SQLSetEnvAttr((SQLHENV)SQL_NULL_HANDLE, SQL_ATTR_CONNECTION_POOLING, (SQLPOINTER)SQL_CP_ONE_PER_DRIVER, SQL_TINYINT);
  DBConn::s_sqlEnvHandle = 0;
  allocRes = SQLAllocHandle(SQL_HANDLE_ENV, (SQLHANDLE)SQL_NULL_HANDLE, &DBConn::s_sqlEnvHandle);
  if ( allocRes && allocRes != SQL_SUCCESS_WITH_INFO || (allocRes2 = SQLSetEnvAttr(DBConn::s_sqlEnvHandle, SQL_ATTR_ODBC_VERSION, (SQLPOINTER)SQL_OV_ODBC3, 0)) != 0 && allocRes2 != SQL_SUCCESS_WITH_INFO )
  {
    CLog::Add(&g_winlog, LOG_ERROR, L"db env allocation failed");
  }
  else if ( DBConn::Login() )
  {
    DBConn::AllocSQLPool();
    DBConn::AllocSQLPool2();
    if ( Config::s_dbConn > 0 )
    {
      DBConn::AllocSQLPool3();
    }
  }
  else
  {
    CLog::Add(&g_winlog, LOG_ERROR, L"db login failed");
    SQLFreeHandle(SQL_HANDLE_ENV, DBConn::s_sqlEnvHandle);
    DBConn::s_sqlEnvHandle = 0;
  }
  unused = -1;
  return unguard();
}
// 19D7E00: using guessed type int Config::s_dbConn;

//----- (00402450) --------------------------------------------------------
bool DBConn::Execute(DBConn *this, const wchar_t *format, ...)
{
  DBConn *this_; // ebx@1
  bool secondPool; // zf@1
  int len; // esi@3
  __int16 sqlResult3; // di@3
  DWORD before; // ebx@4
  int sqlResult; // eax@4
  DWORD after; // esi@4
  signed int maxLen; // eax@6
  signed int maxLen2; // eax@11
  char v12; // [sp+10h] [bp-4418h]@1
  int sqlResult2; // [sp+14h] [bp-4414h]@4
  wchar_t logMsg[512]; // [sp+18h] [bp-4410h]@5
  SQLWCHAR sqlQuery[8198]; // [sp+418h] [bp-4010h]@3
  int unused; // [sp+4424h] [bp-4h]@1
  va_list va; // [sp+4438h] [bp+10h]@1

  va_start(va, format);
  guard(&v12, L"DBConn::Execute");
  this_ = this;
  secondPool = this->m_poolIndex == Pool_2;
  unused = 0;
  if ( secondPool && !Config::s_dbConnectionNum2 )
  {
    goto LABEL_16;
  }
  len = vswprintf(sqlQuery, format, va);
  sqlResult3 = -1;                              // SQL_ERROR
  if ( len > 0 )
  {
    before = GetTickCount();
    LOWORD(sqlResult) = SQLExecDirectW(this->m_sqlHandler, sqlQuery, len);
    sqlResult2 = sqlResult;
    after = GetTickCount() - before;
    if ( after > Config::s_sqlExecLimit )
    {
      logMsg[0] = 0;
      memset(&logMsg[1], 0, 1020u);
      logMsg[511] = 0;
      if ( wcslen(sqlQuery) >= 511 )
      {
        maxLen = 511;
      }
      else
      {
        maxLen = wcslen(sqlQuery);
      }
      wcsncpy(logMsg, sqlQuery, maxLen);
      CLog::Add(&g_winlog, LOG_ERROR, L"sql execution time [%d]ms, sql[%s]", after, logMsg);
    }
    this_ = this;
    sqlResult3 = sqlResult2;
  }
  if ( wcslen(sqlQuery) >= 511 )
  {
    maxLen2 = 511;
  }
  else
  {
    maxLen2 = wcslen(sqlQuery);
  }
  wcsncpy(this_->m_lastQuery, sqlQuery, maxLen2);
  if ( sqlResult3 && sqlResult3 != SQL_SUCCESS_WITH_INFO )
  {
    DBConn::Error(SQL_HANDLE_STMT, this_->m_sqlHandler, sqlQuery);
LABEL_16:
    unused = -1;
    unguard();
    return 0;
  }
  unused = -1;
  unguard();
  return 1;
}

//----- (00402630) --------------------------------------------------------
bool __cdecl Config::ExceptionMailing()
{
  wchar_t value[100]; // [sp+0h] [bp-C8h]@1

  GetPrivateProfileStringW(L"Setting", L"ExceptionMailing", L"True", value, 200u, L".\\l2server.ini");
  return _wcsicmp(value, L"True") == 0;
}

//----- (00402690) --------------------------------------------------------
CHAR *__usercall Utils::UnicodeToMultibyte_WithoutAllocation@<eax>(const WCHAR *wideMsg@<edi>)
{
  int newLength; // esi@1
  BOOL usedDefaultChar; // [sp+8h] [bp-4h]@1

  newLength = WideCharToMultiByte(CP_THREAD_ACP, 0, wideMsg, -1, 0, 0, 0, 0);
  GetLastError();
  WideCharToMultiByte(CP_THREAD_ACP, 0, wideMsg, -1, &localBuffer[1], newLength, 0, &usedDefaultChar);
  localBuffer[newLength] = 0;
  return &localBuffer[1];
}

//----- (004026E0) --------------------------------------------------------
BOOL CoreDump::WriteToFile(HANDLE hFile, wchar_t *format, ...)
{
  DWORD unused; // ecx@0
  CHAR *str; // eax@1
  DWORD bytesWritten; // [sp+0h] [bp-4h]@1
  va_list va; // [sp+10h] [bp+Ch]@1

  va_start(va, format);
  bytesWritten = unused;
  vswprintf(CoreDump::s_writeBuffer, format, va);
  str = Utils::UnicodeToMultibyte_WithoutAllocation(CoreDump::s_writeBuffer);
  return WriteFile(hFile, str, strlen(str), &bytesWritten, 0);
}
// 4026E0: erroneously detected ellipsis type has been ignored

//----- (00402740) --------------------------------------------------------
const char *__thiscall CoreDump::ExceptionToString(int exceptionCode)
{
  int i; // eax@1
  ExceptionName exceptions[24]; // [sp+0h] [bp-C0h]@1

  exceptions[0].code = DBG_CONTROL_C;
  exceptions[0].name = "a Control-C";
  exceptions[1].code = DBG_CONTROL_BREAK;
  exceptions[1].name = "a Control-Break";
  exceptions[2].code = EXCEPTION_DATATYPE_MISALIGNMENT;
  exceptions[2].name = "a Datatype Misalignment";
  exceptions[3].code = EXCEPTION_BREAKPOINT;
  exceptions[3].name = "a Breakpoint";
  exceptions[4].code = EXCEPTION_ACCESS_VIOLATION;
  exceptions[4].name = "an Access Violation";
  exceptions[5].code = EXCEPTION_IN_PAGE_ERROR;
  exceptions[5].name = "an In Page Error";
  exceptions[6].code = STATUS_NO_MEMORY;
  exceptions[6].name = "a No Memory";
  exceptions[7].code = EXCEPTION_ILLEGAL_INSTRUCTION;
  exceptions[7].name = "an Illegal Instruction";
  exceptions[8].code = EXCEPTION_NONCONTINUABLE_EXCEPTION;
  exceptions[8].name = "a Noncontinuable Exception";
  exceptions[9].code = EXCEPTION_INVALID_DISPOSITION;
  exceptions[9].name = "an Invalid Disposition";
  exceptions[10].code = EXCEPTION_ARRAY_BOUNDS_EXCEEDED;
  exceptions[10].name = "a Array Bounds Exceeded";
  exceptions[11].code = EXCEPTION_FLT_DENORMAL_OPERAND;
  exceptions[11].name = "a Float Denormal Operand";
  exceptions[12].code = EXCEPTION_FLT_DIVIDE_BY_ZERO;
  exceptions[12].name = "a Float Divide by Zero";
  exceptions[13].code = EXCEPTION_FLT_INEXACT_RESULT;
  exceptions[13].name = "a Float Inexact Result";
  exceptions[14].code = EXCEPTION_FLT_INVALID_OPERATION;
  exceptions[14].name = "a Float Invalid Operation";
  exceptions[15].code = EXCEPTION_FLT_OVERFLOW;
  exceptions[15].name = "a Float Overflow";
  exceptions[16].code = EXCEPTION_FLT_STACK_CHECK;
  exceptions[16].name = "a Float Stack Check";
  exceptions[17].code = EXCEPTION_FLT_UNDERFLOW;
  exceptions[17].name = "a Float Underflow";
  exceptions[18].code = EXCEPTION_INT_DIVIDE_BY_ZERO;
  exceptions[18].name = "an Integer Divide by Zero";
  exceptions[19].code = EXCEPTION_INT_OVERFLOW;
  exceptions[19].name = "an Integer Overflow";
  exceptions[20].code = EXCEPTION_PRIV_INSTRUCTION;
  exceptions[20].name = "a Privileged Instruction";
  exceptions[21].code = EXCEPTION_STACK_OVERFLOW;
  exceptions[21].name = "a Stack Overflow";
  exceptions[22].code = STATUS_DLL_INIT_FAILED;
  exceptions[22].name = "a DLL Initialization Failed";
  exceptions[23].code = 0xE06D7363;
  exceptions[23].name = "a Microsoft C++ Exception";
  i = 0;
  while ( exceptionCode != exceptions[i].code )
  {
    if ( (unsigned int)++i >= 24 )
    {
      return "Unknown exception type";
    }
  }
  return exceptions[i].name;
}

//----- (00402920) --------------------------------------------------------
wchar_t *__usercall Utils::GetFileName@<eax>(const wchar_t *str@<esi>)
{
  wchar_t *backSlash; // eax@1
  wchar_t *nextSymbol; // eax@2

  backSlash = wcsrchr(str, '\\');
  if ( backSlash )
  {
    nextSymbol = backSlash + 1;
  }
  else
  {
    nextSymbol = (wchar_t *)str;
  }
  return nextSymbol;
}

//----- (00402940) --------------------------------------------------------
char __cdecl CExceptionInit::SendFile(SOCKET socket, const wchar_t *fileToSend)
{
  HANDLE hFile; // eax@1
  void *hFile2; // esi@1
  char result; // al@2
  DWORD bytesRead; // [sp+8h] [bp-2004h]@3
  char buffer[8192]; // [sp+Ch] [bp-2000h]@3

  hFile = CreateFileW(fileToSend, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
  hFile2 = hFile;
  if ( hFile == (HANDLE)INVALID_HANDLE_VALUE )
  {
    result = true;                              // TODO: Fix me: change to false
  }
  else
  {
    if ( ReadFile(hFile, buffer, 0x2000u, &bytesRead, 0) )
    {
      while ( bytesRead )
      {
        if ( send(socket, buffer, bytesRead, 0) <= 0 )
        {
          return 0;
        }
        if ( !ReadFile(hFile2, buffer, 0x2000u, &bytesRead, 0) )
        {
          break;
        }
      }
    }
    CloseHandle(hFile2);
    result = true;
  }
  return result;
}

//----- (00402A00) --------------------------------------------------------
bool __usercall CExceptionInit::SendMail@<al>(const char *mailTo@<eax>, const char *mailServer, const char *mailFrom, const wchar_t *errorLogPath)
{
  const char *mailTo2; // ebx@1
  SOCKET socket; // eax@3
  SOCKET socket1; // ebp@3
  char v8; // al@8
  bool v9; // sf@8
  unsigned __int8 v10; // of@8
  struct hostent *host; // eax@11
  char *v12; // eax@20
  char result2; // si@24
  int optval; // [sp+4h] [bp-AD4h]@5
  sockaddr_in name; // [sp+8h] [bp-AD0h]@7
  sockaddr_in localAddress; // [sp+18h] [bp-AC0h]@20
  DWORD nSize; // [sp+28h] [bp-AB0h]@20
  int namelen; // [sp+2Ch] [bp-AACh]@20
  int result1; // [sp+30h] [bp-AA8h]@1
  time_t now; // [sp+34h] [bp-AA4h]@20
  CHAR pcName[16]; // [sp+38h] [bp-AA0h]@20
  char header[256]; // [sp+48h] [bp-A90h]@14
  char buf[2048]; // [sp+148h] [bp-990h]@14
  struct WSAData wsaData; // [sp+948h] [bp-190h]@1

  mailTo2 = mailTo;
  result1 = false;
  if ( WSAStartup(WINSOCK_VERSION, &wsaData) )
  {
    return false;
  }
  socket = ::socket(SOCK_DGRAM, AF_UNIX, IPPROTO_IP);
  socket1 = socket;
  if ( socket == INVALID_SOCKET )
  {
    WSACleanup();
    return false;
  }
  optval = 5000;
  if ( setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, (const char *)&optval, 4) == SOCKET_ERROR )
  {
    goto LABEL_25;
  }
  optval = 5000;
  if ( setsockopt(socket1, SOL_SOCKET, SO_SNDTIMEO, (const char *)&optval, 4) == SOCKET_ERROR )
  {
    goto LABEL_25;
  }
  name.sin_family = SOCK_DGRAM;
  name.sin_addr.S_un.S_addr = 0;
  name.sin_port = 0;
  if ( bind(socket1, (const struct sockaddr *)&name, sizeof(SOCKADDR_IN)) == SOCKET_ERROR )
  {
    goto LABEL_25;
  }
  v8 = *mailServer;
  v10 = __OFSUB__(*mailServer, '0');
  v9 = (char)(*mailServer - '0') < 0;
  name.sin_family = SOCK_DGRAM;
  if ( v9 ^ v10 || v8 > '9' )
  {
    host = gethostbyname(mailServer);           // mailFrom is hostname, not ip
    if ( !host )
    {
      goto LABEL_25;
    }
    qmemcpy(&name.sin_addr, *(const void **)host->h_addr_list, host->h_length);
    inet_ntoa(name.sin_addr);
  }
  else                                          // mailFrom is ip
  {
    name.sin_addr.S_un.S_addr = inet_addr(mailServer);
  }
  name.sin_port = htons(25u);
  if ( connect(socket1, (const struct sockaddr *)&name, 16) == SOCKET_ERROR )
  {
    goto LABEL_25;
  }
  recv(socket1, buf, 0x800, 0);
  sprintf(header, "HELO %s\r\n", Config::s_mailServer);
  if ( send(socket1, header, strlen(header), 0) <= 0 )
  {
    goto LABEL_25;
  }
  recv(socket1, buf, 0x800, 0);
  sprintf("MAIL From: <l2npc@ncsoft.co.kr>\r\n", "MAIL From: <%s>\r\n", mailFrom);
  if ( send(socket1, "MAIL From: <l2npc@ncsoft.co.kr>\r\n", strlen("MAIL From: <l2npc@ncsoft.co.kr>\r\n"), 0) <= 0 )
  {
    goto LABEL_25;
  }
  recv(socket1, buf, 0x800, 0);
  for ( ; *mailTo2; mailTo2 += strlen(mailTo2) + 1 )
  {
    sprintf("RCPT To: <narcasse@ncsoft.co.kr>\r\n", "RCPT To: <%s>\r\n", mailTo2);
    if ( send(socket1, "RCPT To: <narcasse@ncsoft.co.kr>\r\n", strlen("RCPT To: <narcasse@ncsoft.co.kr>\r\n"), 0) <= 0 )
    {
      goto LABEL_25;
    }
    recv(socket1, buf, 0x800, 0);
  }
  if ( send(socket1, "DATA\r\n", strlen("DATA\r\n"), 0) <= 0 )
  {
    goto LABEL_25;
  }
  recv(socket1, buf, 0x800, 0);
  now = time(0);
  *(_DWORD *)&localAddress.sin_family = 0;
  localAddress.sin_addr.S_un.S_addr = 0;
  *(_DWORD *)&localAddress.sin_zero[0] = 0;
  *(_DWORD *)&localAddress.sin_zero[4] = 0;
  namelen = 0x10;
  getsockname(socket1, (struct sockaddr *)&localAddress, &namelen);
  nSize = 0x10;
  GetComputerNameA(pcName, &nSize);
  v12 = Utils::TimeToString(&now);
  sprintf(subjectTemplate, "Subject: LogD [%d][%s](%d.%d.%d.%d) crashed at %s\r\n", dword_42D814, pcName, localAddress.sin_addr.S_un.S_un_b.s_b1, localAddress.sin_addr.S_un.S_un_b.s_b2, localAddress.sin_addr.S_un.S_un_b.s_b3, localAddress.sin_addr.S_un.S_un_b.s_b4, v12);
  if ( send(socket1, subjectTemplate, strlen(subjectTemplate), 0) <= 0 || !CExceptionInit::SendFile(socket1, errorLogPath) || send(socket1, "\r\n.\r\n", strlen("\r\n.\r\n"), 0) <= 0 || (recv(socket1, buf, 2048, 0), send(socket1, "QUIT\r\n", strlen("QUIT\r\n"), 0) <= 0) )
  {
LABEL_25:
    result2 = result1;
    goto LABEL_26;
  }
  recv(socket1, buf, 0x800, 0);
  result2 = true;
LABEL_26:
  closesocket(socket1);
  WSACleanup();
  return result2;
}
// 42D814: using guessed type int dword_42D814;

//----- (00402E10) --------------------------------------------------------
BOOL __usercall CoreDump::WriteCallStack@<eax>(ThreadIndices threadIndex@<eax>, HANDLE hFile@<ebx>, const wchar_t *threadName)
{
  ThreadIndices threadIndex1; // esi@1
  bool currentThread; // zf@1
  const wchar_t *label; // eax@1
  int stackIndex; // ebp@3
  wchar_t **funcName; // edi@4
  int stackSize; // eax@6
  ThreadIndices threadIndex2; // esi@8
  volatile __int32 i; // ebp@8
  LockFrame *frame; // edi@9

  threadIndex1 = threadIndex;
  currentThread = threadIndex == *(_DWORD *)(*(_DWORD *)(__readfsdword(0x2C) + 4 * TlsIndex) + 8);
  label = L"good";
  if ( currentThread )
  {
    label = L"ahehe";
  }
  CoreDump::WriteToFile(hFile, L"%s [%d] (%s):  ", threadName, threadIndex1, label);
  stackIndex = 0;
  if ( CallStack::s_threadStackSizes[threadIndex1] - 1 > 0 )
  {
    funcName = CallStack::s_functions[threadIndex1];
    do
    {
      CoreDump::WriteToFile(hFile, L"%s -> ", *funcName);
      ++stackIndex;
      ++funcName;
    }
    while ( stackIndex < CallStack::s_threadStackSizes[threadIndex1] - 1 );
  }
  stackSize = CallStack::s_threadStackSizes[threadIndex1];
  if ( stackSize > 0 )
  {
    CoreDump::WriteToFile(hFile, L"%s\r\n", CallStack::s_functions_pre[stackSize + 1000 * threadIndex1]);
  }
  CoreDump::WriteToFile(hFile, L"    Lock Stack  : ");
  threadIndex2 = threadIndex1;
  i = 0;
  if ( LockStack::g_stacks[threadIndex2].m_lockCount <= 0 )
  {
    return CoreDump::WriteToFile(hFile, L"\r\n\r\n");
  }
  frame = (LockFrame *)((char *)&LockStack::g_stacks[threadIndex2].m_lockFrames[0] + 12);
  do
  {
    CoreDump::WriteToFile(hFile, L"%s(%d[%x])", frame[-1].m_line, frame->m_deep, frame->m_deep);// FIX ME!
    if ( i != LockStack::g_stacks[threadIndex2].m_lockCount - 1 )
    {
      CoreDump::WriteToFile(hFile, L" -> ");
    }
    ++i;
    ++frame;
  }
  while ( i < LockStack::g_stacks[threadIndex2].m_lockCount );
  return CoreDump::WriteToFile(hFile, L"\r\n\r\n");
}
// 421CB4: using guessed type wchar_t aAhehe[6];
// 421CC0: using guessed type wchar_t aGood[5];
// 1BD5478: using guessed type int TlsIndex;

//----- (00402F30) --------------------------------------------------------
void __thiscall CoreDump::CreateReport(EXCEPTION_POINTERS *ex)
{
  EXCEPTION_POINTERS *exceptionInfo; // edi@1
  HANDLE hFile0; // eax@1
  void *hFile1; // ebx@1
  int size; // eax@3
  int second; // ST3C_4@3
  int minute; // ST38_4@3
  int hour; // ST34_4@3
  int day; // ST30_4@3
  int month; // ST2C_4@3
  int year; // ST28_4@3
  DWORD threadId; // eax@3
  PEXCEPTION_RECORD exceptionRecord; // esi@3
  PCONTEXT context; // edi@3
  wchar_t *moduleName; // eax@5
  DWORD eip_; // ST3C_4@7
  DWORD segCs; // ST38_4@7
  wchar_t *moduleName1; // ST34_4@7
  const char *exceptionStr; // eax@7
  struct tm *startTime; // eax@7
  const wchar_t *label; // eax@9
  signed int i; // esi@12
  int *stackPointer; // esi@15
  WCHAR *iterator; // edi@18
  const char *spaceOrEoL; // eax@22
  int counter_inc; // ecx@22
  bool v26; // zf@22
  signed int v27; // ecx@22
  int threadIndex; // esi@29
  HANDLE threadId_1; // eax@31
  HANDLE listenThreadId; // eax@34
  HANDLE mainThreadId; // eax@36
  int threadIndex2; // esi@37
  signed int counter; // [sp+20h] [bp-A40h]@17
  int *stackBase; // [sp+24h] [bp-A3Ch]@15
  unsigned __int8 *eip2; // [sp+30h] [bp-A30h]@12
  WCHAR violationBuffer[1000]; // [sp+34h] [bp-A2Ch]@11
  WCHAR moduleFilename[260]; // [sp+804h] [bp-25Ch]@4
  MEMORY_BASIC_INFORMATION memoryInfo; // [sp+A0Ch] [bp-54h]@3
  const wchar_t *moduleName2; // [sp+A28h] [bp-38h]@3
  PCONTEXT context2; // [sp+A2Ch] [bp-34h]@3
  PEXCEPTION_RECORD exceptionRecord1; // [sp+A30h] [bp-30h]@3
  struct _SYSTEMTIME systemTime; // [sp+A34h] [bp-2Ch]@3
  HANDLE hFile; // [sp+A44h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+A48h] [bp-18h]@14

  exceptionInfo = ex;
  hFile0 = CreateFileW(CExceptionInit::s_logPath, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0x80000080, 0);
  hFile1 = hFile0;
  hFile = hFile0;
  if ( hFile0 == (HANDLE)INVALID_HANDLE_VALUE )
  {
    OutputDebugStringW(L"Error creating exception report");
  }
  else
  {
    SetEndOfFile(hFile0);
    size = CIOBufferPool::getFreeSlotsNumberFromAllPools();
    CoreDump::WriteToFile(hFile1, L"IOBufferPool - %d\r\n\r\n", size);
    systemTime.wYear = 0;
    *(_DWORD *)&systemTime.wMonth = 0;
    *(_DWORD *)&systemTime.wDay = 0;
    *(_DWORD *)&systemTime.wMinute = 0;
    systemTime.wMilliseconds = 0;
    GetLocalTime(&systemTime);
    second = systemTime.wSecond;
    minute = systemTime.wMinute;
    hour = systemTime.wHour;
    day = systemTime.wDay;
    month = systemTime.wMonth;
    year = systemTime.wYear;
    threadId = GetCurrentThreadId();
    CoreDump::WriteToFile(hFile1, L"[(%d) %04d/%02d/%02d %02d:%02d:%02d]: =======================\r\n", threadId, year, month, day, hour, minute, second);
    exceptionRecord = exceptionInfo->ExceptionRecord;
    exceptionRecord1 = exceptionInfo->ExceptionRecord;
    context = exceptionInfo->ContextRecord;
    context2 = context;
    moduleName2 = L"Unknown";
    if ( VirtualQuery((LPCVOID)context->Eip, &memoryInfo, sizeof(_MEMORY_BASIC_INFORMATION)) && GetModuleFileNameW((HMODULE)memoryInfo.AllocationBase, moduleFilename, 520u) )
    {
      moduleName = Utils::GetFileName(moduleFilename);
      exceptionRecord = exceptionRecord1;
    }
    else
    {
      moduleName = (wchar_t *)moduleName2;
    }
    eip_ = context->Eip;
    segCs = context->SegCs;
    moduleName1 = moduleName;
    exceptionStr = CoreDump::ExceptionToString(exceptionRecord->ExceptionCode);
    CoreDump::WriteToFile(hFile1, L"%S in module %s at %04x:%08x.\r\n", exceptionStr, moduleName1, segCs, eip_);
    startTime = localtime(&CExceptionInit::s_startTime);
    CoreDump::WriteToFile(hFile1, L"start at %d/%d/%d %02d:%02d:%02d\r\n", startTime->tm_year + 1900, startTime->tm_mon + 1, startTime->tm_mday, startTime->tm_hour, startTime->tm_min, startTime->tm_sec);
    if ( exceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION && exceptionRecord->NumberParameters >= 2 )
    {
      label = L"Read from";
      if ( exceptionRecord->ExceptionInformation[0] )
      {
        label = L"Write to";
      }
      wsprintfW(violationBuffer, L"%s location %08x caused an access violation.\r\n", label, exceptionRecord->ExceptionInformation[1]);
      CoreDump::WriteToFile(hFile1, L"%s", violationBuffer);
    }
    CoreDump::WriteToFile(hFile1, L"\r\n");
    CoreDump::WriteToFile(hFile1, L"Registers:\r\n");
    CoreDump::WriteToFile(hFile1, L"EAX=%08x CS=%04x EIP=%08x EFLGS=%08x\r\n", context->Eax, context->SegCs, context->Eip, context->EFlags);
    CoreDump::WriteToFile(hFile1, L"EBX=%08x SS=%04x ESP=%08x EBP=%08x\r\n", context->Ebx, context->SegSs, context->Esp, context->Ebp);
    CoreDump::WriteToFile(hFile1, L"ECX=%08x DS=%04x ESI=%08x FS=%04x\r\n", context->Ecx, context->SegDs, context->Esi, context->SegFs);
    CoreDump::WriteToFile(hFile1, L"EDX=%08x ES=%04x EDI=%08x GS=%04x\r\n", context->Edx, context->SegEs, context->Edi, context->SegGs);
    CoreDump::WriteToFile(hFile1, L"Bytes at CS:EIP:\r\n");
    eip2 = (unsigned __int8 *)context->Eip;
    for ( i = 0; i < 16; ++i )
    {
      ms_exc.registration.TryLevel = 0;
      CoreDump::WriteToFile(hFile1, L"%02x ", eip2[i]);
      ms_exc.registration.TryLevel = -1;
    }
    CoreDump::WriteToFile(hFile1, L"\r\nStack dump:\r\n");
    ms_exc.registration.TryLevel = 1;
    stackPointer = (int *)context->Esp;
    stackBase = (int *)__readfsdword(4);
    if ( stackBase > stackPointer + 80 )
    {
      stackBase = stackPointer + 80;
    }
    counter = 0;
LABEL_18:
    iterator = CoreDump::s_stackBuffer;
    while ( stackPointer + 1 <= stackBase )
    {
      if ( !(counter % 8) )
      {
        iterator += wsprintfW(iterator, L"%08x: ", stackPointer);
      }
      spaceOrEoL = " ";
      counter_inc = counter + 1;
      counter = counter_inc;
      v27 = counter_inc & 0x80000007;
      v26 = v27 == 0;
      if ( v27 < 0 )
      {
        v26 = (((_BYTE)v27 - 1) | 0xFFFFFFF8) == -1;
      }
      if ( v26 || stackPointer + 2 > stackBase )
      {
        spaceOrEoL = "\r\n";
      }
      iterator += wsprintfW(iterator, L"%08x%S", *stackPointer, spaceOrEoL);
      ++stackPointer;
      if ( iterator > (WCHAR *)&CoreDump::s_stackBuffer_limit )
      {
        CoreDump::WriteToFile(hFile1, L"%s", CoreDump::s_stackBuffer);
        CoreDump::s_stackBuffer[0] = 0;
        goto LABEL_18;
      }
    }
    CoreDump::WriteToFile(hFile1, L"%s", CoreDump::s_stackBuffer);
    ms_exc.registration.TryLevel = -1;
    CIOCriticalSection::Enter(&CoreDump::s_lock, L"Exception.cpp", 964);
    for ( threadIndex = 0; threadIndex < CThreadManager::GetIOThreadNumber(); ++threadIndex )
    {
      if ( threadIndex != tls::GetCurrentThreadIndex() )
      {
        threadId_1 = CThreadManager::GetThread((ThreadIndices)threadIndex);
        SuspendThread(threadId_1);
      }
    }
    CIOCriticalSection::Leave(&CoreDump::s_lock, L"Exception.cpp", 970);
    if ( !CThreadManager::isListenThread() )
    {
      listenThreadId = CThreadManager::GetThread(ThreadIndex_ListenThread);
      SuspendThread(listenThreadId);
    }
    if ( !CThreadManager::isMainThread() )
    {
      mainThreadId = CThreadManager::GetThread(ThreadIndex_Main);
      SuspendThread(mainThreadId);
    }
    CoreDump::WriteToFile(hFile1, L"\r\n\r\nGuardInfo : \r\n\r\n");
    for ( threadIndex2 = 0; threadIndex2 < CThreadManager::GetIOThreadNumber(); ++threadIndex2 )
    {
      CoreDump::WriteCallStack((ThreadIndices)threadIndex2, hFile1, L"IOThread");
    }
    CoreDump::WriteCallStack(ThreadIndex_ListenThread, hFile1, L"ListenThread");
    CoreDump::WriteCallStack(ThreadIndex_Main, hFile1, L"MainThread");
    CoreDump::WriteToFile(hFile1, L"GuardInfo end \r\n\r\n");
    CoreDump::WriteToFile(hFile1, L"\r\n\r\n");
    CloseHandle(hFile1);
  }
}
// 421C1C: using guessed type wchar_t aUnknown[8];
// 422008: using guessed type wchar_t aWriteTo[9];
// 42201C: using guessed type wchar_t aReadFrom[10];

//----- (004034C0) --------------------------------------------------------
int CallStack::ReportCallStack()
{
  int threadIndex; // ebx@1
  int stackSize; // eax@1
  int stackIndex; // esi@1
  wchar_t **funcNames; // edi@2

  threadIndex = *(_DWORD *)(*(_DWORD *)(__readfsdword(0x2C) + 4 * TlsIndex) + 8);
  CLog::Add(&g_winlog, LOG_ERROR, L"--- call stack ---");
  stackSize = CallStack::s_threadStackSizes[threadIndex];
  stackIndex = 0;
  if ( stackSize <= 0 )
  {
    return stackSize;
  }
  funcNames = CallStack::s_functions[threadIndex];
  do
  {
    CLog::Add(&g_winlog, LOG_ERROR, L"[%d] %s", stackIndex, *funcNames);
    stackSize = CallStack::s_threadStackSizes[threadIndex];
    ++stackIndex;
    ++funcNames;
  }
  while ( stackIndex < stackSize );
  return stackSize;
}
// 1BD5478: using guessed type int TlsIndex;

//----- (00403540) --------------------------------------------------------
LONG __stdcall CExceptionInit::RecordExceptionInfo(struct _EXCEPTION_POINTERS *exceptionInfo)
{
  if ( CExceptionInit::bBeenHere )
  {
    if ( CExceptionInit::s_oldFilter )
    {
      return CExceptionInit::s_oldFilter(exceptionInfo);
    }
  }
  else
  {
    CExceptionInit::bBeenHere = true;
    if ( !CExceptionInit::s_errorReported && exceptionInfo->ExceptionRecord->ExceptionCode != ERR_NO_DISK_SPACE )
    {
      EnterCriticalSection(&CExceptionInit::s_lock);
      CoreDump::CreateReport(exceptionInfo);
      if ( Config::s_mailServer )
      {
        CExceptionInit::SendMail("narcasse@ncsoft.net", Config::s_mailServer, "l2logd@ncsoft.co.kr", CExceptionInit::s_logPath);
      }
      LeaveCriticalSection(&CExceptionInit::s_lock);
    }
    if ( CExceptionInit::s_oldFilter )
    {
      return CExceptionInit::s_oldFilter(exceptionInfo);
    }
  }
  return 0;
}
// 455C08: using guessed type int CExceptionInit::bBeenHere;

//----- (00403630) --------------------------------------------------------
void __cdecl CExceptionInit::InstallTopLevelFilter()
{
  CExceptionInit::s_oldFilter = SetUnhandledExceptionFilter(CExceptionInit::RecordExceptionInfo);
}

//----- (00403650) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER CExceptionInit::RestoreTopLevelFilter()
{
  LPTOP_LEVEL_EXCEPTION_FILTER result; // eax@1

  result = CExceptionInit::s_oldFilter;
  if ( CExceptionInit::s_oldFilter )
  {
    result = SetUnhandledExceptionFilter(CExceptionInit::s_oldFilter);
  }
  return result;
}

//----- (00403670) --------------------------------------------------------
void *__thiscall CExceptionInit::CExceptionInit(void *this)
{
  void *v1; // ebx@1
  wchar_t *exeName; // esi@3
  wchar_t *extension; // eax@3
  wchar_t buffer[256]; // [sp+10h] [bp-208h]@1

  v1 = this;
  InitializeCriticalSection(&CExceptionInit::s_lock);
  *(_DWORD *)buffer = *(_DWORD *)L"Unknown";
  *(_DWORD *)&buffer[6] = *(_DWORD *)L"\u6b00\u6e00\u6f00\u7700\u6e00";
  *(_DWORD *)&buffer[2] = *(_DWORD *)L"\u6e00\u6b00\u6e00\u6f00\u7700\u6e00";
  *(_DWORD *)&buffer[4] = *(_DWORD *)L"nknown";
  memset(&buffer[8], 0, 504u);
  if ( !GetModuleFileNameW(0, CExceptionInit::s_logPath, 520u) )
  {
    CExceptionInit::s_logPath[0] = '\0';
  }
  exeName = Utils::GetFileName(CExceptionInit::s_logPath);
  lstrcpyW(buffer, exeName);
  extension = wcsrchr(buffer, '.');
  if ( extension )
  {
    *extension = 0;
  }
  lstrcpyW(exeName, L"LinError.txt");
  CExceptionInit::s_startTime = time(0);
  CExceptionInit::InstallTopLevelFilter();
  return v1;
}
// 421C1C: using guessed type wchar_t aUnknown[8];

//----- (00403760) --------------------------------------------------------
void CExceptionInit::LogException(const wchar_t *format, ...)
{
  HANDLE hFile; // eax@2
  void *hFile2; // ebp@2
  int second; // ST24_4@3
  int minute; // ST20_4@3
  int hour; // ST1C_4@3
  int day; // ST18_4@3
  int month; // ST14_4@3
  int year; // ST10_4@3
  DWORD threadId; // eax@3
  CHAR *buffer; // eax@4
  int len2; // eax@4
  unsigned int len; // ebx@4
  int i; // esi@5
  wchar_t *newLine; // eax@6
  wchar_t *newLine2; // edi@6
  signed int distanse; // esi@9
  CHAR *narrowBuff; // eax@10
  struct _SYSTEMTIME now; // [sp+0h] [bp-4014h]@2
  DWORD bytesWritten; // [sp+10h] [bp-4004h]@4
  wchar_t bufferW[8192]; // [sp+14h] [bp-4000h]@3
  va_list va; // [sp+401Ch] [bp+8h]@1

  va_start(va, format);
  if ( !CExceptionInit::s_errorReported )
  {
    EnterCriticalSection(&CExceptionInit::s_lock);
    *(_DWORD *)&now.wMonth = 0;
    *(_DWORD *)&now.wDay = 0;
    *(_DWORD *)&now.wMinute = 0;
    now.wYear = 0;
    now.wMilliseconds = 0;
    GetLocalTime(&now);
    hFile = CreateFileW(CExceptionInit::s_logPath, GENERIC_WRITE|GENERIC_READ, 0, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
    hFile2 = hFile;
    if ( hFile != (HANDLE)INVALID_HANDLE_VALUE )
    {
      SetFilePointer(hFile, 0, 0, FILE_END);
      second = now.wSecond;
      minute = now.wMinute;
      hour = now.wHour;
      day = now.wDay;
      month = now.wMonth;
      year = now.wYear;
      threadId = GetCurrentThreadId();
      if ( _snwprintf(bufferW, 0x4000u, L"[(%d) %04d/%02d/%02d %02d:%02d:%02d]: ", threadId, year, month, day, hour, minute, second) >= 0 )
      {
        buffer = Utils::UnicodeToMultibyte_WithoutAllocation(bufferW);
        WriteFile(hFile2, buffer, strlen(buffer), &bytesWritten, 0);
        len2 = _vsnwprintf(bufferW, 0x4000u, format, va);
        len = len2;
        if ( len2 >= 0 )
        {
          i = 0;
          if ( len2 > 0 )
          {
            do
            {
              newLine = (wchar_t *)memchr(&bufferW[i], '\n', len - i);
              newLine2 = newLine;
              if ( !newLine )
              {
                break;
              }
              if ( len < 0x4000 )
              {
                ++len;
              }
              distanse = newLine - bufferW;
              memcpy(newLine + 1, newLine, len - distanse - 1);
              i = distanse + 2;
              *newLine2 = '\r';
            }
            while ( i < (signed int)len );
          }
          narrowBuff = Utils::UnicodeToMultibyte_WithoutAllocation(bufferW);
          WriteFile(hFile2, narrowBuff, strlen(narrowBuff), &bytesWritten, 0);
        }
      }
      CloseHandle(hFile2);
    }
    LeaveCriticalSection(&CExceptionInit::s_lock);
  }
}

//----- (00403920) --------------------------------------------------------
MACRO_EXCEPTION __cdecl CExceptionInit::ExceptionFilter(EXCEPTION_POINTERS *ex)
{
  EnterCriticalSection(&CExceptionInit::s_lock);
  CoreDump::CreateReport(ex);
  LeaveCriticalSection(&CExceptionInit::s_lock);
  return EXCEPTION_EXECUTE_HANDLER;
}

//----- (00403970) --------------------------------------------------------
char __cdecl CExceptionInit::SendExceptionLog(bool fatal)
{
  char result; // al@1

  result = CExceptionInit::s_errorReported;
  if ( CExceptionInit::s_errorReported )
  {
    return result;
  }
  EnterCriticalSection(&CExceptionInit::s_lock);
  if ( Config::s_mailServer )
  {
    CExceptionInit::SendMail("narcasse@ncsoft.net", Config::s_mailServer, "l2logd@ncsoft.co.kr", CExceptionInit::s_logPath);
  }
  LeaveCriticalSection(&CExceptionInit::s_lock);
  result = fatal;
  if ( !fatal )
  {
    return result;
  }
  CExceptionInit::s_errorReported = true;
  ExitProcess(0);
  return result;
}

//----- (004039D0) --------------------------------------------------------
int EASSERT()
{
  int result; // eax@2

  if ( !ExceptionHandler::s_good )
  {
    return result;
  }
  ExceptionHandler::s_good = false;
  CExceptionInit::LogException(L"Intentional Exception\n");
  result = 0;
  LOBYTE(v0) = false;
  return result;
}
// 42D727: using guessed type char ExceptionHandler::s_good;

//----- (00403A70) --------------------------------------------------------
void *__thiscall guard(void *this, wchar_t *funcName)
{
  void *result; // eax@1
  int threadIndex; // edx@1
  int stackSize; // esi@1

  result = this;
  threadIndex = *(_DWORD *)(*(_DWORD *)(__readfsdword(0x2C) + 4 * TlsIndex) + 8);// 
                                                // http://www.mpgh.net/forum/showthread.php?t=863507
  stackSize = CallStack::s_threadStackSizes[threadIndex];
  CallStack::s_threadStackSizes[threadIndex] = stackSize + 1;
  CallStack::s_functions[0][stackSize + 1000 * threadIndex] = funcName;
  return result;
}
// 1BD5478: using guessed type int TlsIndex;

//----- (00403AC0) --------------------------------------------------------
int unguard()
{
  int threadIndex; // eax@1

  threadIndex = *(_DWORD *)(*(_DWORD *)(__readfsdword(0x2C) + 4 * TlsIndex) + 8);
  --CallStack::s_threadStackSizes[threadIndex];
  return threadIndex;
}
// 1BD5478: using guessed type int TlsIndex;

//----- (00403AE0) --------------------------------------------------------
int __cdecl MainWindow::MessageLoop_common(HACCEL hAccTable)
{
  int result; // eax@1
  tagMSG msg; // [sp+0h] [bp-1Ch]@1

  for ( result = GetMessageW(&msg, 0, 0, 0); result; result = GetMessageW(&msg, 0, 0, 0) )
  {
    if ( !TranslateAcceleratorW(msg.hwnd, hAccTable, &msg) )
    {
      TranslateMessage(&msg);
      DispatchMessageW(&msg);
    }
  }
  return result;
}

//----- (00403B50) --------------------------------------------------------
int __cdecl MainWindow::MessageLoop_mailing(HACCEL hAccTable)
{
  return MainWindow::MessageLoop_common(hAccTable);
}

//----- (00403BE0) --------------------------------------------------------
MACRO_FALSE __stdcall MainWindow::AboutDlgProc(HWND hDlg, UINT msgType, WPARAM wparam, LPARAM a4)
{
  if ( msgType == WM_INITDIALOG )
  {
    return TRUE;
  }
  if ( msgType != WM_COMMAND || (_WORD)wparam != IDOK && (_WORD)wparam != IDCANCEL )
  {
    return FALSE;
  }
  EndDialog(hDlg, (unsigned __int16)wparam);
  return TRUE;
}

//----- (00403C20) --------------------------------------------------------
unsigned int __stdcall Threads::ServerListeningThread(void *param)
{
  int result_1; // eax@1
  struct WSAData wsaData; // [sp+10h] [bp-1A8h]@1
  CPPEH_RECORD ms_exc; // [sp+1A0h] [bp-18h]@1

  CThreadManager::RegisterThisThread(ThreadIndex_ListenThread);
  Config::ExceptionMailing();                   //     if (ExceptionMailing())
                                                //     {
                                                //         _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );
                                                //         _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_DEBUG );
                                                //     }   
                                                // 
  ms_exc.registration.TryLevel = 0;
  result_1 = WSAStartup(WINSOCK_VERSION, &wsaData);// THIS IS INLINED _common
  if ( !result_1 )
  {
    Threading::s_ioThreadNumber = CThreadManager::GetMaxIOThreadNumber();
    Threads::CreateIOThread(Threading::s_ioThreadNumber);
    CServer::Run(&g_logServer, 3999, CServerSocket::Allocate, 0, 0, 0);// TODO: fix me! Take port from Config
    Threads::WaitThread();
  }
  CLog::Add_Ansi(&g_winlog, LOG_ERROR, "WSAStartup error 0x%x", result_1);
  ms_exc.registration.TryLevel = -1;
  return 0;
}

//----- (00403D30) --------------------------------------------------------
void __noreturn PerfMonitor::Job()
{
  while ( 1 )
  {
    PerfMonitor::CheckPerformance(&g_perfMonitor);
    Sleep(g_perfMonitor.m_interval);
  }
}

//----- (00403D60) --------------------------------------------------------
void __noreturn CSQLQueue::Job()
{
  while ( 1 )
  {
    CSQLQueue::ExecSQL(&g_sqlPollingQueue);
    Sleep(Config::s_pollingInterval);
  }
}

//----- (00403D90) --------------------------------------------------------
void __cdecl __noreturn CBCPLogFile::Job(int bcpSlot)
{
  CBCPLogFile *bcpFile; // esi@1
  DWORD interval; // ST14_4@2
  DWORD threadId; // eax@2
  wchar_t currDirectory[512]; // [sp+10h] [bp-C00h]@1
  wchar_t chatDirPath[512]; // [sp+410h] [bp-800h]@1
  wchar_t inDirPath[512]; // [sp+810h] [bp-400h]@1

  bcpFile = &g_bcpFiles[bcpSlot];
  CBCPLogFile::Init(&g_bcpFiles[bcpSlot], bcpSlot);
  currDirectory[0] = 0;
  memset(&currDirectory[1], 0, 1020u);
  currDirectory[511] = 0;
  chatDirPath[0] = 0;
  memset(&chatDirPath[1], 0, 1020u);
  chatDirPath[511] = 0;
  inDirPath[0] = 0;
  memset(&inDirPath[1], 0, 1020u);
  inDirPath[511] = 0;
  GetCurrentDirectoryW(1024u, currDirectory);
  wsprintfW(chatDirPath, L"%s\\log\\chat\\", currDirectory);
  wsprintfW(inDirPath, L"%s\\log\\in\\", currDirectory);
  while ( 1 )
  {
    CBCPLogFile::InsertLogFiles(bcpFile, chatDirPath);
    CBCPLogFile::InsertLogFiles(bcpFile, inDirPath);
    interval = Config::s_BCPLogFileInterval;
    threadId = GetCurrentThreadId();
    CLog::Add(&g_winlog, 0, L"[%d]Sleep %d milliseconds", threadId, interval);
    Sleep(Config::s_BCPLogFileInterval);
  }
}

//----- (00403EA0) --------------------------------------------------------
LRESULT __stdcall MainWindow::WndProc(HWND hWnd, UINT mstType, WPARAM wParam, LPARAM lParam)
{
  LRESULT result; // eax@4
  int i; // esi@21
  int i2; // esi@26
  WCHAR buffer[100]; // [sp+8h] [bp-C8h]@1

  LoadStringW(g_instance, STR_HELLO_WORLD, buffer, 100);
  if ( mstType == WM_DESTROY )
  {
    PostQuitMessage(0);
    return 0;
  }
  if ( mstType == WM_PAINT )
  {
    CLog::Redraw(&g_winlog);
    return 0;
  }
  if ( mstType != WM_COMMAND )
  {
    return DefWindowProcW(hWnd, mstType, wParam, lParam);
  }
  if ( (unsigned __int16)wParam <= (signed int)MENU_ITEM_RELOAD_CONF )
  {
    if ( (unsigned __int16)wParam == MENU_ITEM_RELOAD_CONF )
    {
      SuspendThread(PerfMonitor_s_thread);
      PerfMonitor::Reload(&g_perfMonitor);
      ResumeThread(PerfMonitor_s_thread);
      result = 0;
    }
    else
    {
      switch ( (unsigned __int16)wParam )
      {
        case MENU_ITEM_START_MONITOR:
          ResumeThread(PerfMonitor_s_thread);
          result = 0;
          break;
        case MENU_ITEM_INSERT_ITEM_NAME:
          CReadFile::ParseItemName();
          result = 0;
          break;
        case MENU_ITEM_INSERT_NPC_NAME:
          CReadFile::ParseNPCName();
          result = 0;
          break;
        case MENU_ITEM_INSERT_QUEST_NAME:
          CReadFile::ParseQuestName();
          result = 0;
          break;
        case MENU_ITEM_INSERT_SKILL_NAME:
          CReadFile::ParseSkillName();
          result = 0;
          break;
        case MENU_ITEM_ABOUT:
          DialogBoxParamW(g_instance, (LPCWSTR)DIALOG_ABOUT, hWnd, (DLGPROC)MainWindow::AboutDlgProc, 0);
          result = 0;
          break;
        case MENU_ITEM_EXIT:
          DestroyWindow(hWnd);
          result = 0;
          break;
        default:
          return DefWindowProcW(hWnd, WM_COMMAND, wParam, lParam);
      }
    }
    return result;
  }
  if ( (unsigned __int16)wParam > (signed int)MENU_ITEM_STOP_INSERT_DATA )
  {
    if ( (unsigned __int16)wParam == MENU_ITEM_CONFIGURE )
    {
      DialogBoxParamW(g_instance, (LPCWSTR)DIALOG_CONFIGURATION, hWnd, (DLGPROC)MainWindow::ConfigDlgProc, 0);
      return 0;
    }
    if ( (unsigned __int16)wParam == MENU_ITEM_START_SERVER_MONITOR || (unsigned __int16)wParam == 32783 )
    {
      return 0;
    }
    return DefWindowProcW(hWnd, WM_COMMAND, wParam, lParam);
  }
  if ( (unsigned __int16)wParam != MENU_ITEM_STOP_INSERT_DATA )
  {
    if ( (unsigned __int16)wParam == MENU_ITEM_STOP_MONITOR )
    {
      SuspendThread(PerfMonitor_s_thread);
      return 0;
    }
    if ( (unsigned __int16)wParam == MENU_ITEM_SPACEUSED )
    {
      CSQLQueue::SpaceUsed(&g_sqlPollingQueue, true);
      return 0;
    }
    if ( (unsigned __int16)wParam != MENU_ITEM_START_INSERT_DATA )
    {
      return DefWindowProcW(hWnd, WM_COMMAND, wParam, lParam);
    }
    i = 0;
    if ( Config::s_BCPThreadCount <= 0 )
    {
      return 0;
    }
    do
    {
      ResumeThread(BCPThread_s_threads[i++]);
    }
    while ( i < Config::s_BCPThreadCount );
    return 0;
  }
  i2 = 0;
  if ( Config::s_BCPThreadCount <= 0 )
  {
    return 0;
  }
  do
  {
    SuspendThread(BCPThread_s_threads[i2++]);
  }
  while ( i2 < Config::s_BCPThreadCount );
  return 0;
}
// 19D7E18: using guessed type int Config::s_BCPThreadCount;

//----- (004041D0) --------------------------------------------------------
void __noreturn Threads::PerfMonitorThread_mailing()
{
  PerfMonitor::Job();
}

//----- (00404270) --------------------------------------------------------
void __stdcall __noreturn Threads::PerfMonitorThread(void *a1)
{
  CThreadManager::RegisterThisThread(ThreadIndex_PerfMonitor);
  if ( Config::ExceptionMailing() )
  {
    Threads::PerfMonitorThread_mailing();
  }
  Threads::PerfMonitorThread_common();
}
// 404260: using guessed type int Threads::PerfMonitorThread_common(void);

//----- (004042A0) --------------------------------------------------------
void __noreturn Threads::SqlQueueThread_mailing()
{
  CSQLQueue::Job();
}

//----- (00404340) --------------------------------------------------------
void __stdcall __noreturn Threads::SqlQueueThread(void *param)
{
  CThreadManager::RegisterThisThread(ThreadIndex_Log);
  if ( Config::ExceptionMailing() )
  {
    Threads::SqlQueueThread_mailing();
  }
  Threads::SqlQueueThread_common();
}

//----- (00404370) --------------------------------------------------------
void __cdecl __noreturn Threads::BCPThread_mailing(int bcpSlot)
{
  CBCPLogFile::Job(bcpSlot);                    //  THIS IS INLINED COMMON
}

//----- (00404420) --------------------------------------------------------
unsigned int __stdcall __noreturn Threads::BCPThread(void *bcpSlot)
{
  CThreadManager::RegisterThisThread((ThreadIndices)(8 - (_DWORD)bcpSlot));
  if ( Config::ExceptionMailing() )
  {
    Threads::BCPThread_mailing((int)bcpSlot);
  }
  Threads::BCPThread_common((int)bcpSlot);
}

//----- (00404460) --------------------------------------------------------
ATOM __cdecl MainWindow::RegisterLogDClass(HINSTANCE hInstance)
{
  WNDCLASSEXW wcex; // [sp+4h] [bp-30h]@1

  wcex.cbSize = sizeof(WNDCLASSEX);
  wcex.style = 3;                               // CS_HREDRAW | CS_VREDRAW
  wcex.lpfnWndProc = MainWindow::WndProc;
  wcex.cbClsExtra = 0;
  wcex.cbWndExtra = 0;
  wcex.hInstance = hInstance;
  wcex.hIcon = LoadIconW(hInstance, (LPCWSTR)ICON_LOGD);
  wcex.hCursor = LoadCursorW(0, (LPCWSTR)IDC_ARROW);
  wcex.hbrBackground = (HBRUSH)6;
  wcex.lpszMenuName = (LPCWSTR)STR_L2LOGD;
  wcex.lpszClassName = MainWindow::s_windowClass;
  wcex.hIconSm = LoadIconW(hInstance, (LPCWSTR)ICON_LOGD_SMALL);
  return RegisterClassExW(&wcex);
}

//----- (004044F0) --------------------------------------------------------
bool __cdecl MainWindow::InitInstance(HINSTANCE hInstance, int nCmdShow)
{
  HWND logWnd; // esi@1
  bool result; // al@2
  int bcpSlot; // esi@4
  int count; // eax@5
  int i; // esi@7
  struct _SYSTEMTIME systemTime; // [sp+Ch] [bp-634h]@3
  DWORD threadId; // [sp+1Ch] [bp-624h]@3
  wchar_t timeStr[256]; // [sp+20h] [bp-620h]@3
  DBConn dbConn; // [sp+220h] [bp-420h]@3
  int unused; // [sp+63Ch] [bp-4h]@3

  g_instance = hInstance;
  logWnd = CreateWindowExW(0, MainWindow::s_windowClass, MainWindow::s_title, (DWORD)&dword_CF0000, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, 0, 0, hInstance, 0);// unk == WS_OVERLAPPEDWINDOW
  if ( logWnd )
  {
    Config::Init();
    CLog::Set(&g_winlog, logWnd);
    CLog::Enable(&g_winlog, true);
    ShowWindow(logWnd, nCmdShow);
    UpdateWindow(logWnd);
    DBConn::Init();
    g_logServer.m_d.m_threadId = _beginthreadex(0, 0, (int)Threads::ServerListeningThread, 0, 0, &threadId);
    CThreadManager::SetThread(ThreadIndex_ListenThread, g_logServer.m_d.m_threadId);
    GetLocalTime(&systemTime);
    timeStr[0] = 0;
    memset(&timeStr[1], 0, 0x1FCu);
    timeStr[255] = 0;
    wsprintfW(timeStr, L"L%04d_%02d_%02d_", systemTime.wYear, systemTime.wMonth, systemTime.wDay);
    DBConn::DBConn(&dbConn);
    unused = 0;
    DBConn::Execute(&dbConn, aExecuteLin_checklogtim2[0], timeStr, Config::s_worldId);
    if ( Config::s_BCPThreadCount < 10 )
    {
      bcpSlot = 0;
      if ( Config::s_BCPThreadCount > 0 )
      {
        do
        {
          BCPThread_s_threads[bcpSlot] = _beginthreadex(0, 0, (int)Threads::BCPThread, bcpSlot, CREATE_SUSPENDED, (LPDWORD)(4 * bcpSlot + 0x455C48));// Threading__s_threadIds
          count = Config::s_BCPThreadCount;
          CBCPLogFile::s_worldIds[bcpSlot++] = 0;
        }
        while ( bcpSlot < count );
      }
    }
    if ( Config::s_autoBCP == 1 )
    {
      CLog::Add(&g_winlog, 0, L"Auto BCP mode is on");
      for ( i = 0; i < Config::s_BCPThreadCount; ++i )
      {
        ResumeThread(BCPThread_s_threads[i]);
      }
    }
    if ( PerfMonitor::Init(&g_perfMonitor) )
    {
      PerfMonitor_s_thread = _beginthreadex(0, 0, (int)Threads::PerfMonitorThread, 0, 0, &g_ThreadId_unused);
    }
    SqlPooling::s_unusedThreadId1 = (int)_beginthreadex(0, 0, (int)Threads::SqlQueueThread, 0, 0, &SqlPooling::s_unusedThreadId2);
    unused = -1;
    DBConn::DestructorDBConn(&dbConn);
    result = 1;
  }
  else
  {
    result = false;
  }
  return result;
}
// 455C14: using guessed type int SqlPooling::s_unusedThreadId1;
// CF0000: using guessed type int dword_CF0000;
// 19D7E18: using guessed type int Config::s_BCPThreadCount;

//----- (00404730) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE instance, HINSTANCE hPrevInstance, char *lpCmdLine, int nShowCmd)
{
  int res; // eax@2
  int maxIOThreadNumber; // eax@3
  HACCEL accelerators; // [sp-Ch] [bp-Ch]@4

  CreateMutexW(NULL, TRUE, L"_L2LOGD_EXE_");
  if ( GetLastError() == ERROR_ALREADY_EXISTS )
  {
    MessageBoxW(0, L"L2LogD.EXE is already running.", L"Error", WM_NULL);
    res = -1;
  }
  else
  {
    CThreadManager::SetThisThreadAsMainThread();
    maxIOThreadNumber = CThreadManager::GetMaxIOThreadNumber();
    CThreadManager::SetIOThreadNumber(maxIOThreadNumber);
    Config::s_mailServer = "mail.ncsoft.co.kr";
    Config::ExceptionMailing();
    LoadStringW(instance, STR_CAPTION, MainWindow::s_title, 100);// #define MAX_LOADSTRING 100
    LoadStringW(instance, STR_L2LOGD, MainWindow::s_windowClass, 100);
    MainWindow::RegisterLogDClass(instance);
    LOBYTE(res) = MainWindow::InitInstance(instance, nShowCmd);
    if ( res )
    {
      accelerators = LoadAcceleratorsW(instance, (LPCWSTR)ACCELERATOR_L2LOGD);
      if ( Config::ExceptionMailing() )
      {
        MainWindow::MessageLoop_mailing(accelerators);
        res = -1;
      }
      else
      {
        MainWindow::MessageLoop_common(accelerators);
        res = -1;
      }
    }
  }
  return res;
}

//----- (00404800) --------------------------------------------------------
MemSmth *__thiscall MemSmth::MemSmth(MemSmth *this)
{
  MemSmth *this_; // esi@1

  this_ = this;
  MemSmth::sub_404CF0(this);
  SmallBufferBlock::SmallBufferBlock(&this_->m_someOtherObject);
  return this_;
}

//----- (00404850) --------------------------------------------------------
void __thiscall MemSmth::Destructor(MemSmth *this)
{
  MemSmth *v1; // esi@1

  v1 = this;
  SmallBufferBlock::Destructor(&this->m_someOtherObject);
  MemSmth::Internal::Destructor(v1);
}

//----- (00404940) --------------------------------------------------------
LONG __thiscall MMU::deallocate(void *this, void *memory)
{
  char *memBlock; // eax@1
  unsigned int fullSize; // edi@1
  MemoryPool *memPool; // ebx@1
  int v5; // esi@2
  CIOCriticalSection *lock; // ebp@2
  int v7; // esi@2
  int v8; // edx@2
  int v9; // edi@2
  LONG result; // eax@2
  char *memorya; // [sp+4h] [bp+4h]@1

  memBlock = (char *)memory - 4;
  fullSize = *((_DWORD *)memory - 1);
  memPool = MMU::s_memPool;
  memorya = (char *)memory - 4;
  if ( fullSize >= 0x8001 )
  {
    free(memBlock);
    result = InterlockedDecrement(&memPool->m_allocatedBlocks);
  }
  else
  {
    v5 = MMU::s_memPool->m_smallBlocksArray[fullSize];
    lock = &MMU::s_memPool->m_locks[MMU::s_memPool->m_smallBlocksArray[fullSize]];
    CIOCriticalSection::Enter(lock, 0, 0);
    v7 = (int)memPool + 72 * v5;
    sub_405020(v7 + 40, (int)memorya);
    v8 = *(_DWORD *)(v7 + 72);
    v9 = fullSize - *(_DWORD *)(v7 + 60);
    --*(_DWORD *)(v7 + 64);
    *(_DWORD *)(v7 + 72) = v9 + v8;
    CIOCriticalSection::Leave(lock, 0, 0);
    result = InterlockedDecrement(&memPool->m_allocatedBlocks);
  }
  return result;
}

//----- (00404950) --------------------------------------------------------
MemoryPool *__thiscall MemoryPool::MemoryPool(MemoryPool *this)
{
  MemoryPool *this_; // ebx@1
  MemSmth *memSmth; // esi@1
  unsigned int v3; // edi@1
  unsigned int v4; // eax@3
  int *v5; // esi@3
  int v6; // edx@4
  char *v7; // ecx@5

  this_ = this;
  memSmth = this->m_somethings;
  this->vtable = MemoryPool_vtable_off_422584;
  Static_Init_For_Arrays(this->m_somethings, sizeof(MemSmth), 49, (int)MemSmth::MemSmth, (void (__thiscall *)(void *))MemSmth::Destructor);
  Static_Init_For_Arrays(this_->m_locks, sizeof(CIOCriticalSection), 49, (int)CIOCriticalSection::CIOCriticalSection, (void (__thiscall *)(void *))CIOCriticalSection::Destructor);
  v3 = 0;
  do
  {
    memSmth->field_15 = ((v3 & 3) + 4) << ((v3 >> 2) + 1);
    MemSmth::sub_404D40(memSmth, 2000u);
    memSmth->field_16 = 0;
    memSmth->field_17 = 0;
    memSmth->field_18 = 0;
    ++v3;
    ++memSmth;
  }
  while ( v3 < 49 );
  v4 = 0;
  v5 = this_->m_smallBlocksArray;
  do
  {
    v6 = 0;
    if ( this_->m_somethings[0].field_15 < v4 )
    {
      v7 = (char *)&this_->m_somethings[0].field_15;
      do
      {
        v7 += sizeof(MemSmth);
        ++v6;
      }
      while ( *(_DWORD *)v7 < v4 );
    }
    *v5 = v6;
    ++v4;
    ++v5;
  }
  while ( v4 < 0x8001 );
  this_->m_allocatedBlocks = 0;
  this_->field_135984 = 0;
  this_->field_135988 = 0;
  this_->field_135992 = 0;
  this_->field_135996 = 0;
  this_->field_136000 = 0;
  InitializeCriticalSection(&MemoryPool::s_lock);
  return this_;
}
// 422584: using guessed type int (__thiscall *MemoryPool_vtable_off_422584[3])(void *, char);

//----- (00404A60) --------------------------------------------------------
_DWORD *__userpurge MemoryPool::Allocate@<eax>(MemoryPool *this@<ecx>, void *a2@<esi>, int size)
{
  int fullSize; // ebp@1
  MemoryPool *this_; // edi@1
  int v5; // esi@2
  int v6; // eax@2
  CIOCriticalSection *lock; // ebx@2
  int v8; // eax@2
  int v9; // esi@2
  void *memBlock; // ebx@3
  int v11; // ecx@3
  void **v12; // eax@4
  int v13; // ecx@7
  CIOCriticalSection *lpCriticalSectiona; // [sp+10h] [bp+4h]@2

  fullSize = size + 4;
  this_ = this;
  if ( (unsigned int)(size + 4) >= 0x8001 )
  {
    memBlock = malloc(size + 4);
  }
  else
  {
    v5 = this->m_smallBlocksArray[fullSize];
    v6 = this->m_smallBlocksArray[fullSize];
    lock = &this->m_locks[v6];
    lpCriticalSectiona = &this->m_locks[v6];
    CIOCriticalSection::Enter(lock, 0, 0);
    v8 = this_->m_somethings[v5].m_someOtherObject.m_used;
    v9 = (int)this_ + sizeof(MemSmth) * v5;
    if ( v8 )
    {
      v12 = *(void ***)(v9 + 48);
      if ( v12 )
      {
        memBlock = *v12;
      }
      else
      {
        memBlock = 0;
      }
      sub_405100((void *)(v9 + 40));
      ++*(_DWORD *)(v9 + 64);
      ++this_->field_135984;
      v13 = *(_DWORD *)(v9 + 60);
      ++*(_DWORD *)(v9 + 68);
      *(_DWORD *)(v9 + 72) += v13 - fullSize;
      CIOCriticalSection::Leave(lpCriticalSectiona, 0, 0);
    }
    else
    {
      CIOCriticalSection::Leave(lock, 0, 0);
      memBlock = malloc(*(_DWORD *)(v9 + 60));
      CIOCriticalSection::Enter(lpCriticalSectiona, 0, 0);
      sub_404EA0(v9 + 4, (int)memBlock);
      v11 = *(_DWORD *)(v9 + 72);
      ++*(_DWORD *)(v9 + 64);
      *(_DWORD *)(v9 + 72) = *(_DWORD *)(v9 + 60) - fullSize + v11;
      CIOCriticalSection::Leave(lpCriticalSectiona, 0, 0);
    }
  }
  InterlockedIncrement(&this_->m_allocatedBlocks);
  *(_DWORD *)memBlock = fullSize;
  return (char *)memBlock + 4;
}

//----- (00404B70) --------------------------------------------------------
int __thiscall MemoryPool::Destructor(MemoryPool *this)
{
  MemoryPool *this_; // ebx@1
  MemSmth *v2; // edi@1
  unsigned int v3; // esi@2
  void *v4; // eax@3
  signed int v6; // [sp+10h] [bp-14h]@1

  this_ = this;
  this->vtable = MemoryPool_vtable_off_422584;
  v2 = (MemSmth *)((char *)&this->m_somethings[0] + 12);
  v6 = 49;
  do
  {
    v3 = 0;
    if ( v2->field_1 )
    {
      do
      {
        v4 = (void *)sub_404F30((int)&v2[-1].field_16, v3);
        free(v4);
        ++v3;
      }
      while ( v3 < v2->field_1 );
    }
    ++v2;
    --v6;
  }
  while ( v6 );
  this_->m_allocatedBlocks = 0;
  this_->field_135984 = 0;
  DeleteCriticalSection(&MemoryPool::s_lock);
  `eh vector destructor iterator'(this_->m_locks, sizeof(CIOCriticalSection), 49, (void (__thiscall *)(void *))CIOCriticalSection::Destructor);
  return `eh vector destructor iterator'(this_->m_somethings, 72u, 49, (void (__thiscall *)(void *))MemSmth::Destructor);
}
// 422584: using guessed type int (__thiscall *MemoryPool_vtable_off_422584[3])(void *, char);

//----- (00404C50) --------------------------------------------------------
void *__thiscall Allocator::allocate(void *this, int size, int blockSize, const wchar_t *name)
{
  void *v4; // esi@0
  MemoryPool *memPool; // eax@1
  MemoryPool *memPoolPtr; // eax@2

  memPool = MMU::s_memPool;
  if ( MMU::s_memPool )                         // TODO: multi-thread unsafe
  {
    return MemoryPool::Allocate(memPool, v4, size);
  }
  memPoolPtr = (MemoryPool *)operator new(sizeof(MemoryPool));
  if ( memPoolPtr )
  {
    memPool = MemoryPool::MemoryPool(memPoolPtr);
  }
  else
  {
    memPool = 0;
  }
  MMU::s_memPool = memPool;
  return MemoryPool::Allocate(memPool, v4, size);
}

//----- (00404CD0) --------------------------------------------------------
MemoryPool *__thiscall MemoryPool::DeletingDestructor(MemoryPool *this, char a2)
{
  MemoryPool *v2; // esi@1

  v2 = this;
  MemoryPool::Destructor(this);
  if ( a2 & 1 )
  {
    j__free(v2);
  }
  return v2;
}

//----- (00404CF0) --------------------------------------------------------
MemSmth *__thiscall MemSmth::sub_404CF0(MemSmth *this)
{
  MemSmth *v1; // esi@1
  char *v2; // edi@1

  v1 = this;
  this->field_1 = (int)MemSmth::Internal::vtable_off_422588;
  v2 = (char *)&this->field_2;
  *(_DWORD *)v2 = calloc_crt(2000, 4);
  v1->field_7 = (int)v2;
  v1->field_3 = 0;
  v1->field_4 = 0;
  v1->field_8 = 0;
  v1->field_5 = 2000;
  v1->field_6 = 2000;
  v1->field_9 = 2000;
  return v1;
}
// 422588: using guessed type int (__thiscall *MemSmth::Internal::vtable_off_422588[2])(void *, char);

//----- (00404D40) --------------------------------------------------------
void __thiscall MemSmth::sub_404D40(MemSmth *this, unsigned int a2)
{
  MemSmth *this_; // esi@1
  unsigned int v3; // edi@1
  int v4; // ebx@2
  unsigned int v5; // ebp@2
  char *v6; // eax@2
  int v7; // ebx@3
  int v8; // esi@6
  bool v9; // cf@7
  MemSmth *v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@4
  unsigned int v12; // [sp+10h] [bp-8h]@2
  char *v13; // [sp+14h] [bp-4h]@4
  int v14; // [sp+1Ch] [bp+4h]@5

  this_ = this;
  v3 = this->field_6;
  v10 = this;
  if ( a2 > v3 )
  {
    v4 = this->field_3;
    v5 = v3 + 100 * ((a2 - v3 - 1) / 100 + 1);
    v12 = 100 * ((a2 - v3 - 1) / 100 + 1) / 100;
    v6 = (char *)calloc_crt(v3 + 100 * ((a2 - v3 - 1) / 100 + 1), 4);
    if ( v4 )
    {
      v13 = v6;
      qmemcpy(v6, (const void *)this_->field_2, 4 * this_->field_6);
      free((void *)this_->field_2);
      v11 = 0;
      if ( v12 )
      {
        v14 = 0;
        do
        {
          qmemcpy(&v13[4 * (v14 + v10->field_6)], *(const void **)v4, 400u);
          free(*(void **)v4);
          v8 = *(_DWORD *)(v4 + 4);
          free((void *)v4);
          v4 = v8;
          if ( !v8 )
          {
            break;
          }
          v9 = v11++ + 1 < v12;
          v14 += 100;
        }
        while ( v9 );
      }
      v10->field_2 = (int)v13;
      v10->field_3 = v4;
      v10->field_6 = v5;
      if ( !v4 )
      {
        v10->field_7 = (int)&v10->field_2;
        v10->field_8 = v5;
        v10->field_9 = v5;
        v10->field_5 = v5;
      }
    }
    else
    {
      v7 = (int)v6;
      qmemcpy(v6, (const void *)this_->field_2, 4 * this_->field_4);
      free((void *)v10->field_2);
      v10->field_5 = v5;
      v10->field_6 = v5;
      v10->field_9 = v5;
      v10->field_2 = v7;
    }
  }
}

//----- (00404EA0) --------------------------------------------------------
int __thiscall sub_404EA0(int this, int a2)
{
  int v2; // esi@1
  unsigned int v3; // eax@1
  int result; // eax@2
  int v5; // eax@3
  _DWORD *v6; // edi@4
  int v7; // ecx@6

  v2 = this;
  v3 = *(_DWORD *)(this + 28);
  if ( v3 >= *(_DWORD *)(this + 32) )
  {
    v5 = *(_DWORD *)(*(_DWORD *)(this + 24) + 4);
    if ( v5 )
    {
      *(_DWORD *)(this + 24) = v5;
    }
    else
    {
      v6 = calloc_crt(1, 8);
      *v6 = calloc_crt(100, 4);
      v6[1] = 0;
      *(_DWORD *)(*(_DWORD *)(v2 + 24) + 4) = v6;
      *(_DWORD *)(v2 + 24) = v6;
      *(_DWORD *)*v6 = a2;
    }
    v7 = *(_DWORD *)(v2 + 16);
    result = *(_DWORD *)(v2 + 12) + 1;
    *(_DWORD *)(v2 + 28) = 1;
    *(_DWORD *)(v2 + 32) = 100;
    *(_DWORD *)(v2 + 16) = v7 + 100;
    *(_DWORD *)(v2 + 12) = result;
  }
  else
  {
    *(_DWORD *)(**(_DWORD **)(this + 24) + 4 * v3) = a2;
    result = *(_DWORD *)(this + 12) + 1;
    ++*(_DWORD *)(this + 28);
    *(_DWORD *)(this + 12) = result;
  }
  return result;
}

//----- (00404F30) --------------------------------------------------------
int __thiscall sub_404F30(int this, unsigned int a2)
{
  unsigned int v3; // ebx@3
  int v4; // edi@5
  unsigned int v5; // edx@7
  int v6; // ecx@7

  if ( a2 >= *(_DWORD *)(this + 12) )
  {
    return 0;
  }
  v3 = *(_DWORD *)(this + 20);
  if ( a2 < v3 )
  {
    return *(_DWORD *)(*(_DWORD *)(this + 4) + 4 * a2);
  }
  v4 = *(_DWORD *)(this + 8);
  if ( !v4 )
  {
    return 0;
  }
  v5 = (a2 - v3) / 0x64;
  v6 = 0;
  if ( !v5 )
  {
    return *(_DWORD *)(*(_DWORD *)v4 + 4 * (a2 - 100 * v6 - v3));
  }
  while ( 1 )
  {
    v4 = *(_DWORD *)(v4 + 4);
    if ( !v4 )
    {
      break;
    }
    if ( ++v6 >= v5 )
    {
      return *(_DWORD *)(*(_DWORD *)v4 + 4 * (a2 - 100 * v6 - v3));
    }
  }
  return 0;
}

//----- (00404FA0) --------------------------------------------------------
void __thiscall MemSmth::Internal::Destructor(MemSmth *this)
{
  MemSmth *v1; // ebx@1
  int v2; // esi@1
  int v3; // edi@2

  v1 = this;
  v2 = this->field_3;
  this->field_1 = (int)MemSmth::Internal::vtable_off_422588;
  if ( v2 )
  {
    do
    {
      free(*(void **)v2);
      v3 = *(_DWORD *)(v2 + 4);
      free((void *)v2);
      v2 = v3;
    }
    while ( v3 );
  }
  free((void *)v1->field_2);
}
// 422588: using guessed type int (__thiscall *MemSmth::Internal::vtable_off_422588[2])(void *, char);

//----- (00404FE0) --------------------------------------------------------
SmallBufferBlock *__thiscall SmallBufferBlock::SmallBufferBlock(SmallBufferBlock *this)
{
  SmallBufferBlock *this_; // esi@1
  void *buffer; // eax@1

  this_ = this;
  this->vtable = (int *)&SmallBufferBlock__vtable;
  buffer = calloc_crt(1000, 4);
  this_->m_begin = buffer;
  this_->m_current = (int)buffer;
  this_->m_end = (int)buffer + 3996;
  this_->m_used = 0;
  return this_;
}
// 42258C: using guessed type int (__thiscall *SmallBufferBlock__vtable)(void *, char);

//----- (00405020) --------------------------------------------------------
char *__thiscall sub_405020(int this, int a2)
{
  int v2; // ebx@1
  int *v3; // eax@1
  int v4; // eax@4
  char *result; // eax@5
  int v6; // ebp@7
  void *v7; // eax@7
  char *v8; // [sp+8h] [bp+4h]@7

  v2 = this;
  v3 = *(int **)(this + 12);
  if ( v3 == *(int **)(this + 8) )
  {
    v6 = ((*(_DWORD *)(this + 16) - *(_DWORD *)(this + 4)) >> 2) + 1;
    v7 = calloc_crt(((*(_DWORD *)(this + 16) - *(_DWORD *)(this + 4)) >> 2) + 101, 4);
    qmemcpy(v7, *(const void **)(v2 + 8), 4 * ((*(_DWORD *)(v2 + 16) - *(_DWORD *)(v2 + 8)) >> 2) + 4);
    v8 = (char *)v7;
    qmemcpy((char *)v7 + 4 * ((*(_DWORD *)(v2 + 16) - *(_DWORD *)(v2 + 8)) >> 2) + 4, *(const void **)(v2 + 4), 4 * ((*(_DWORD *)(v2 + 12) - *(_DWORD *)(v2 + 4)) >> 2));
    free(*(void **)(v2 + 4));
    *(_DWORD *)(v2 + 4) = v8;
    *(_DWORD *)(v2 + 8) = v8;
    result = &v8[4 * v6 + 396];
    *(_DWORD *)(v2 + 12) = &v8[4 * v6 - 4];
    *(_DWORD *)(v2 + 16) = result;
  }
  else
  {
    *v3 = a2;
    if ( !*(_DWORD *)(this + 8) )
    {
      *(_DWORD *)(this + 8) = *(_DWORD *)(this + 12);
    }
    v4 = *(_DWORD *)(this + 12);
    if ( v4 == *(_DWORD *)(this + 16) )
    {
      result = *(char **)(this + 4);
      *(_DWORD *)(this + 12) = result;
    }
    else
    {
      result = (char *)(v4 + 4);
      *(_DWORD *)(this + 12) = result;
    }
  }
  return result;
}

//----- (00405100) --------------------------------------------------------
int __thiscall sub_405100(void *this)
{
  int result; // eax@1

  result = *((_DWORD *)this + 2);
  if ( !result )
  {
    return result;
  }
  if ( result == *((_DWORD *)this + 4) )
  {
    result = *((_DWORD *)this + 1);
  }
  else
  {
    result += 4;
  }
  *((_DWORD *)this + 2) = result;
  if ( result == *((_DWORD *)this + 3) )
  {
    *((_DWORD *)this + 2) = 0;
  }
  return result;
}

//----- (00405130) --------------------------------------------------------
void __thiscall SmallBufferBlock::Destructor(SmallBufferBlock *this)
{
  void *v1; // ST00_4@1

  v1 = this->m_begin;
  this->vtable = (int *)&SmallBufferBlock__vtable;
  free(v1);
}
// 42258C: using guessed type int (__thiscall *SmallBufferBlock__vtable)(void *, char);

//----- (00405150) --------------------------------------------------------
MemSmth *__thiscall MemSmth::Internal::DeletingDestructor(MemSmth *this, char a2)
{
  MemSmth *v2; // esi@1

  v2 = this;
  MemSmth::Internal::Destructor(this);
  if ( a2 & 1 )
  {
    j__free(v2);
  }
  return v2;
}

//----- (00405170) --------------------------------------------------------
SmallBufferBlock *__thiscall SmallBufferBlock::DeletingDestructor(SmallBufferBlock *this, char a2)
{
  SmallBufferBlock *v2; // esi@1

  v2 = this;
  SmallBufferBlock::Destructor(this);
  if ( a2 & 1 )
  {
    j__free(v2);
  }
  return v2;
}

//----- (00405190) --------------------------------------------------------
int __cdecl sub_405190(int a1)
{
  int result; // eax@1
  int i; // ecx@1

  result = a1;
  for ( i = *(_DWORD *)(a1 + 8); !*(_BYTE *)(i + 21); i = *(_DWORD *)(i + 8) )
  {
    result = i;
  }
  return result;
}

//----- (004051B0) --------------------------------------------------------
_DWORD *__cdecl sub_4051B0(_DWORD *a1)
{
  _DWORD *result; // eax@1
  int i; // ecx@1

  result = a1;
  for ( i = *a1; !*(_BYTE *)(i + 21); i = *(_DWORD *)i )
  {
    result = (_DWORD *)i;
  }
  return result;
}

//----- (004051D0) --------------------------------------------------------
int __thiscall sub_4051D0(int this, int a2)
{
  int result; // eax@1
  int v3; // ecx@3
  int v4; // ecx@5

  result = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)result;
  if ( !*(_BYTE *)(*(_DWORD *)result + 21) )
  {
    *(_DWORD *)(*(_DWORD *)result + 4) = a2;
  }
  *(_DWORD *)(result + 4) = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)(this + 4);
  if ( a2 == *(_DWORD *)(v3 + 4) )
  {
    *(_DWORD *)(v3 + 4) = result;
    *(_DWORD *)result = a2;
    *(_DWORD *)(a2 + 4) = result;
  }
  else
  {
    v4 = *(_DWORD *)(a2 + 4);
    if ( a2 == *(_DWORD *)v4 )
    {
      *(_DWORD *)v4 = result;
      *(_DWORD *)result = a2;
      *(_DWORD *)(a2 + 4) = result;
    }
    else
    {
      *(_DWORD *)(v4 + 8) = result;
      *(_DWORD *)result = a2;
      *(_DWORD *)(a2 + 4) = result;
    }
  }
  return result;
}

//----- (00405230) --------------------------------------------------------
int __thiscall sub_405230(int this, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  int v4; // ecx@3
  int v5; // ecx@5

  result = *(_DWORD *)a2;
  *(_DWORD *)a2 = *(_DWORD *)(*(_DWORD *)a2 + 8);
  v3 = *(_DWORD *)(result + 8);
  if ( !*(_BYTE *)(v3 + 21) )
  {
    *(_DWORD *)(v3 + 4) = a2;
  }
  *(_DWORD *)(result + 4) = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)(this + 4);
  if ( a2 == *(_DWORD *)(v4 + 4) )
  {
    *(_DWORD *)(v4 + 4) = result;
    *(_DWORD *)(result + 8) = a2;
    *(_DWORD *)(a2 + 4) = result;
  }
  else
  {
    v5 = *(_DWORD *)(a2 + 4);
    if ( a2 == *(_DWORD *)(v5 + 8) )
    {
      *(_DWORD *)(v5 + 8) = result;
      *(_DWORD *)(result + 8) = a2;
      *(_DWORD *)(a2 + 4) = result;
    }
    else
    {
      *(_DWORD *)v5 = result;
      *(_DWORD *)(result + 8) = a2;
      *(_DWORD *)(a2 + 4) = result;
    }
  }
  return result;
}

//----- (00405330) --------------------------------------------------------
char __stdcall sub_405330(void *a1)
{
  void *v1; // edi@1
  char result; // al@1
  void *i; // esi@1

  v1 = a1;
  result = *((_BYTE *)a1 + 21);
  for ( i = a1; !result; v1 = i )
  {
    sub_405330(*((void **)i + 2));
    i = *(void **)i;
    j__free(v1);
    result = *((_BYTE *)i + 21);
  }
  return result;
}

//----- (00405370) --------------------------------------------------------
_BYTE *__thiscall sub_405370(void *this, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  void *v4; // ebx@1
  void *v5; // edx@3
  unsigned int v6; // ecx@3
  const void *v7; // esi@5
  _BYTE *result; // eax@10
  int v9; // [sp+0h] [bp-24h]@1
  void *v10; // [sp+Ch] [bp-18h]@1
  int v11; // [sp+10h] [bp-14h]@1
  int *v12; // [sp+14h] [bp-10h]@1
  int v13; // [sp+20h] [bp-4h]@3
  void *v14; // [sp+2Ch] [bp+8h]@3

  v3 = a2 | 0xF;
  v4 = this;
  v12 = &v9;
  v10 = this;
  v11 = a2 | 0xF;
  if ( (a2 | 0xFu) > 0xFFFFFFFE )
  {
    v11 = a2;
    v3 = a2;
  }
  v13 = 0;
  v5 = operator new(v3 + 1);
  v14 = v5;
  v6 = a3;
  if ( a3 )
  {
    if ( *((_DWORD *)v4 + 6) < 0x10u )
    {
      v7 = (char *)v4 + 4;
    }
    else
    {
      v7 = (const void *)*((_DWORD *)v4 + 1);
    }
    qmemcpy(v5, v7, a3);
    v3 = v11;
    v6 = a3;
  }
  if ( *((_DWORD *)v4 + 6) >= 0x10u )
  {
    j__free(*((void **)v4 + 1));
    v5 = v14;
    v6 = a3;
  }
  result = (char *)v4 + 4;
  *result = 0;
  *(_DWORD *)result = v5;
  *((_DWORD *)v4 + 6) = v3;
  *((_DWORD *)v4 + 5) = v6;
  if ( v3 >= 0x10 )
  {
    result = v5;
  }
  result[v6] = 0;
  return result;
}

//----- (0040545D) --------------------------------------------------------
void __usercall __noreturn sub_40545D(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 - 24);
  if ( *(_DWORD *)(v1 + 24) >= 0x10u )
  {
    j__free(*(void **)(v1 + 4));
  }
  *(_DWORD *)(v1 + 24) = 15;
  *(_DWORD *)(v1 + 20) = 0;
  *(_BYTE *)(v1 + 4) = 0;
  _CxxThrowException(0, 0);
}
// 413348: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (004054C0) --------------------------------------------------------
int __thiscall sub_4054C0(int this, unsigned int a2, char a3)
{
  int v3; // esi@1
  unsigned int v4; // eax@3
  int result; // eax@5

  v3 = this;
  if ( a2 > 0xFFFFFFFE )
  {
    String_base::_Xlen__();
  }
  v4 = *(_DWORD *)(this + 24);
  if ( v4 >= a2 )
  {
    if ( a3 && a2 < 0x10 )
    {
      if ( v4 >= 0x10 )
      {
        j__free(*(void **)(this + 4));
      }
      *(_DWORD *)(v3 + 24) = 15;
      *(_DWORD *)(v3 + 20) = 0;
      *(_BYTE *)(v3 + 4) = 0;
      result = a2 > 0;
    }
    else
    {
      if ( !a2 )
      {
        *(_DWORD *)(this + 20) = 0;
        if ( v4 >= 0x10 )
        {
          **(_BYTE **)(this + 4) = 0;
          return 0;
        }
        *(_BYTE *)(this + 4) = 0;
      }
      result = a2 > 0;
    }
  }
  else if ( a3 )
  {
    sub_405370((void *)this, a2, 0);
    result = a2 > 0;
  }
  else
  {
    sub_405370((void *)this, a2, *(_DWORD *)(this + 20));
    result = a2 > 0;
  }
  return result;
}

//----- (004055A0) --------------------------------------------------------
int __thiscall sub_4055A0(int this, unsigned int a2, unsigned int a3)
{
  int v3; // edi@1
  unsigned int v4; // ebx@3
  unsigned int v5; // eax@3
  unsigned int v6; // ecx@6
  int *v7; // ebp@6
  int v8; // edx@7
  int v9; // ecx@10
  unsigned int v10; // esi@12
  unsigned int v11; // eax@14
  bool v12; // zf@15
  bool v13; // cf@17
  int result; // eax@20

  v3 = this;
  if ( *(_DWORD *)(this + 20) < a2 )
  {
    std::_Xran();
  }
  v4 = a3;
  v5 = *(_DWORD *)(this + 20) - a2;
  if ( v5 < a3 )
  {
    v4 = *(_DWORD *)(this + 20) - a2;
  }
  if ( !v4 )
  {
    return v3;
  }
  v6 = *(_DWORD *)(this + 24);
  v7 = (int *)(v3 + 4);
  if ( v6 < 0x10 )
  {
    v8 = v3 + 4;
  }
  else
  {
    v8 = *v7;
  }
  if ( v6 < 0x10 )
  {
    v9 = v3 + 4;
  }
  else
  {
    v9 = *v7;
  }
  memcpy((void *)(a2 + v9), (const void *)(v4 + a2 + v8), v5 - v4);
  v10 = *(_DWORD *)(v3 + 20) - v4;
  if ( v10 > 0xFFFFFFFE )
  {
    String_base::_Xlen__();
  }
  v11 = *(_DWORD *)(v3 + 24);
  if ( v11 < v10 )
  {
    sub_405370((void *)v3, v10, *(_DWORD *)(v3 + 20));
    v12 = v10 == 0;
    goto LABEL_16;
  }
  v12 = *(_DWORD *)(v3 + 20) == v4;
  if ( *(_DWORD *)(v3 + 20) != v4 )
  {
LABEL_16:
    if ( v12 )
    {
      return v3;
    }
    v13 = *(_DWORD *)(v3 + 24) < 0x10u;
    *(_DWORD *)(v3 + 20) = v10;
    if ( !v13 )
    {
      v7 = (int *)*v7;
    }
    *((_BYTE *)v7 + v10) = 0;
    return v3;
  }
  *(_DWORD *)(v3 + 20) = 0;
  if ( v11 >= 0x10 )
  {
    v7 = (int *)*v7;
  }
  result = v3;
  *(_BYTE *)v7 = 0;
  return result;
}

//----- (00405660) --------------------------------------------------------
void *__thiscall sub_405660(void *this, int a2, unsigned int a3, unsigned int a4)
{
  void *v4; // ebx@1
  unsigned int v5; // ebp@3
  void *result; // eax@6
  int v7; // esi@9
  void **v8; // eax@11
  void *v9; // edx@12
  bool v10; // cf@14

  v4 = this;
  if ( *(_DWORD *)(a2 + 20) < a3 )
  {
    std::_Xran();
  }
  v5 = *(_DWORD *)(a2 + 20) - a3;
  if ( a4 < v5 )
  {
    v5 = a4;
  }
  if ( this == (void *)a2 )
  {
    sub_4055A0((int)this, a3 + v5, 0xFFFFFFFF);
    sub_4055A0((int)v4, 0, a3);
    result = v4;
  }
  else
  {
    if ( (unsigned __int8)sub_4054C0((int)this, v5, 1) )
    {
      if ( *(_DWORD *)(a2 + 24) < 0x10u )
      {
        v7 = a2 + 4;
      }
      else
      {
        v7 = *(_DWORD *)(a2 + 4);
      }
      v8 = (void **)((char *)v4 + 4);
      if ( *((_DWORD *)v4 + 6) < 0x10u )
      {
        v9 = (char *)v4 + 4;
      }
      else
      {
        v9 = *v8;
      }
      qmemcpy(v9, (const void *)(a3 + v7), v5);
      v10 = *((_DWORD *)v4 + 6) < 0x10u;
      *((_DWORD *)v4 + 5) = v5;
      if ( !v10 )
      {
        v8 = (void **)*v8;
      }
      *((_BYTE *)v8 + v5) = 0;
    }
    result = v4;
  }
  return result;
}

//----- (00405710) --------------------------------------------------------
void *__thiscall sub_405710(int this, const void *a2, unsigned int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  unsigned int *v5; // ebp@1
  unsigned int v6; // eax@2
  int v7; // eax@6
  void *result; // eax@11
  void *v9; // edi@14
  bool v10; // cf@16

  v3 = this;
  v4 = *(_DWORD *)(this + 24);
  v5 = (unsigned int *)(v3 + 4);
  if ( v4 < 0x10 )
  {
    v6 = v3 + 4;
  }
  else
  {
    v6 = *v5;
  }
  if ( v6 > (unsigned int)a2 || (v4 < 0x10 ? (v7 = v3 + 4) : (v7 = *v5), (unsigned int)a2 >= v7 + *(_DWORD *)(v3 + 20)) )
  {
    if ( (unsigned __int8)sub_4054C0(v3, a3, 1) )
    {
      if ( *(_DWORD *)(v3 + 24) < 0x10u )
      {
        v9 = (void *)(v3 + 4);
      }
      else
      {
        v9 = (void *)*v5;
      }
      qmemcpy(v9, a2, a3);
      v10 = *(_DWORD *)(v3 + 24) < 0x10u;
      *(_DWORD *)(v3 + 20) = a3;
      if ( !v10 )
      {
        v5 = (unsigned int *)*v5;
      }
      *((_BYTE *)v5 + a3) = 0;
    }
    result = (void *)v3;
  }
  else
  {
    if ( v4 >= 0x10 )
    {
      v5 = (unsigned int *)*v5;
    }
    result = sub_405660((void *)v3, v3, (_BYTE *)a2 - (_BYTE *)v5, a3);
  }
  return result;
}

//----- (004057B0) --------------------------------------------------------
void *__thiscall sub_4057B0(void *this, int a2)
{
  void *v2; // esi@1
  int v3; // ecx@1

  v2 = this;
  exception::exception();
  v3 = (int)v2 + 12;
  *(_DWORD *)v2 = &std::logic_error::`vftable';
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)(v3 + 24) = 15;
  *(_BYTE *)(v3 + 4) = 0;
  sub_405660((char *)v2 + 12, a2, 0, 0xFFFFFFFF);
  return v2;
}
// 413382: using guessed type int exception::exception(void);
// 4293A8: using guessed type int (__thiscall *std::logic_error::`vftable')(void *, char);

//----- (00405810) --------------------------------------------------------
void *__thiscall sub_405810(void *this, char a2)
{
  void *v2; // esi@1
  unsigned int v4; // [sp+0h] [bp-4h]@0

  v2 = this;
  _ismbbkana(v4);
  if ( a2 & 1 )
  {
    j__free(v2);
  }
  return v2;
}

//----- (00405870) --------------------------------------------------------
int __thiscall sub_405870(int this, const void *a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 24) = 15;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 4) = 0;
  sub_405710(this, a2, strlen((const char *)a2));
  return v2;
}

//----- (004058B0) --------------------------------------------------------
void *__thiscall sub_4058B0(void *this, int a2)
{
  void *v2; // esi@1
  int v3; // ecx@1

  v2 = this;
  exception::exception(a2);
  v3 = (int)v2 + 12;
  *(_DWORD *)v2 = &std::logic_error::`vftable';
  *(_DWORD *)(v3 + 24) = 15;
  *(_DWORD *)(v3 + 20) = 0;
  *(_BYTE *)(v3 + 4) = 0;
  sub_405660((char *)v2 + 12, a2 + 12, 0, 0xFFFFFFFF);
  return v2;
}
// 4133D0: using guessed type _DWORD __stdcall exception::exception(_DWORD);
// 4293A8: using guessed type int (__thiscall *std::logic_error::`vftable')(void *, char);

//----- (00405920) --------------------------------------------------------
int *__thiscall sub_405920(void *this, int *a2, int a3)
{
  int v3; // edi@1
  int v4; // ebx@4
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // esi@9
  _DWORD *v8; // ecx@11
  int v9; // eax@11
  _DWORD *v10; // edi@16
  _DWORD *v11; // eax@18
  int v12; // edi@21
  int v13; // eax@30
  int v14; // eax@32
  char v15; // al@35
  int v16; // eax@39
  bool v17; // zf@54
  int v18; // eax@60
  int *result; // eax@62
  _DWORD *v20; // [sp+8h] [bp-58h]@1
  _BYTE *v21; // [sp+Ch] [bp-54h]@4
  char v22; // [sp+10h] [bp-50h]@2
  char v23; // [sp+14h] [bp-4Ch]@2
  int v24; // [sp+24h] [bp-3Ch]@2
  int v25; // [sp+28h] [bp-38h]@2
  int (__thiscall **v26)(void *, char); // [sp+2Ch] [bp-34h]@2
  int v27; // [sp+5Ch] [bp-4h]@2

  v3 = a3;
  v20 = this;
  if ( *(_BYTE *)(a3 + 21) )
  {
    v25 = 15;
    v24 = 0;
    v23 = 0;
    sub_405710((int)&v22, "invalid map/set<T> iterator", strlen("invalid map/set<T> iterator"));
    v27 = 0;
    sub_4057B0(&v26, (int)&v22);
    v26 = &std::out_of_range::`vftable';
    _CxxThrowException(&v26, &unk_42AC98);
  }
  v4 = a3;
  v21 = (_BYTE *)a3;
  Utils__isNumber(&a3);
  v5 = *(_DWORD *)v3;
  v6 = v3 + 8;
  if ( !*(_BYTE *)(*(_DWORD *)v3 + 21) )
  {
    if ( *(_BYTE *)(*(_DWORD *)v6 + 21) )
    {
      goto LABEL_8;
    }
    v3 = a3;
    v6 = a3 + 8;
  }
  v5 = *(_DWORD *)v6;
LABEL_8:
  if ( v3 == v4 )
  {
    v7 = *(_DWORD *)(v4 + 4);
    if ( !*(_BYTE *)(v5 + 21) )
    {
      *(_DWORD *)(v5 + 4) = v7;
    }
    v8 = v20;
    v9 = v20[1];
    if ( *(_DWORD *)(v9 + 4) == v4 )
    {
      *(_DWORD *)(v9 + 4) = v5;
    }
    else if ( *(_DWORD *)v7 == v4 )
    {
      *(_DWORD *)v7 = v5;
    }
    else
    {
      *(_DWORD *)(v7 + 8) = v5;
    }
    v10 = (_DWORD *)v20[1];
    if ( *v10 == v4 )
    {
      if ( *(_BYTE *)(v5 + 21) )
      {
        v11 = (_DWORD *)v7;
      }
      else
      {
        v11 = sub_4051B0((_DWORD *)v5);
        v8 = v20;
      }
      *v10 = v11;
    }
    v12 = v8[1];
    if ( *(_DWORD *)(v12 + 8) == v4 )
    {
      if ( *(_BYTE *)(v5 + 21) )
      {
        *(_DWORD *)(v12 + 8) = v7;
      }
      else
      {
        *(_DWORD *)(v12 + 8) = sub_405190(v5);
      }
    }
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)v4 + 4) = v3;
    *(_DWORD *)v3 = *(_DWORD *)v4;
    if ( v3 == *(_DWORD *)(v4 + 8) )
    {
      v7 = v3;
    }
    else
    {
      v7 = *(_DWORD *)(v3 + 4);
      if ( !*(_BYTE *)(v5 + 21) )
      {
        *(_DWORD *)(v5 + 4) = v7;
      }
      *(_DWORD *)v7 = v5;
      *(_DWORD *)v6 = *(_DWORD *)(v4 + 8);
      *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4) = v3;
    }
    v13 = v20[1];
    if ( *(_DWORD *)(v13 + 4) == v4 )
    {
      *(_DWORD *)(v13 + 4) = v3;
    }
    else
    {
      v14 = *(_DWORD *)(v4 + 4);
      if ( *(_DWORD *)v14 == v4 )
      {
        *(_DWORD *)v14 = v3;
      }
      else
      {
        *(_DWORD *)(v14 + 8) = v3;
      }
    }
    *(_DWORD *)(v3 + 4) = *(_DWORD *)(v4 + 4);
    v15 = *(_BYTE *)(v3 + 20);
    *(_BYTE *)(v3 + 20) = *(_BYTE *)(v4 + 20);
    *(_BYTE *)(v4 + 20) = v15;
  }
  if ( v21[20] == 1 )
  {
    if ( v5 != *(_DWORD *)(v20[1] + 4) )
    {
      do
      {
        if ( *(_BYTE *)(v5 + 20) != 1 )
        {
          break;
        }
        v16 = *(_DWORD *)v7;
        if ( v5 == *(_DWORD *)v7 )
        {
          v16 = *(_DWORD *)(v7 + 8);
          if ( !*(_BYTE *)(v16 + 20) )
          {
            *(_BYTE *)(v16 + 20) = 1;
            *(_BYTE *)(v7 + 20) = 0;
            sub_4051D0((int)v20, v7);
            v16 = *(_DWORD *)(v7 + 8);
          }
          if ( *(_BYTE *)(v16 + 21) )
          {
            goto LABEL_54;
          }
          if ( *(_BYTE *)(*(_DWORD *)v16 + 20) != 1 || *(_BYTE *)(*(_DWORD *)(v16 + 8) + 20) != 1 )
          {
            if ( *(_BYTE *)(*(_DWORD *)(v16 + 8) + 20) == 1 )
            {
              *(_BYTE *)(*(_DWORD *)v16 + 20) = 1;
              *(_BYTE *)(v16 + 20) = 0;
              sub_405230((int)v20, v16);
              v16 = *(_DWORD *)(v7 + 8);
            }
            *(_BYTE *)(v16 + 20) = *(_BYTE *)(v7 + 20);
            *(_BYTE *)(v7 + 20) = 1;
            *(_BYTE *)(*(_DWORD *)(v16 + 8) + 20) = 1;
            sub_4051D0((int)v20, v7);
            break;
          }
        }
        else
        {
          if ( !*(_BYTE *)(v16 + 20) )
          {
            *(_BYTE *)(v16 + 20) = 1;
            *(_BYTE *)(v7 + 20) = 0;
            sub_405230((int)v20, v7);
            v16 = *(_DWORD *)v7;
          }
          if ( *(_BYTE *)(v16 + 21) )
          {
            goto LABEL_54;
          }
          if ( *(_BYTE *)(*(_DWORD *)(v16 + 8) + 20) != 1 || *(_BYTE *)(*(_DWORD *)v16 + 20) != 1 )
          {
            if ( *(_BYTE *)(*(_DWORD *)v16 + 20) == 1 )
            {
              *(_BYTE *)(*(_DWORD *)(v16 + 8) + 20) = 1;
              *(_BYTE *)(v16 + 20) = 0;
              sub_4051D0((int)v20, v16);
              v16 = *(_DWORD *)v7;
            }
            *(_BYTE *)(v16 + 20) = *(_BYTE *)(v7 + 20);
            *(_BYTE *)(v7 + 20) = 1;
            *(_BYTE *)(*(_DWORD *)v16 + 20) = 1;
            sub_405230((int)v20, v7);
            break;
          }
        }
        *(_BYTE *)(v16 + 20) = 0;
LABEL_54:
        v5 = v7;
        v17 = v7 == *(_DWORD *)(v20[1] + 4);
        v7 = *(_DWORD *)(v7 + 4);
      }
      while ( !v17 );
    }
    *(_BYTE *)(v5 + 20) = 1;
  }
  j__free(v21);
  v18 = v20[2];
  if ( v18 )
  {
    v20[2] = v18 - 1;
  }
  result = a2;
  *a2 = a3;
  return result;
}
// 413348: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 4293C0: using guessed type int (__thiscall *std::out_of_range::`vftable')(void *, char);

//----- (00405C30) --------------------------------------------------------
int *__thiscall sub_405C30(int this, int *a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // eax@1
  _DWORD *v8; // eax@3
  int *result; // eax@3
  int v10; // ecx@5
  int v11; // eax@6
  int j; // eax@7
  int i; // eax@10

  v4 = a4;
  v5 = a3;
  v6 = this;
  v7 = *(_DWORD *)(this + 4);
  if ( a3 != *(_DWORD *)v7 || a4 != v7 )
  {
    if ( a3 != a4 )
    {
      do
      {
        v10 = v5;
        if ( !*(_BYTE *)(v5 + 21) )
        {
          v11 = *(_DWORD *)(v5 + 8);
          if ( *(_BYTE *)(v11 + 21) )
          {
            for ( i = *(_DWORD *)(v5 + 4); !*(_BYTE *)(i + 21); i = *(_DWORD *)(i + 4) )
            {
              if ( v5 != *(_DWORD *)(i + 8) )
              {
                break;
              }
              v5 = i;
            }
            v5 = i;
          }
          else
          {
            v5 = *(_DWORD *)(v5 + 8);
            for ( j = *(_DWORD *)v11; !*(_BYTE *)(j + 21); j = *(_DWORD *)j )
            {
              v5 = j;
            }
          }
        }
        sub_405920((void *)v6, &a3, v10);
      }
      while ( v5 != v4 );
    }
    result = a2;
    *a2 = v5;
  }
  else
  {
    sub_405330(*(void **)(v7 + 4));
    *(_DWORD *)(*(_DWORD *)(v6 + 4) + 4) = *(_DWORD *)(v6 + 4);
    v8 = *(_DWORD **)(v6 + 4);
    *(_DWORD *)(v6 + 8) = 0;
    *v8 = v8;
    *(_DWORD *)(*(_DWORD *)(v6 + 4) + 8) = *(_DWORD *)(v6 + 4);
    result = a2;
    *a2 = **(_DWORD **)(v6 + 4);
  }
  return result;
}

//----- (00405D20) --------------------------------------------------------
void __thiscall CQsCheck::Destructor(struct _RTL_CRITICAL_SECTION *lpCriticalSection)
{
  struct _RTL_CRITICAL_SECTION *v1; // esi@1
  void *v2; // eax@1
  int *v3; // eax@3
  char *v4; // esi@3
  int v5; // ST04_4@3
  char v6; // [sp+Ch] [bp-14h]@1
  struct _RTL_CRITICAL_SECTION *v7; // [sp+10h] [bp-10h]@1
  int v8; // [sp+1Ch] [bp-4h]@1

  v1 = lpCriticalSection;
  v7 = lpCriticalSection;
  v8 = 1;
  guard(&v6, L"CQsCheck::~CQsCheck(void)");
  DeleteCriticalSection(v1);
  DeleteCriticalSection(v1 + 1);
  DeleteCriticalSection(v1 + 349639);
  unguard();
  v2 = v1[349640].LockSemaphore;
  LOBYTE(v8) = 0;
  if ( v2 )
  {
    MMU::deallocate(&g_mmu, v2);
  }
  v1[349640].LockSemaphore = 0;
  v1[349640].SpinCount = 0;
  v1[349641].DebugInfo = 0;
  v3 = (int *)v1[349640].LockCount;
  v4 = (char *)&v1[349640];
  v5 = *v3;
  v8 = -1;
  sub_405C30((int)v4, (int *)&v7, v5, (int)v3);
  j__free(*((void **)v4 + 1));
  *((_DWORD *)v4 + 1) = 0;
  *((_DWORD *)v4 + 2) = 0;
}
// 800AC4: using guessed type int dword_800AC4;
// 800AD0: using guessed type int dword_800AD0;
// 800AD4: using guessed type int dword_800AD4;
// 800AD8: using guessed type int dword_800AD8;
// 1BD3B5C: using guessed type int g_mmu;

//----- (00405DF0) --------------------------------------------------------
LPCRITICAL_SECTION __thiscall CQsCheck::CQsCheck(LPCRITICAL_SECTION lpCriticalSection)
{
  LPCRITICAL_SECTION v1; // esi@1
  LPCRITICAL_SECTION v2; // edi@1
  int v3; // eax@1
  char v5; // [sp+Fh] [bp-15h]@0
  char v6; // [sp+10h] [bp-14h]@1
  LPCRITICAL_SECTION v7; // [sp+14h] [bp-10h]@1
  int v8; // [sp+20h] [bp-4h]@1

  v1 = lpCriticalSection;
  v2 = lpCriticalSection + 349640;
  v7 = lpCriticalSection;
  LOBYTE(lpCriticalSection[349640].DebugInfo) = v5;
  v3 = std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::assign(&lpCriticalSection[349640]);
  v2->LockCount = v3;
  *(_BYTE *)(v3 + 21) = 1;
  *(_DWORD *)(v2->LockCount + 4) = v2->LockCount;
  *(_DWORD *)v2->LockCount = v2->LockCount;
  *(_DWORD *)(v2->LockCount + 8) = v2->LockCount;
  v2->RecursionCount = 0;
  v8 = 0;
  v1[349640].LockSemaphore = 0;
  v1[349640].SpinCount = 0;
  v1[349641].DebugInfo = 0;
  LOBYTE(v8) = 1;
  guard(&v6, L"CQsCheck::CQsCheck(void)");
  InitializeCriticalSection(v1);
  InitializeCriticalSection(v1 + 1);
  InitializeCriticalSection(v1 + 349639);
  memset(&v1[2], 0, 0x800000u);
  v1[349527].RecursionCount = 0;
  v1[349527].OwningThread = 0;
  v1[349527].LockSemaphore = 0;
  memset(&v1[349528], 0, 0x378u);
  memset(&v1[349565], 0, 0x378u);
  memset(&v1[349602], 0, 0x378u);
  unguard();
  return v1;
}
// 4052F0: using guessed type int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::assign(_DWORD);
// 800030: using guessed type int dword_800030;
// 800034: using guessed type int dword_800034;
// 800038: using guessed type int dword_800038;
// 800AD0: using guessed type int dword_800AD0;
// 800AD4: using guessed type int dword_800AD4;
// 800AD8: using guessed type int dword_800AD8;

//----- (00405EF0) --------------------------------------------------------
LONG __thiscall LockStack::Push(LockStack *this, int recurent, int deep, const wchar_t *lockName, int line)
{
  LockStack *this_; // edi@1
  volatile __int32 *lockStack; // esi@1

  this_ = this;
  lockStack = &this->m_lockCount;
  if ( this->m_lockCount >= 10000 )
  {
    CLog::Add(&g_winlog, LOG_ERROR, L"Lock stack is small?? -_-;;; kuooo");
  }
  this_->m_lockFrames[*lockStack].m_deep = deep;
  this_->m_lockFrames[*lockStack].m_recurent = recurent;
  this_->m_lockFrames[*lockStack].m_lockName = lockName;
  this_->m_lockFrames[*lockStack].m_line = line;
  return InterlockedIncrement(lockStack);
}

//----- (00405F60) --------------------------------------------------------
LONG __thiscall LockStack::Pop(LockStack *this, int recurent, int m_deep, const wchar_t *unlockName, int unlocker)
{
  LockStack *this_; // edi@1
  volatile __int32 *lockCount; // esi@1
  LONG result; // eax@3

  this_ = this;
  lockCount = &this->m_lockCount;
  if ( !this->m_lockCount )
  {
    CLog::Add(&g_winlog, LOG_ERROR, L"NO WAY!!! trying to unlock the unlocked lock -_-;;; kuooo mansei");
  }
  InterlockedDecrement(lockCount);
  this_->m_lockFrames[*lockCount].m_deep = 0;
  this_->m_lockFrames[*lockCount].m_recurent = 0;
  this_->m_lockFrames[*lockCount].m_lockName = 0;
  result = *lockCount;
  this_->m_lockFrames[result].m_line = 0;
  return result * 16;
}

//----- (00405FD0) --------------------------------------------------------
int CThreadManager::SetThisThreadAsMainThread()
{
  int result; // eax@1

  result = TlsIndex;
  *(_DWORD *)(*(_DWORD *)(__readfsdword(0x2C) + 4 * TlsIndex) + 8) = 11;
  return result;
}
// 1BD5478: using guessed type int TlsIndex;

//----- (00405FF0) --------------------------------------------------------
BOOL CThreadManager::isMainThread()
{
  return *(_DWORD *)(*(_DWORD *)(__readfsdword(44) + 4 * TlsIndex) + 8) == ThreadIndex_Main;
}
// 1BD5478: using guessed type int TlsIndex;

//----- (00406010) --------------------------------------------------------
bool __cdecl CThreadManager::isListenThread()
{
  return *(_DWORD *)(*(_DWORD *)(__readfsdword(44) + 4 * TlsIndex) + 8) == ThreadIndex_ListenThread;
}
// 1BD5478: using guessed type int TlsIndex;

//----- (00406030) --------------------------------------------------------
int CThreadManager::GetIOThreadNumber()
{
  return CThreadManager::s_IOThreadNumber;
}
// 19D6968: using guessed type int CThreadManager::s_IOThreadNumber;

//----- (00406040) --------------------------------------------------------
int __cdecl CThreadManager::SetIOThreadNumber(int maxIOThreadNumber)
{
  int result; // eax@1

  result = maxIOThreadNumber;
  CThreadManager::s_IOThreadNumber = maxIOThreadNumber;
  return result;
}
// 19D6968: using guessed type int CThreadManager::s_IOThreadNumber;

//----- (00406050) --------------------------------------------------------
int __cdecl CThreadManager::RegisterThisThread(ThreadIndices threadIndex)
{
  int result; // eax@1

  result = threadIndex;
  *(_DWORD *)(*(_DWORD *)(__readfsdword(0x2C) + 4 * TlsIndex) + 8) = threadIndex;
  return result;
}
// 1BD5478: using guessed type int TlsIndex;

//----- (00406070) --------------------------------------------------------
HANDLE __cdecl CThreadManager::SetThread(int index, HANDLE threadId)
{
  HANDLE result; // eax@1

  result = threadId;
  CThreadManager::s_threadIds[index] = threadId;
  return result;
}

//----- (00406080) --------------------------------------------------------
HANDLE __cdecl CThreadManager::GetThread(ThreadIndices index)
{
  return CThreadManager::s_threadIds[index];
}

//----- (00406090) --------------------------------------------------------
int tls::GetCurrentThreadIndex()
{
  return *(_DWORD *)(*(_DWORD *)(__readfsdword(0x2C) + 4 * TlsIndex) + 8);
}
// 1BD5478: using guessed type int TlsIndex;

//----- (004060B0) --------------------------------------------------------
bool __cdecl DBConn::LoadStrFromReg(WCHAR *str, const WCHAR *keyStr, const WCHAR *regEntry)
{
  bool result_1; // bl@1
  HKEY regKey; // [sp+10h] [bp-210h]@1
  DWORD type; // [sp+14h] [bp-20Ch]@2
  DWORD length; // [sp+18h] [bp-208h]@2
  char v8; // [sp+1Ch] [bp-204h]@1
  wchar_t storedValue[256]; // [sp+20h] [bp-200h]@2

  guard(&v8, L"bool LoadStrFromReg(WCHAR* str, const WCHAR* keyStr, const WCHAR* regEntry)");
  result_1 = false;
  if ( !RegOpenKeyExW(HKEY_CURRENT_USER, regEntry, 0, KEY_READ, &regKey) )
  {
    length = 256;
    if ( !RegQueryValueExW(regKey, keyStr, 0, &type, (LPBYTE)storedValue, &length) && type == REG_BINARY )
    {
      result_1 = true;
    }
    RegCloseKey(regKey);
    if ( result_1 )
    {
      goto LABEL_15;
    }
  }
  if ( !RegOpenKeyExW(HKEY_LOCAL_MACHINE, regEntry, 0, KEY_READ, &regKey) )
  {
    length = 256;
    if ( !RegQueryValueExW(regKey, keyStr, 0, &type, (LPBYTE)storedValue, &length) && type == REG_BINARY )
    {
      result_1 = true;
    }
    RegCloseKey(regKey);
    if ( result_1 )
    {
LABEL_15:
      lstrcpyW(str, storedValue);
    }
  }
  unguard();
  return result_1;
}

//----- (004061C0) --------------------------------------------------------
int __cdecl DBConn::SaveStrToReg(WCHAR *str, const WCHAR *keyStr, const WCHAR *regEntry)
{
  HKEY phkResult; // [sp+8h] [bp-20Ch]@1
  DWORD dwDisposition; // [sp+Ch] [bp-208h]@1
  char v6; // [sp+10h] [bp-204h]@1
  wchar_t buffer[256]; // [sp+14h] [bp-200h]@1

  guard(&v6, L"void SaveStrToReg(WCHAR* str, const WCHAR* keyStr, const WCHAR* regEntry)");
  lstrcpyW(buffer, str);
  if ( RegCreateKeyExW(HKEY_LOCAL_MACHINE, regEntry, 0, aClass, 0, KEY_WRITE, 0, &phkResult, &dwDisposition) && RegCreateKeyExW(HKEY_CURRENT_USER, regEntry, 0, aClass, 0, KEY_WRITE, 0, &phkResult, &dwDisposition) )
  {
    return unguard();
  }
  RegSetValueExW(phkResult, keyStr, 0, REG_BINARY, (const BYTE *)buffer, 256u);
  RegCloseKey(phkResult);
  return unguard();
}

//----- (00406280) --------------------------------------------------------
int __cdecl Utils::UnicodeToAnsi(WCHAR *unistr, int maxunilen, char *ansistr, int maxansilen)
{
  int length; // esi@1
  char v6; // [sp+10h] [bp-4h]@1

  guard(&v6, L"int UnicodeToAnsi(WCHAR* unistr, int maxunilen, char* ansistr, int maxansilen)");
  length = WideCharToMultiByte(CP_ACP, 0, unistr, -1, 0, 0, 0, 0);
  WideCharToMultiByte(CP_ACP, 0, unistr, -1, ansistr, length, 0, 0);
  ansistr[length - 1] = 0;
  unguard();
  return length;
}

//----- (004062E0) --------------------------------------------------------
int __cdecl Utils::AnsiToUnicode(const char *ansistr, int maxansilen, wchar_t *unistr, int maxunilen)
{
  int length; // esi@1
  char v6; // [sp+10h] [bp-4h]@1

  guard(&v6, L"int AnsiToUnicode(char* ansistr, int maxansilen, WCHAR* unistr, int maxunilen)");
  length = MultiByteToWideChar(0, 0, ansistr, -1, 0, 0);
  MultiByteToWideChar(0, 0, ansistr, -1, unistr, length);
  unistr[length - 1] = 0;
  unguard();
  return length;
}

//----- (00406340) --------------------------------------------------------
int __cdecl sub_406340(wchar_t *a1, int a2)
{
  int result; // eax@1
  char *v3; // edx@2
  int v4; // edi@2
  unsigned __int16 v5; // cx@3

  result = wcslen(a1);
  if ( result <= 0 )
  {
    *(_WORD *)(a2 + 2 * result) = 0;
  }
  else
  {
    v3 = (char *)a2;
    v4 = result;
    do
    {
      v5 = *(_WORD *)&v3[(_DWORD)a1 - a2];
      if ( v5 > 0x40u && v5 < 0x5Bu )
      {
        v5 += 32;
      }
      *(_WORD *)v3 = v5;
      v3 += 2;
      --v4;
    }
    while ( v4 );
    *(_WORD *)(a2 + 2 * result) = 0;
  }
  return result;
}

//----- (004063A0) --------------------------------------------------------
bool __cdecl Utils::IsNumber(wchar_t chr)
{
  return chr >= '0' && chr <= '9' || chr == '-';
}

//----- (004063C0) --------------------------------------------------------
BOOL __cdecl Config::SetPrivateProfile(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
{
  BOOL v4; // esi@1
  char v6; // [sp+4h] [bp-4h]@1

  guard(&v6, L"BOOL SetPrivateProfile(WCHAR * szSection, WCHAR * szKeyName, WCHAR * szValue, WCHAR * szFile)");
  v4 = WritePrivateProfileStringW(lpAppName, lpKeyName, lpString, lpFileName);
  unguard();
  return v4;
}

//----- (00406400) --------------------------------------------------------
BOOL __cdecl Config::SetPrivateProfile2(const wchar_t *section, const wchar_t *keyName, int value, const wchar_t *fileName)
{
  BOOL v4; // esi@1
  char v6; // [sp+Ch] [bp-204h]@1
  WCHAR string[256]; // [sp+10h] [bp-200h]@1

  guard(&v6, L"BOOL SetPrivateProfile(WCHAR * szSection, WCHAR * szKeyName, int nValue, WCHAR * szFile)");
  memset(string, 0, sizeof(string));
  Utils::ToWString(value, string, 10);
  v4 = WritePrivateProfileStringW(section, keyName, string, fileName);
  unguard();
  return v4;
}

//----- (00406470) --------------------------------------------------------
wchar_t *__thiscall sub_406470(std::wstring *this)
{
  wchar_t *result; // eax@2

  if ( this->_Myres < 140u )
  {
    result = this->m_buffer;
  }
  else
  {
    result = *(wchar_t **)&this->m_buffer[0];
  }
  return result;
}

//----- (00406490) --------------------------------------------------------
int __stdcall Mybase::_Alval_deallocate(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
  {
    result = MMU::deallocate(&g_mmu, (void *)a1);
  }
  return result;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (004064B0) --------------------------------------------------------
int __thiscall Traits::assign(std::wstring *this, int a2)
{
  bool v2; // cf@1
  int result; // eax@1

  v2 = this->_Myres < 140u;
  result = a2;
  this->_Mysize = a2;
  if ( v2 )
  {
    this->m_buffer[a2] = 0;
  }
  else
  {
    *(_WORD *)(*(_DWORD *)&this->m_buffer[0] + 2 * a2) = 0;
  }
  return result;
}

//----- (004064E0) --------------------------------------------------------
void *__stdcall sub_4064E0(int a1, int a2)
{
  return Allocator::allocate(&g_mmu, 2 * a1, 0, &name);
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (00406500) --------------------------------------------------------
char __thiscall sub_406500(int this, char a2)
{
  int v2; // eax@1
  int v3; // esi@1

  LOBYTE(v2) = a2;
  v3 = this;
  if ( a2 )
  {
    if ( *(_DWORD *)(this + 288) >= 0x8Cu )
    {
      v2 = *(_DWORD *)(this + 4);
      if ( v2 )
      {
        LOBYTE(v2) = MMU::deallocate(&g_mmu, *(void **)(this + 4));
      }
    }
  }
  *(_DWORD *)(v3 + 288) = 139;
  *(_DWORD *)(v3 + 284) = 0;
  *(_WORD *)(v3 + 4) = 0;
  return v2;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (00406550) --------------------------------------------------------
_WORD *__thiscall std::string::_Copy(void *this, int a2, int a3)
{
  unsigned int v3; // esi@1
  void *v4; // ebx@1
  int v5; // edx@3
  const void *v6; // esi@5
  _WORD *result; // eax@11
  int v8; // [sp+0h] [bp-24h]@1
  void *v9; // [sp+Ch] [bp-18h]@1
  int v10; // [sp+10h] [bp-14h]@1
  int *v11; // [sp+14h] [bp-10h]@1
  int v12; // [sp+20h] [bp-4h]@3
  void *v13; // [sp+2Ch] [bp+8h]@3

  v3 = a2 | 7;
  v4 = this;
  v11 = &v8;
  v9 = this;
  v10 = a2 | 7;
  if ( (a2 | 7u) > 0x7FFFFFFE )
  {
    v10 = a2;
    v3 = a2;
  }
  v12 = 0;
  v13 = Allocator::allocate(&g_mmu, 2 * v3 + 2, 0, &name);
  v5 = a3;
  v12 = -1;
  if ( a3 )
  {
    if ( *((_DWORD *)v4 + 72) < 140u )
    {
      v6 = (char *)v4 + 4;
    }
    else
    {
      v6 = (const void *)*((_DWORD *)v4 + 1);
    }
    qmemcpy(v13, v6, 2 * a3);
    v3 = v10;
  }
  if ( *((_DWORD *)v4 + 72) >= 140u && *((_DWORD *)v4 + 1) )
  {
    MMU::deallocate(&g_mmu, *((void **)v4 + 1));
    v5 = a3;
  }
  result = (char *)v4 + 4;
  *result = 0;
  *(_DWORD *)result = v13;
  *((_DWORD *)v4 + 72) = v3;
  *((_DWORD *)v4 + 71) = v5;
  if ( v3 >= 0x8C )
  {
    result = v13;
  }
  result[v5] = 0;
  return result;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (0040666E) --------------------------------------------------------
void __usercall __noreturn sub_40666E(int a1@<ebp>)
{
  sub_406500(*(_DWORD *)(a1 - 24), 1);
  _CxxThrowException(0, 0);
}
// 413348: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (00406690) --------------------------------------------------------
int __thiscall std::string::_Grow(std::wstring *this, unsigned int _Newsize, char _Trim)
{
  std::wstring *this_; // esi@1
  unsigned int _Myres; // eax@3
  int result; // eax@5

  this_ = this;
  if ( _Newsize > 0x7FFFFFFE )
  {
    String_base::_Xlen__();
  }
  _Myres = this->_Myres;
  if ( _Myres >= _Newsize )
  {
    if ( _Trim && _Newsize < 140 )              // _BUF_SIZE
    {                                           // _Tidy
      if ( _Myres >= 140 && *(_DWORD *)&this->m_buffer[0] )
      {
        MMU::deallocate(&g_mmu, *(void **)&this->m_buffer[0]);
      }
      this_->_Myres = 139;
      this_->_Mysize = 0;
      this_->m_buffer[0] = 0;
      result = _Newsize > 0;
    }
    else
    {
      if ( !_Newsize )
      {
        this->_Mysize = 0;
        if ( _Myres >= 140 )
        {
          **(_WORD **)&this->m_buffer[0] = 0;
          return 0;
        }
        this->m_buffer[0] = 0;
      }
      result = _Newsize > 0;
    }
  }
  else if ( _Trim )
  {
    std::string::_Copy(this, _Newsize, 0);
    result = _Newsize > 0;
  }
  else
  {
    std::string::_Copy(this, _Newsize, this->_Mysize);
    result = _Newsize > 0;
  }
  return result;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (00406780) --------------------------------------------------------
LONG __thiscall MMU::Allocator::destroy(std::wstring *this)
{
  std::wstring *v1; // esi@1
  LONG result; // eax@2

  v1 = this;
  if ( this->_Myres >= 140u )
  {
    result = *(_DWORD *)&this->m_buffer[0];
    if ( result )
    {
      result = MMU::deallocate(&g_mmu, *(void **)&this->m_buffer[0]);
    }
  }
  v1->_Myres = 139;
  v1->_Mysize = 0;
  v1->m_buffer[0] = 0;
  return result;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (004067C0) --------------------------------------------------------
std::wstring *__thiscall std::string::assign_char(std::wstring *this, unsigned int _Count, wchar_t _Ch)
{
  int v3; // ebp@1
  std::wstring *this_; // esi@1
  unsigned int newSize; // ebx@4
  unsigned int _Myres; // eax@6
  bool empty; // zf@7
  int *v8; // edx@9
  int v9; // eax@10
  std::wstring *result; // eax@13
  void *v11; // edi@16
  int v12; // ebp@16
  wchar_t *v13; // edi@16
  unsigned int i; // ecx@16
  bool v15; // cf@19

  HIWORD(v3) = HIWORD(_Count);
  this_ = this;
  if ( -1 - this->_Mysize <= _Count )
  {
    String_base::_Xlen__();
  }
  if ( !_Count )
  {
    return this_;
  }
  newSize = _Count + this->_Mysize;
  if ( newSize > 0x7FFFFFFE )
  {
    String_base::_Xlen__();
  }
  _Myres = this->_Myres;
  if ( _Myres < newSize )
  {
    std::string::_Copy(this, newSize, this->_Mysize);
    empty = newSize == 0;
    goto LABEL_8;
  }
  empty = newSize == 0;
  if ( newSize )
  {
LABEL_8:
    if ( empty )
    {
      return this_;
    }
    v8 = (int *)this_->m_buffer;
    if ( this_->_Myres < 140u )
    {
      v9 = (int)this_->m_buffer;
    }
    else
    {
      v9 = *v8;
    }
    v11 = (void *)(v9 + 2 * this_->_Mysize);
    LOWORD(v3) = _Ch;
    v12 = v3 << 16;
    LOWORD(v12) = _Ch;
    memset32(v11, v12, _Count >> 1);
    v13 = (wchar_t *)((char *)v11 + 4 * (_Count >> 1));
    for ( i = _Count & 1; i; --i )
    {
      *v13 = _Ch;
      ++v13;
    }
    v15 = this_->_Myres < 140u;
    this_->_Mysize = newSize;
    if ( !v15 )
    {
      v8 = (int *)*v8;
    }
    *((_WORD *)v8 + newSize) = 0;
    return this_;
  }
  this->_Mysize = 0;
  if ( _Myres < 140 )
  {
    this->m_buffer[0] = 0;
    result = this;
  }
  else
  {
    **(_WORD **)&this->m_buffer[0] = 0;
    result = this;
  }
  return result;
}

//----- (004068B0) --------------------------------------------------------
int __thiscall std::string::erase(int this, unsigned int a2, unsigned int a3)
{
  int v3; // edi@1
  unsigned int v4; // ebx@3
  unsigned int v5; // eax@3
  unsigned int v6; // ecx@6
  int *v7; // ebp@6
  int v8; // edx@7
  int v9; // ecx@10
  unsigned int v10; // esi@12
  unsigned int v11; // eax@14
  bool v12; // zf@15
  bool v13; // cf@17
  int result; // eax@20

  v3 = this;
  if ( *(_DWORD *)(this + 284) < a2 )
  {
    std::_Xran();
  }
  v4 = a3;
  v5 = *(_DWORD *)(this + 284) - a2;
  if ( v5 < a3 )
  {
    v4 = *(_DWORD *)(this + 284) - a2;
  }
  if ( !v4 )
  {
    return v3;
  }
  v6 = *(_DWORD *)(this + 288);
  v7 = (int *)(v3 + 4);
  if ( v6 < 0x8C )
  {
    v8 = v3 + 4;
  }
  else
  {
    v8 = *v7;
  }
  if ( v6 < 0x8C )
  {
    v9 = v3 + 4;
  }
  else
  {
    v9 = *v7;
  }
  memcpy((void *)(v9 + 2 * a2), (const void *)(v8 + 2 * (a2 + v4)), 2 * (v5 - v4));
  v10 = *(_DWORD *)(v3 + 284) - v4;
  if ( v10 > 0x7FFFFFFE )
  {
    String_base::_Xlen__();
  }
  v11 = *(_DWORD *)(v3 + 288);
  if ( v11 < v10 )
  {
    std::string::_Copy((void *)v3, v10, *(_DWORD *)(v3 + 284));
    v12 = v10 == 0;
    goto LABEL_16;
  }
  v12 = *(_DWORD *)(v3 + 284) == v4;
  if ( *(_DWORD *)(v3 + 284) != v4 )
  {
LABEL_16:
    if ( v12 )
    {
      return v3;
    }
    v13 = *(_DWORD *)(v3 + 288) < 0x8Cu;
    *(_DWORD *)(v3 + 284) = v10;
    if ( !v13 )
    {
      v7 = (int *)*v7;
    }
    *((_WORD *)v7 + v10) = 0;
    return v3;
  }
  *(_DWORD *)(v3 + 284) = 0;
  if ( v11 >= 0x8C )
  {
    v7 = (int *)*v7;
  }
  result = v3;
  *(_WORD *)v7 = 0;
  return result;
}

//----- (004069A0) --------------------------------------------------------
std::wstring *__thiscall std::string::assign(std::wstring *this, std::wstring *_Right, unsigned int _Roff, unsigned int _Count)
{
  std::wstring *this_; // ebx@1
  unsigned int _Num; // ebp@3
  char *v7; // edx@9
  char *v8; // edi@12
  int v9; // eax@14
  bool v10; // cf@14

  this_ = this;
  if ( _Right->_Mysize < _Roff )
  {
    std::_Xran();
  }
  _Num = _Right->_Mysize - _Roff;
  if ( _Count < _Num )
  {
    _Num = _Count;
  }
  if ( this == _Right )
  {
    std::string::erase((int)this, _Roff + _Num, 0xFFFFFFFF);
    std::string::erase((int)this_, 0, _Roff);
    return this_;
  }
  if ( !(unsigned __int8)std::string::_Grow(this, _Num, 1) )
  {
    return this_;
  }
  if ( _Right->_Myres < 140u )
  {
    v7 = (char *)_Right->m_buffer;
  }
  else
  {
    v7 = *(char **)&_Right->m_buffer[0];
  }
  if ( this_->_Myres < 140u )
  {
    v8 = (char *)this_->m_buffer;
  }
  else
  {
    v8 = *(char **)&this_->m_buffer[0];
  }
  v9 = _Num;
  qmemcpy(v8, &v7[2 * _Roff], 2 * _Num);
  v10 = this_->_Myres < 140u;
  this_->_Mysize = _Num;
  if ( !v10 )
  {
    *(_WORD *)(v9 * 2 + *(_DWORD *)&this_->m_buffer[0]) = 0;
    return this_;
  }
  this_->m_buffer[v9] = 0;
  return this_;
}

//----- (00406A70) --------------------------------------------------------
int __thiscall std::string::assign_c_str(std::wstring *this, const wchar_t *msg, int len)
{
  std::wstring *this_; // ebx@1
  unsigned int _Myres; // ecx@1
  wchar_t *buffIt; // ebp@1
  wchar_t *v6; // eax@2
  wchar_t *buffer; // eax@6
  int result; // eax@11
  wchar_t *destination; // edx@14

  this_ = this;
  _Myres = this->_Myres;
  buffIt = this_->m_buffer;
  if ( _Myres < 140 )
  {
    v6 = this_->m_buffer;
  }
  else
  {
    v6 = *(wchar_t **)buffIt;
  }
  if ( v6 > msg || (_Myres < 140 ? (buffer = this_->m_buffer) : (buffer = *(wchar_t **)buffIt), msg >= &buffer[this_->_Mysize]) )
  {
    if ( (unsigned __int8)std::string::_Grow(this_, len, true) )
    {
      if ( this_->_Myres < 140u )
      {
        destination = this_->m_buffer;
      }
      else
      {
        destination = *(wchar_t **)buffIt;
      }
      qmemcpy(destination, msg, 2 * len);
      this_->_Mysize = len;
      if ( this_->_Myres >= 140u )
      {
        buffIt = *(wchar_t **)buffIt;
      }
      buffIt[len] = 0;
    }
    result = (int)this_;
  }
  else
  {
    if ( _Myres >= 140 )
    {
      buffIt = *(wchar_t **)buffIt;
    }
    result = (int)std::string::assign(this_, this_, msg - buffIt, len);
  }
  return result;
}

//----- (00406B40) --------------------------------------------------------
__int32 __cdecl Utils::GetIntFromString(wchar_t *strWithNum)
{
  int len; // eax@1
  signed int strWithNumLen; // ebp@1
  __int32 result; // eax@5
  signed int i; // esi@6
  wchar_t v5; // cx@6
  signed int i2; // eax@7
  const wchar_t *c_str; // eax@10
  __int32 number; // esi@12
  char guard; // [sp+10h] [bp-134h]@1
  std::wstring str; // [sp+14h] [bp-130h]@1
  int unused; // [sp+140h] [bp-4h]@1

  ::guard(&guard, L"int GetIntFromString(WCHAR * sNum)");
  unused = 0;
  str._Myres = 139;                             // ctor
  str._Mysize = 0;
  str.m_buffer[0] = 0;                          // /ctor
  len = wcslen(aClass);
  std::string::assign_c_str(&str, aClass, len);
  LOBYTE(unused) = 1;
  strWithNumLen = wcslen(strWithNum);
  if ( strWithNumLen >= 1 )
  {
    i = 0;
    if ( Utils::IsNumber(*strWithNum) )
    {
      do
      {
        i2 = i++;
        if ( i2 > strWithNumLen )
        {
          break;
        }
        if ( i >= 10 )
        {
          break;
        }
        std::string::assign_char(&str, 1u, v5);
      }
      while ( Utils::IsNumber(strWithNum[i]) );
    }
    c_str = *(const wchar_t **)&str.m_buffer[0];
    if ( str._Myres < 140u )
    {
      c_str = str.m_buffer;
    }
    number = j___wtol(c_str);
    LOBYTE(unused) = 0;
    if ( str._Myres >= 140u && *(_DWORD *)&str.m_buffer[0] )// destructor
    {
      MMU::deallocate(&g_mmu, *(void **)&str.m_buffer[0]);
    }
    str._Myres = 139;
    str._Mysize = 0;
    str.m_buffer[0] = 0;                        // /destructor
    unused = -1;
    unguard();
    result = number;
  }
  else
  {
    LOBYTE(unused) = 0;
    if ( str._Myres >= 140u )
    {
      if ( *(_DWORD *)&str.m_buffer[0] )
      {
        MMU::deallocate(&g_mmu, *(void **)&str.m_buffer[0]);
      }
    }
    str._Myres = 139;
    str._Mysize = 0;
    str.m_buffer[0] = 0;
    unused = -1;
    unguard();
    result = 0;
  }
  return result;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (00406CF0) --------------------------------------------------------
void __thiscall CBCPLogFile::DestructorCBCPLogFile(CBCPLogFile *this)
{
  CBCPLogFile *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  guard(&this_, L"CBCPLogFile::~CBCPLogFile()");
  DeleteCriticalSection(&CBCPLogFile::s_lock);
  unguard();
}

//----- (00406D20) --------------------------------------------------------
char __thiscall CBCPLogFile::Init(CBCPLogFile *this, int slot)
{
  CBCPLogFile *this_; // esi@1
  char v4; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v4, L"bool CBCPLogFile::Init(int nSlot)");
  this_->m_slot = slot;
  unguard();
  return 1;
}

//----- (00406D50) --------------------------------------------------------
int __stdcall CBCPLogFile::BulkInsert(const wchar_t *logCategory, const wchar_t *filePath, const wchar_t *logTableName)
{
  int executionResult2; // ST1C_4@3
  DWORD endTime; // eax@3
  int executionResult3; // esi@3
  int executionResult; // [sp+10h] [bp-830h]@1
  DWORD startTime; // [sp+14h] [bp-82Ch]@1
  char v9; // [sp+18h] [bp-828h]@1
  SQLINTEGER length; // [sp+1Ch] [bp-824h]@1
  DBConn dbConn; // [sp+20h] [bp-820h]@1
  wchar_t sqlQuery[512]; // [sp+430h] [bp-410h]@1
  int unused; // [sp+83Ch] [bp-4h]@1

  guard(&v9, L"int CBCPLogFile::BulkInsert(WCHAR *szInOut, WCHAR *szFilePath, WCHAR *szDB)");
  unused = 0;
  executionResult = 0;
  startTime = GetTickCount();
  DBConn::DBConn(&dbConn);
  sqlQuery[0] = 0;
  memset(&sqlQuery[1], 0, 1020u);
  sqlQuery[511] = 0;
  LOBYTE(unused) = 1;
  wsprintfW(sqlQuery, aExec_lin_BulkInsert, logTableName, filePath);
  CLog::Add(&g_winlog, 0, L"SQL(%s)", sqlQuery);
  length = -1;
  DBConn::BindNullable(&dbConn, &executionResult, &length);
  if ( DBConn::Execute(&dbConn, aExec_lin_BulkInsert, logTableName, filePath) )
  {
    DBConn::Fetch(&dbConn);
  }
  executionResult2 = executionResult;
  endTime = GetTickCount();
  CLog::Add(&g_winlog, 0, L"BULK INSERT (%d) seconds, nRet(%d)", (endTime - startTime) / 1000, executionResult2);
  executionResult3 = executionResult;
  LOBYTE(unused) = 0;
  DBConn::DestructorDBConn(&dbConn);
  unused = -1;
  unguard();
  return executionResult3;
}

//----- (00406EB0) --------------------------------------------------------
char CBCPLogFile::CheckFmtFile()
{
  HANDLE logDataFile; // eax@1
  HANDLE newLogDataFile; // ebx@2
  char *v2; // edi@3
  char v3; // al@4
  char *v4; // edi@5
  char v5; // al@6
  char *v6; // edi@7
  char v7; // al@8
  char *v8; // edi@9
  char v9; // al@10
  char *v10; // edi@11
  char v11; // al@12
  char *v12; // edi@13
  char v13; // al@14
  char *v14; // edi@15
  char v15; // al@16
  char *v16; // edi@17
  char v17; // al@18
  char *v18; // edi@19
  char v19; // al@20
  char *v20; // edi@21
  char v21; // al@22
  char *v22; // edi@23
  char v23; // al@24
  char *v24; // edi@25
  char v25; // al@26
  char *v26; // edi@27
  char v27; // al@28
  char *v28; // edi@29
  char v29; // al@30
  char *v30; // edi@31
  char v31; // al@32
  char *v32; // edi@33
  char v33; // al@34
  char *v34; // edi@35
  char v35; // al@36
  char *v36; // edi@37
  char v37; // al@38
  char *v38; // edi@39
  char v39; // al@40
  char *v40; // edi@41
  char v41; // al@42
  char *v42; // edi@43
  char v43; // al@44
  char *v44; // edi@45
  char v45; // al@46
  char *v46; // edi@47
  char v47; // al@48
  char *v48; // edi@49
  char v49; // al@50
  char *v50; // edi@51
  char v51; // al@52
  char *v52; // edi@53
  char v53; // al@54
  char *v54; // edi@55
  char v55; // al@56
  char *v56; // edi@57
  char v57; // al@58
  HANDLE chatDataFile; // eax@61
  HANDLE newChatDataFile; // ebx@62
  char *v60; // edi@63
  char v61; // al@64
  char *v62; // edi@65
  char v63; // al@66
  char *v64; // edi@67
  char v65; // al@68
  char *v66; // edi@69
  char v67; // al@70
  char *v68; // edi@71
  char v69; // al@72
  char *v70; // edi@73
  char v71; // al@74
  char *v72; // edi@75
  char v73; // al@76
  char *v74; // edi@77
  char v75; // al@78
  char *v76; // edi@79
  char v77; // al@80
  char *v78; // edi@81
  char v79; // al@82
  char *v80; // edi@83
  char v81; // al@84
  char guard; // [sp+10h] [bp-1258h]@1
  int bytesWritten; // [sp+14h] [bp-1254h]@3
  char buffer[4096]; // [sp+18h] [bp-1250h]@3
  struct _WIN32_FIND_DATAW findFileData; // [sp+1018h] [bp-250h]@1

  ::guard(&guard, L"CBCPLogFile::CheckFmtFile()");
  EnterCriticalSection(&CBCPLogFile::s_lock);
  logDataFile = FindFirstFileW(L"log_data.fmt", &findFileData);
  if ( logDataFile == (HANDLE)INVALID_HANDLE_VALUE )
  {
    newLogDataFile = CreateFileW(L"log_data.fmt", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
    if ( newLogDataFile != (HANDLE)INVALID_HANDLE_VALUE )
    {
      strcpy(buffer, "8.0\r\n");
      v2 = (char *)&bytesWritten + 3;
      do
      {
        v3 = (v2++)[1];
      }
      while ( v3 );
      *(_DWORD *)v2 = 0xA0D3732;
      v2[4] = 0;
      v4 = (char *)&bytesWritten + 3;
      do
      {
        v5 = (v4++)[1];
      }
      while ( v5 );
      qmemcpy(v4, "1       SQLCHAR\t      0       50      \",\"                       1     act_time           \"\"\r\n", 0x5Eu);
      v6 = (char *)&bytesWritten + 3;
      do
      {
        v7 = (v6++)[1];
      }
      while ( v7 );
      qmemcpy(v6, "2       SQLCHAR       0       50      \",\"                       2     log_id             \"\"\r\n", 0x5Eu);
      v8 = (char *)&bytesWritten + 3;
      do
      {
        v9 = (v8++)[1];
      }
      while ( v9 );
      qmemcpy(v8, "3       SQLCHAR       0       50      \",\"                       3     actor              \"\"\r\n", 0x5Eu);
      v10 = (char *)&bytesWritten + 3;
      do
      {
        v11 = (v10++)[1];
      }
      while ( v11 );
      qmemcpy(v10, "4       SQLCHAR       0       50      \",\"                       4     actor_account      \"\"\r\n", 0x5Eu);
      v12 = (char *)&bytesWritten + 3;
      do
      {
        v13 = (v12++)[1];
      }
      while ( v13 );
      qmemcpy(v12, "5       SQLCHAR       0       50      \",\"                       5     target             \"\"\r\n", 0x5Eu);
      v14 = (char *)&bytesWritten + 3;
      do
      {
        v15 = (v14++)[1];
      }
      while ( v15 );
      qmemcpy(v14, "6       SQLCHAR       0       50      \",\"                       6     target_account     \"\"\r\n", 0x5Eu);
      v16 = (char *)&bytesWritten + 3;
      do
      {
        v17 = (v16++)[1];
      }
      while ( v17 );
      qmemcpy(v16, "7       SQLCHAR       0       50       \",\"                       7     location_x         \"\"\r\n", 0x5Fu);
      v18 = (char *)&bytesWritten + 3;
      do
      {
        v19 = (v18++)[1];
      }
      while ( v19 );
      qmemcpy(v18, "8       SQLCHAR       0       50       \",\"                       8     location_y         \"\"\r\n", 0x5Fu);
      v20 = (char *)&bytesWritten + 3;
      do
      {
        v21 = (v20++)[1];
      }
      while ( v21 );
      qmemcpy(v20, "9       SQLCHAR       0       50       \",\"                       9     location_z         \"\"\r\n", 0x5Fu);
      v22 = (char *)&bytesWritten + 3;
      do
      {
        v23 = (v22++)[1];
      }
      while ( v23 );
      qmemcpy(v22, "10      SQLCHAR       0       50      \",\"                       10    etc_str1           Korean_Wansung_CI_AS\r\n", 0x70u);
      v24 = (char *)&bytesWritten + 3;
      do
      {
        v25 = (v24++)[1];
      }
      while ( v25 );
      qmemcpy(v24, "11      SQLCHAR       0       50      \",\"                       11    etc_str2           Korean_Wansung_CI_AS\r\n", 0x70u);
      v26 = (char *)&bytesWritten + 3;
      do
      {
        v27 = (v26++)[1];
      }
      while ( v27 );
      qmemcpy(v26, "12      SQLCHAR       0       50      \",\"                       12    etc_str3           Korean_Wansung_CI_AS\r\n", 0x70u);
      v28 = (char *)&bytesWritten + 3;
      do
      {
        v29 = (v28++)[1];
      }
      while ( v29 );
      qmemcpy(v28, "13      SQLCHAR       0       50       \",\"                       13    etc_num1           \"\"\r\n", 0x5Fu);
      v30 = (char *)&bytesWritten + 3;
      do
      {
        v31 = (v30++)[1];
      }
      while ( v31 );
      qmemcpy(v30, "14      SQLCHAR       0       50       \",\"                       14    etc_num2           \"\"\r\n", 0x5Fu);
      v32 = (char *)&bytesWritten + 3;
      do
      {
        v33 = (v32++)[1];
      }
      while ( v33 );
      qmemcpy(v32, "15      SQLCHAR       0       50       \",\"                       15    etc_num3           \"\"\r\n", 0x5Fu);
      v34 = (char *)&bytesWritten + 3;
      do
      {
        v35 = (v34++)[1];
      }
      while ( v35 );
      qmemcpy(v34, "16      SQLCHAR       0       50       \",\"                       16    etc_num4           \"\"\r\n", 0x5Fu);
      v36 = (char *)&bytesWritten + 3;
      do
      {
        v37 = (v36++)[1];
      }
      while ( v37 );
      qmemcpy(v36, "17      SQLCHAR       0       50       \",\"                       17    etc_num5           \"\"\r\n", 0x5Fu);
      v38 = (char *)&bytesWritten + 3;
      do
      {
        v39 = (v38++)[1];
      }
      while ( v39 );
      qmemcpy(v38, "18      SQLCHAR       0       50       \",\"                       18    etc_num6           \"\"\r\n", 0x5Fu);
      v40 = (char *)&bytesWritten + 3;
      do
      {
        v41 = (v40++)[1];
      }
      while ( v41 );
      qmemcpy(v40, "19      SQLCHAR       0       50       \",\"                       19    etc_num7           \"\"\r\n", 0x5Fu);
      v42 = (char *)&bytesWritten + 3;
      do
      {
        v43 = (v42++)[1];
      }
      while ( v43 );
      qmemcpy(v42, "20      SQLCHAR       0       50       \",\"                       20    etc_num8           \"\"\r\n", 0x5Fu);
      v44 = (char *)&bytesWritten + 3;
      do
      {
        v45 = (v44++)[1];
      }
      while ( v45 );
      qmemcpy(v44, "21      SQLCHAR       0       50       \",\"                       21    etc_num9           \"\"\r\n", 0x5Fu);
      v46 = (char *)&bytesWritten + 3;
      do
      {
        v47 = (v46++)[1];
      }
      while ( v47 );
      qmemcpy(v46, "22      SQLCHAR       0       50       \",\"                    22    etc_num10          \"\"\r\n", 0x5Cu);
      v48 = (char *)&bytesWritten + 3;
      do
      {
        v49 = (v48++)[1];
      }
      while ( v49 );
      qmemcpy(v48, "23       SQLCHAR       0       50      \",\"                       23     STR_actor              Korean_Wansung_CI_AS\r\n", 0x76u);
      v50 = (char *)&bytesWritten + 3;
      do
      {
        v51 = (v50++)[1];
      }
      while ( v51 );
      qmemcpy(v50, "24       SQLCHAR       0       50      \",\"                       24     STR_actor_account      Korean_Wansung_CI_AS\r\n", 0x76u);
      v52 = (char *)&bytesWritten + 3;
      do
      {
        v53 = (v52++)[1];
      }
      while ( v53 );
      qmemcpy(v52, "25       SQLCHAR       0       50      \",\"                       25     STR_target             Korean_Wansung_CI_AS\r\n", 0x76u);
      v54 = (char *)&bytesWritten + 3;
      do
      {
        v55 = (v54++)[1];
      }
      while ( v55 );
      qmemcpy(v54, "26       SQLCHAR       0       50      \",\"                       26     STR_target_account     Korean_Wansung_CI_AS\r\n", 0x76u);
      v56 = (char *)&bytesWritten + 3;
      do
      {
        v57 = (v56++)[1];
      }
      while ( v57 );
      qmemcpy(v56, "27       SQLCHAR       0       50      \"\\r\\n\"                  27     item_id     \"\"\r\n", 0x57u);
      WriteFile(newLogDataFile, buffer, strlen(buffer), (LPDWORD)&bytesWritten, 0);
      FlushFileBuffers(newLogDataFile);
      CloseHandle(newLogDataFile);
    }
  }
  else
  {
    FindClose(logDataFile);
  }
  chatDataFile = FindFirstFileW(L"chat_data.fmt", &findFileData);
  if ( chatDataFile == (HANDLE)INVALID_HANDLE_VALUE )
  {
    newChatDataFile = CreateFileW(L"chat_data.fmt", GENERIC_WRITE, 1u, 0, 1u, FILE_ATTRIBUTE_NORMAL, 0);
    if ( newChatDataFile != (HANDLE)INVALID_HANDLE_VALUE )
    {
      strcpy(buffer, "8.0\r\n");
      v60 = (char *)&bytesWritten + 3;
      do
      {
        v61 = (v60++)[1];
      }
      while ( v61 );
      *(_DWORD *)v60 = 0xA0D3031;
      v60[4] = 0;
      v62 = (char *)&bytesWritten + 3;
      do
      {
        v63 = (v62++)[1];
      }
      while ( v63 );
      qmemcpy(v62, "1       SQLCHAR\t      0       50      \",\"                       1     act_time           \"\"\r\n", 0x5Eu);
      v64 = (char *)&bytesWritten + 3;
      do
      {
        v65 = (v64++)[1];
      }
      while ( v65 );
      qmemcpy(v64, "2       SQLCHAR       0       50      \",\"                       2     log_id             \"\"\r\n", 0x5Eu);
      v66 = (char *)&bytesWritten + 3;
      do
      {
        v67 = (v66++)[1];
      }
      while ( v67 );
      qmemcpy(v66, "3       SQLCHAR       0       50      \",\"                       3     actor              \"\"\r\n", 0x5Eu);
      v68 = (char *)&bytesWritten + 3;
      do
      {
        v69 = (v68++)[1];
      }
      while ( v69 );
      qmemcpy(v68, "4       SQLCHAR       0       50      \",\"                       4     target             \"\"\r\n", 0x5Eu);
      v70 = (char *)&bytesWritten + 3;
      do
      {
        v71 = (v70++)[1];
      }
      while ( v71 );
      qmemcpy(v70, "5       SQLCHAR       0       50       \",\"                       5     location_x         \"\"\r\n", 0x5Fu);
      v72 = (char *)&bytesWritten + 3;
      do
      {
        v73 = (v72++)[1];
      }
      while ( v73 );
      qmemcpy(v72, "6       SQLCHAR       0       50       \",\"                       6     location_y         \"\"\r\n", 0x5Fu);
      v74 = (char *)&bytesWritten + 3;
      do
      {
        v75 = (v74++)[1];
      }
      while ( v75 );
      qmemcpy(v74, "7       SQLCHAR       0       50       \",\"                       7     location_z         \"\"\r\n", 0x5Fu);
      v76 = (char *)&bytesWritten + 3;
      do
      {
        v77 = (v76++)[1];
      }
      while ( v77 );
      qmemcpy(v76, "8      SQLCHAR       0       50      \",\"                       8    say           Korean_Wansung_CI_AS\r\n", 0x69u);
      v78 = (char *)&bytesWritten + 3;
      do
      {
        v79 = (v78++)[1];
      }
      while ( v79 );
      qmemcpy(v78, "9       SQLCHAR       0       50      \",\"                       9     STR_actor              Korean_Wansung_CI_AS\r\n", 0x74u);
      v80 = (char *)&bytesWritten + 3;
      do
      {
        v81 = (v80++)[1];
      }
      while ( v81 );
      qmemcpy(v80, "10       SQLCHAR       0       50      \"\\r\\n\"                  10     STR_target             Korean_Wansung_CI_AS\r\n", 0x74u);
      WriteFile(newChatDataFile, buffer, strlen(buffer), (LPDWORD)&bytesWritten, 0);
      FlushFileBuffers(newChatDataFile);
      CloseHandle(newChatDataFile);
    }
  }
  else
  {
    FindClose(chatDataFile);
  }
  LeaveCriticalSection(&CBCPLogFile::s_lock);
  unguard();
  return 1;
}

//----- (00407500) --------------------------------------------------------
bool __stdcall CBCPLogFile::GetMaxFileNo(const wchar_t *file, wchar_t *clearFileName, int *max)
{
  __int32 newMax; // ebx@1
  wchar_t *fileNameTail; // eax@1
  unsigned __int16 fileIndex; // cx@3
  HANDLE fileHandle; // edi@8
  size_t increment; // esi@9
  wchar_t *foundFileNameChanger; // eax@9
  wchar_t fileIndex2; // cx@10
  char guard; // [sp+10h] [bp-668h]@1
  wchar_t fileIndexString[8]; // [sp+14h] [bp-664h]@9
  int i; // [sp+24h] [bp-654h]@9
  WCHAR fileName[256]; // [sp+28h] [bp-650h]@8
  struct _WIN32_FIND_DATAW findFileData; // [sp+228h] [bp-450h]@8
  wchar_t foundFileName[256]; // [sp+478h] [bp-200h]@9

  ::guard(&guard, L"bool CBCPLogFile::GetMaxFileNo(WCHAR* szFile, WCHAR* szFilePre, int& nMax)");
  newMax = 0;
  *max = 0;
  fileNameTail = wcsstr(file, L".log");         // find .log, and then find back (left) till meet file index
  if ( fileNameTail )
  {
    if ( *fileNameTail )
    {
      while ( 1 )
      {
        fileIndex = *(fileNameTail - 1);
        if ( fileIndex < '0' || fileIndex > '9' )//  TODO: doesn't work with numbers bigger then 9
        {
          break;
        }
        --fileNameTail;
        if ( !*fileNameTail )
        {
          goto LABEL_8;
        }
      }
      *fileNameTail = 0;                        // changes "file" variable as well - trims string till found number (exclusivly)
    }
LABEL_8:
    *fileNameTail = 0;
    wcscpy(clearFileName, file);
    wcscpy(fileName, clearFileName);
    wcscat(fileName, L"*.log");
    fileHandle = FindFirstFileW(fileName, &findFileData);
    if ( fileHandle != (HANDLE)INVALID_HANDLE_VALUE )
    {
      do
      {
        increment = 0;
        wcscpy(foundFileName, findFileData.cFileName);
        foundFileNameChanger = wcsstr(foundFileName, L".log");
        *(_DWORD *)fileIndexString = 0;
        *(_DWORD *)&fileIndexString[2] = 0;
        *(_DWORD *)&fileIndexString[4] = 0;
        *(_DWORD *)&fileIndexString[6] = 0;
        for ( i = 0; foundFileNameChanger; ++increment )//  TODO: doesn't work with numbers bigger then 9
        {
          fileIndex2 = *(foundFileNameChanger - 1);
          if ( fileIndex2 < '0' )
          {
            break;
          }
          if ( fileIndex2 > '9' )
          {
            break;
          }
          --foundFileNameChanger;
        }
        wcsncpy(fileIndexString, foundFileNameChanger, increment);
        if ( wcslen(fileIndexString) )
        {
          newMax = j___wtol(fileIndexString);
        }
        if ( newMax > *max )
        {
          *max = newMax;
        }
      }
      while ( FindNextFileW(fileHandle, &findFileData) );
      FindClose(fileHandle);
    }
  }
  else
  {
    wcscpy(clearFileName, file);
    *max = 0;
  }
  unguard();
  return true;
}

//----- (004076B0) --------------------------------------------------------
bool __stdcall CBCPLogFile::CheckLogTimeTable(int year, int month, int day, int world)
{
  bool result; // al@2
  char v5; // [sp+Ch] [bp-624h]@1
  wchar_t dateStr[256]; // [sp+10h] [bp-620h]@3
  DBConn sql; // [sp+210h] [bp-420h]@7
  int unused; // [sp+62Ch] [bp-4h]@1

  guard(&v5, L"bool CBCPLogFile::CheckLogTimeTable(int nYear, int nMonth, int nDay, int nWorld)");
  unused = 0;
  if ( world >= 0 )
  {
    memset(dateStr, 0, sizeof(dateStr));
    if ( year && month )
    {
      if ( day )
      {
        wsprintfW(dateStr, L"L%04d_%02d_%02d_", year, month, day);
      }
    }
    DBConn::DBConn(&sql);
    LOBYTE(unused) = 1;
    DBConn::Execute(&sql, aExecuteLin_checklogtim2[0], dateStr, world);
    CLog::Add(&g_winlog, 0, L"bcplogfile::checklogtimetable %s, %d", dateStr, world);
    LOBYTE(unused) = 0;
    DBConn::DestructorDBConn(&sql);
    unused = -1;
    unguard();
    result = true;
  }
  else
  {
    CLog::Add(&g_winlog, LOG_ERROR, L"CBCPLogFile CheckLogTimeTable(%d) world is below 0", world);
    unused = -1;
    unguard();
    result = false;
  }
  return result;
}

//----- (00407800) --------------------------------------------------------
CBCPLogFile *__thiscall CBCPLogFile::CBCPLogFile(CBCPLogFile *this)
{
  CBCPLogFile *this_; // esi@1
  char v3; // [sp+8h] [bp-10h]@1
  int unused; // [sp+14h] [bp-4h]@1

  this_ = this;
  guard(&v3, L"CBCPLogFile::CBCPLogFile()");
  unused = 0;
  InitializeCriticalSection(&CBCPLogFile::s_lock);
  memset(this_->m_dirPath, 0, 508u);
  this_->m_dirPath[254] = 0;
  CBCPLogFile::CheckFmtFile();
  this_->m_unused = 0;
  this_->m_slot = 0;
  unused = -1;
  unguard();
  return this_;
}

//----- (00407890) --------------------------------------------------------
bool __stdcall CBCPLogFile::GetMoveFileName(const wchar_t *dirName, const wchar_t *originFileName, wchar_t *newFileName)
{
  HANDLE fileHandle; // eax@1
  int max; // [sp+4h] [bp-678h]@1
  char guard; // [sp+8h] [bp-674h]@1
  WCHAR newIndex[10]; // [sp+Ch] [bp-670h]@2
  wchar_t fileName[256]; // [sp+20h] [bp-65Ch]@1
  wchar_t filePrevious[256]; // [sp+220h] [bp-45Ch]@2
  WIN32_FIND_DATAW findFileData; // [sp+420h] [bp-25Ch]@1
  int unused; // [sp+678h] [bp-4h]@1

  ::guard(&guard, L"WCHAR* CBCPLogFile::GetMoveFileName(WCHAR* szFolder, WCHAR* szFile, WCHAR* szMoveFile)");
  unused = 0;
  max = 0;
  wcscpy(fileName, dirName);
  wcscat(fileName, L"insert\\");
  wcscat(fileName, originFileName);
  fileHandle = FindFirstFileW(fileName, &findFileData);
  if ( fileHandle == (HANDLE)INVALID_HANDLE_VALUE )
  {
    wcscpy(newFileName, fileName);
  }
  else
  {
    FindClose(fileHandle);
    CBCPLogFile::GetMaxFileNo(fileName, filePrevious, &max);
    wsprintfW(newIndex, L"%d", max + 1);
    wcscpy(newFileName, filePrevious);
    wcscat(newFileName, newIndex);
    wcscat(newFileName, L".log");
  }
  unused = -1;
  unguard();
  return true;
}

//----- (004079C0) --------------------------------------------------------
char __thiscall CBCPLogFile::InsertLogFiles(CBCPLogFile *this, wchar_t *dirPath)
{
  struct tm *now_1; // esi@1
  int v3; // ST38_4@1
  int v4; // ST34_4@1
  int v5; // ST30_4@1
  int v6; // ST2C_4@1
  int v7; // ST28_4@1
  int v8; // ST24_4@1
  DWORD threadId_1; // eax@1
  void (__stdcall *_LeaveCriticalSection)(LPCRITICAL_SECTION); // esi@1
  HANDLE fileHandle; // edi@1
  char v12; // bl@2
  HANDLE canBeRead; // eax@9
  DWORD threadId_2; // eax@13
  wchar_t *categoryStr; // eax@13
  wchar_t *v17; // edi@13
  wchar_t *extension; // eax@14
  void (__stdcall *enterCliticalSection)(LPCRITICAL_SECTION); // edi@17
  int i; // eax@17
  CBCPLogFile *this2; // esi@20
  DWORD threadId34; // eax@24
  HANDLE fileHandle3; // eax@24
  DWORD startTime; // edi@36
  DWORD threadId2_1; // eax@36
  int executionResult; // esi@36
  DWORD timePassed; // ST38_4@36
  DWORD threadId3_1; // eax@36
  DWORD threadId; // eax@37
  DWORD endTime; // eax@37
  DWORD threadId2; // ST30_4@37
  wchar_t *timeStr; // ST2C_4@37
  DWORD threadId3; // eax@37
  BOOL notFound; // eax@24
  char finished; // [sp+Dh] [bp-F5Bh]@1
  char categoryFound; // [sp+Eh] [bp-F5Ah]@0
  CBCPLogFile *this_; // [sp+10h] [bp-F58h]@1
  int world; // [sp+14h] [bp-F54h]@13
  int year; // [sp+18h] [bp-F50h]@13
  int day; // [sp+1Ch] [bp-F4Ch]@13
  int month; // [sp+20h] [bp-F48h]@13
  HANDLE fileHandle2; // [sp+24h] [bp-F44h]@1
  int hour; // [sp+28h] [bp-F40h]@13
  time_t now; // [sp+2Ch] [bp-F3Ch]@37
  time_t timeNow; // [sp+30h] [bp-F38h]@1
  char guard; // [sp+34h] [bp-F34h]@1
  wchar_t logCategory[20]; // [sp+38h] [bp-F30h]@13
  wchar_t v48[20]; // [sp+60h] [bp-F08h]@13
  wchar_t logTableName[64]; // [sp+88h] [bp-EE0h]@31
  struct _WIN32_FIND_DATAW findFileData; // [sp+108h] [bp-E60h]@1
  wchar_t logFilePath[256]; // [sp+358h] [bp-C10h]@5
  wchar_t suffix[256]; // [sp+558h] [bp-A10h]@13
  wchar_t newFileName[256]; // [sp+758h] [bp-810h]@24
  wchar_t fileToMove[256]; // [sp+958h] [bp-610h]@13
  wchar_t fileName[256]; // [sp+B58h] [bp-410h]@1
  wchar_t pathName[258]; // [sp+D58h] [bp-210h]@1
  int v57; // [sp+F64h] [bp-4h]@1

  this_ = this;
  ::guard(&guard, L"CBCPLogFile::InsertLogFiles(WCHAR *szDirPath)");
  v57 = 0;
  timeNow = time(0);
  now_1 = localtime(&timeNow);
  finished = 0;
  EnterCriticalSection(&CBCPLogFile::s_lock);
  v3 = now_1->tm_sec;
  v4 = now_1->tm_min;
  v5 = now_1->tm_hour;
  v6 = now_1->tm_mday;
  v7 = now_1->tm_mon + 1;
  v8 = now_1->tm_year + 1900;
  threadId_1 = GetCurrentThreadId();
  CLog::Add(&g_winlog, 0, L"[%d]Insert Log File begins at %04d/%02d/%02d %02d:%02d:%02d", threadId_1, v8, v7, v6, v5, v4, v3);
  wsprintfW(pathName, L"%s\\insert", dirPath);
  CreateDirectoryW(pathName, 0);
  wcscpy(this_->m_dirPath, dirPath);
  wcscpy(fileName, this_->m_dirPath);
  wcscat(fileName, L"*.log");
  _LeaveCriticalSection = LeaveCriticalSection;
  fileHandle = FindFirstFileW(fileName, &findFileData);
  fileHandle2 = fileHandle;
  LeaveCriticalSection(&CBCPLogFile::s_lock);
  if ( fileHandle != (HANDLE)INVALID_HANDLE_VALUE )
  {
    while ( 1 )
    {
      EnterCriticalSection(&CBCPLogFile::s_lock);
      wcscpy(logFilePath, this_->m_dirPath);
      wcscat(logFilePath, findFileData.cFileName);
      if ( !wcsstr(findFileData.cFileName, L".log") )
      {
        if ( !FindNextFileW(fileHandle, &findFileData) )
        {
          finished = 1;
        }
        _LeaveCriticalSection(&CBCPLogFile::s_lock);
        goto LABEL_42;
      }
      canBeRead = CreateFileW(logFilePath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
      if ( canBeRead == (HANDLE)INVALID_HANDLE_VALUE )
      {
        if ( !FindNextFileW(fileHandle, &findFileData) )
        {
          finished = 1;
        }
        _LeaveCriticalSection(&CBCPLogFile::s_lock);
        goto LABEL_42;
      }
      CloseHandle(canBeRead);
      _LeaveCriticalSection(&CBCPLogFile::s_lock);
      wcscpy(fileToMove, findFileData.cFileName);
      threadId_2 = GetCurrentThreadId();
      CLog::Add(&g_winlog, 0, L"[%d]found log file(%s)", threadId_2, logFilePath);
      memset(v48, 0, sizeof(v48));
      memset(logCategory, 0, sizeof(logCategory));
      memset(suffix, 0, 508u);
      suffix[254] = 0;
      swscanf(findFileData.cFileName, L"%d-%d-%d-%d-%d-%s", &year, &month, &day, &hour, &world, suffix);
      categoryStr = wcschr(suffix, '-');
      v17 = categoryStr;
      if ( categoryStr && (*categoryStr = 0, wcscpy(v48, suffix), wcscpy(suffix, v17 + 1), (extension = wcschr(suffix, '.')) != 0) )
      {
        *extension = 0;
        wcscpy(logCategory, suffix);
        categoryFound = true;
      }
      else if ( !categoryFound )
      {
        enterCliticalSection = EnterCriticalSection;
        goto LABEL_28;
      }
      enterCliticalSection = EnterCriticalSection;
      EnterCriticalSection(&CBCPLogFile::s_lock);
      i = 0;
      if ( Config::s_BCPThreadCount <= 0 )
      {
LABEL_20:
        this2 = this_;
        CBCPLogFile::s_worldIds[this_->m_slot] = world;
      }
      else
      {
        while ( world != CBCPLogFile::s_worldIds[i] )
        {
          if ( ++i >= Config::s_BCPThreadCount )
          {
            goto LABEL_20;
          }
        }
        this2 = this_;
        categoryFound = 0;
      }
      LeaveCriticalSection(&CBCPLogFile::s_lock);
      if ( categoryFound )
      {
        if ( findFileData.nFileSizeHigh || findFileData.nFileSizeLow )
        {
          memset(logTableName, 0, sizeof(logTableName));
          if ( !wcsncmp(logCategory, L"chat", 4u) )
          {
            wsprintfW(logTableName, L"lin2log.dbo.L%04d_%02d_%02d_log_chat_%d", year, month, day, world);
          }
          else if ( hour >= 12 )
          {
            wsprintfW(logTableName, L"lin2log.dbo.L%04d_%02d_%02d_log_data2_%d", year, month, day, world);
          }
          else
          {
            wsprintfW(logTableName, L"lin2log.dbo.L%04d_%02d_%02d_log_data_%d", year, month, day, world);
          }
          CBCPLogFile::CheckLogTimeTable(year, month, day, world);
          startTime = GetTickCount();
          threadId2_1 = GetCurrentThreadId();
          CLog::Add_Ansi(&g_winlog, 0, "[%d]begin bcp", threadId2_1);
          executionResult = CBCPLogFile::BulkInsert(logCategory, logFilePath, logTableName);
          timePassed = (GetTickCount() - startTime) / 1000;
          threadId3_1 = GetCurrentThreadId();
          CLog::Add_Ansi(&g_winlog, 0, "[%d]end bcp. bcp time(%d)", threadId3_1, timePassed);
          if ( executionResult > -1 )
          {
            CBCPLogFile::GetMoveFileName(this_->m_dirPath, fileToMove, newFileName);
            MoveFileW(logFilePath, newFileName);
            threadId = GetCurrentThreadId();
            CLog::Add(&g_winlog, 0, L"[%d]move file %s -> %s", threadId, logFilePath, newFileName);
            EnterCriticalSection(&CBCPLogFile::s_lock);
            CBCPLogFile::s_worldIds[this_->m_slot] = 0;
            LeaveCriticalSection(&CBCPLogFile::s_lock);
            endTime = GetTickCount();
            CSQLQueue::PushSQL(&g_sqlPollingQueue, aExecuteLin_setinserte2, fileToMove, logTableName, year, month, day, hour, world, v48, logCategory, executionResult, (endTime - startTime) / 1000);
            time(&now);
            threadId2 = GetCurrentThreadId();
            timeStr = Utils::TimeToStr(&now);
            threadId3 = GetCurrentThreadId();
            CLog::Add(&g_winlog, 0, L"[%d]Now(%s), ThreadId(%d) insert file(%s), processed(%d)", threadId3, timeStr, threadId2, logFilePath, executionResult);
          }
          EnterCriticalSection(&CBCPLogFile::s_lock);
          notFound = FindNextFileW(fileHandle2, &findFileData);
        }
        else
        {
          CBCPLogFile::GetMoveFileName(this2->m_dirPath, fileToMove, newFileName);
          MoveFileW(logFilePath, newFileName);
          threadId34 = GetCurrentThreadId();
          CLog::Add(&g_winlog, 0, L"[%d]zero size file... just move file %s -> %s", threadId34, logFilePath, newFileName);
          EnterCriticalSection(&CBCPLogFile::s_lock);
          fileHandle3 = fileHandle2;
          CBCPLogFile::s_worldIds[this2->m_slot] = 0;
          notFound = FindNextFileW(fileHandle3, &findFileData);
        }
        if ( !notFound )
        {
          finished = 1;
        }
        LeaveCriticalSection(&CBCPLogFile::s_lock);
        _LeaveCriticalSection = LeaveCriticalSection;
        goto LABEL_42;
      }
      _LeaveCriticalSection = LeaveCriticalSection;
LABEL_28:
      enterCliticalSection(&CBCPLogFile::s_lock);
      if ( !FindNextFileW(fileHandle2, &findFileData) )
      {
        finished = 1;
      }
      _LeaveCriticalSection(&CBCPLogFile::s_lock);
LABEL_42:
      if ( finished )
      {
        v12 = 1;
        goto LABEL_3;
      }
      fileHandle = fileHandle2;
    }
  }
  v12 = 0;
LABEL_3:
  v57 = -1;
  unguard();
  return v12;
}
// 4241F0: using guessed type wchar_t aLin2log_dbo__0[40];
// 424240: using guessed type wchar_t aLin2log_dbo__1[40];
// 19D7E18: using guessed type int Config::s_BCPThreadCount;

//----- (004080E0) --------------------------------------------------------
int Config::Init()
{
  wchar_t fileName[14]; // [sp+8h] [bp-102Ch]@1
  int giard; // [sp+24h] [bp-1010h]@1
  WCHAR addresW[1024]; // [sp+28h] [bp-100Ch]@3
  char address[2048]; // [sp+828h] [bp-80Ch]@3
  int unused; // [sp+1030h] [bp-4h]@1

  guard(&giard, L"void InitConfig()");
  qmemcpy(fileName, L".\\l2logd.ini", 24u);
  unused = 0;
  fileName[12] = a_L2logd_ini[12];
  if ( _waccess(fileName, 0) == -1 )
  {
    CLog::Add(&g_winlog, LOG_ERROR, L"cannot read file \"L2LOG.INI\"");
  }
  else
  {
    GetPrivateProfileStringW(L"LogD", L"address", L"127.0.0.1", addresW, 2048u, fileName);
    Utils::UnicodeToAnsi(addresW, 1024, address, 2048);
    Config::s_ipAddr = (in_addr)inet_addr(address);
    Config::s_port = GetPrivateProfileIntW(L"LogD", L"port", 3999, fileName);
    Config::s_worldId = GetPrivateProfileIntW(L"World", L"WorldId", 1, fileName);
    g_winlog.m_createNewFile = 1;
    Config::s_BCPLogFileInterval = GetPrivateProfileIntW(L"Start", L"BCPInt", 300000, fileName);
    if ( (signed int)Config::s_BCPLogFileInterval > 300000 )
    {
      Config::s_BCPLogFileInterval = 300000;
    }
    Config::s_serverReportInterval = GetPrivateProfileIntW(L"Start", L"ServerInt", 10000, fileName);
    Config::s_autoBCP = GetPrivateProfileIntW(L"Start", L"AutoBCP", 0, fileName);
    Config::s_BCPFolder = GetPrivateProfileIntW(L"LogTable", L"BCPFolder", 1, fileName);
    Config::s_sqlExecLimit = GetPrivateProfileIntW(L"SQL", L"SQLExecLimit", 5000, fileName);
    Config::s_pollingInterval = GetPrivateProfileIntW(L"SQL", L"PollingInterval", 6000, fileName);
    Config::s_BCPThreadCount = GetPrivateProfileIntW(L"SQL", L"BCPThreadCount", 1, fileName);
    if ( Config::s_BCPThreadCount > 10 )
    {
      Config::s_BCPThreadCount = 10;
    }
    Config::s_makeOut = GetPrivateProfileIntW(L"LogD", L"MakeOut", 1, fileName);
  }
  unused = -1;
  return unguard();
}
// 4245B0: using guessed type wchar_t a_L2logd_ini[13];
// 19D7E18: using guessed type int Config::s_BCPThreadCount;

//----- (00408310) --------------------------------------------------------
int Config::Save()
{
  char *ipAddress; // eax@3
  char guard; // [sp+8h] [bp-230h]@1
  wchar_t fileName[13]; // [sp+Ch] [bp-22Ch]@1
  WCHAR wideCharStr[256]; // [sp+28h] [bp-210h]@3
  int unused; // [sp+234h] [bp-4h]@1

  ::guard(&guard, L"void SaveConfig()");
  qmemcpy(fileName, L".\\l2logd.ini", 24u);
  unused = 0;
  fileName[12] = a_L2logd_ini[12];              // '\0'
  if ( _waccess(fileName, 2) == -1 )            // 2 - write only
  {
    CLog::Add(&g_winlog, LOG_ERROR, L"cannot write file \"%s\"", fileName);
  }
  else
  {
    memset(wideCharStr, 0, sizeof(wideCharStr));
    ipAddress = inet_ntoa(Config::s_ipAddr);
    Utils::AnsiToUnicode(ipAddress, 255, wideCharStr, 255);
    Config::SetPrivateProfile(L"LogD", L"address", wideCharStr, fileName);
    Config::SetPrivateProfile2(L"LogD", L"port", (signed __int16)Config::s_port, fileName);
    Config::SetPrivateProfile2(L"World", L"WorldId", Config::s_worldId, fileName);
    Config::SetPrivateProfile2(L"Start", L"BCPInt", Config::s_BCPLogFileInterval, fileName);
    Config::SetPrivateProfile2(L"Start", L"ServerInt", Config::s_serverReportInterval, fileName);
    Config::SetPrivateProfile2(L"Start", L"AutoBCP", Config::s_autoBCP, fileName);
    Config::SetPrivateProfile2(L"LogTable", L"BCPFolder", Config::s_BCPFolder, fileName);
  }
  unused = -1;
  return unguard();
}
// 4245B0: using guessed type wchar_t a_L2logd_ini[13];

//----- (004084B0) --------------------------------------------------------
MACRO_FALSE __stdcall MainWindow::ConfigDlgProc(HWND hDlg, UINT msgType, WPARAM wparam, LPARAM a4)
{
  char v5; // [sp+8h] [bp-110h]@1
  wchar_t buffer[64]; // [sp+Ch] [bp-10Ch]@6
  wchar_t strBuffer[68]; // [sp+8Ch] [bp-8Ch]@8
  int v8; // [sp+114h] [bp-4h]@1

  guard(&v5, L"configDlgProc");
  v8 = 0;
  if ( msgType == WM_INITDIALOG )
  {
    Utils::ToWString((signed int)Config::s_BCPLogFileInterval / 60000, strBuffer, 10);
    SendDlgItemMessageW(hDlg, CONTROL_CONFIGURATION_EDIT_BOX_BCP_LOG_INTERVAL, WM_SETTEXT, 0, (LPARAM)strBuffer);
    Utils::ToWString((signed int)Config::s_serverReportInterval / 1000, strBuffer, 10);
    SendDlgItemMessageW(hDlg, CONTROL_CONFIGURATION_EDIT_BOX_SERVER_REPORT_INTERVAL, WM_SETTEXT, 0, (LPARAM)strBuffer);
    SendDlgItemMessageW(hDlg, CONTROL_CONFIGURATION_CHECK_BOX_BCP_ON, BM_SETCHECK, Config::s_autoBCP, 0);
    goto LABEL_9;
  }
  if ( msgType != WM_COMMAND )
  {
    goto LABEL_7;
  }
  if ( wparam == 1 )                            // IDOK
  {
    SendDlgItemMessageW(hDlg, CONTROL_CONFIGURATION_EDIT_BOX_BCP_LOG_INTERVAL, WM_GETTEXT, 64u, (LPARAM)buffer);
    Config::s_BCPLogFileInterval = 60000 * j___wtol(buffer);
    SendDlgItemMessageW(hDlg, CONTROL_CONFIGURATION_EDIT_BOX_SERVER_REPORT_INTERVAL, WM_GETTEXT, 64u, (LPARAM)buffer);
    Config::s_serverReportInterval = 1000 * j___wtol(buffer);
    Config::s_autoBCP = SendDlgItemMessageW(hDlg, CONTROL_CONFIGURATION_CHECK_BOX_BCP_ON, BM_GETSTATE, 0, 0);
    Utils::ToWString(Config::s_autoBCP, buffer, 10);
    Config::Save();
    EndDialog(hDlg, TRUE);
    goto LABEL_7;
  }
  if ( wparam != IDCANCEL )
  {
LABEL_7:
    v8 = -1;
    unguard();
    return FALSE;
  }
  EndDialog(hDlg, IDCANCEL);
LABEL_9:
  v8 = -1;
  unguard();
  return TRUE;
}

//----- (004086B0) --------------------------------------------------------
DWORD CThreadManager::GetMaxIOThreadNumber()
{
  DWORD result; // eax@1
  struct _SYSTEM_INFO systemInfo; // [sp+0h] [bp-24h]@1

  GetSystemInfo(&systemInfo);
  result = 2 * systemInfo.dwNumberOfProcessors;
  if ( (signed __int32)(2 * systemInfo.dwNumberOfProcessors) >= 8 )// 8 - MAX_IOTHREAD
  {
    result = 8;
  }
  return result;
}

//----- (004086E0) --------------------------------------------------------
int __thiscall SpinLock::Wait(SpinLock *this)
{
  signed int v1; // edi@1
  signed int v2; // ebx@4
  SpinLock *this_; // [sp+8h] [bp-14h]@1
  char v5; // [sp+Ch] [bp-10h]@1
  int v6; // [sp+18h] [bp-4h]@8

  this_ = this;
  guard(&v5, L"void SpinLock::Wait()");
  v1 = 3999;
  do
  {
    if ( !InterlockedExchange(&this_->lock, 1) )
    {
      v6 = -1;
      return unguard();
    }
    _mm_pause();
    --v1;
  }
  while ( v1 >= 0 );
  v2 = 3999;
  while ( 1 )
  {
    SwitchToThread();
    if ( !InterlockedExchange(&this_->lock, 1) )
    {
      break;
    }
    if ( --v2 < 0 )
    {
      do
      {
        Sleep(1000u);
      }
      while ( InterlockedExchange(&this_->lock, 1) );
      break;
    }
  }
  v6 = -1;
  return unguard();
}

//----- (004087B0) --------------------------------------------------------
int __thiscall CIOObject::OnTimerCallback(CIOObject *this, int id)
{
  CIOObject *this_; // esi@1
  char v4; // [sp+10h] [bp-10h]@1
  int v5; // [sp+1Ch] [bp-4h]@1

  this_ = this;
  guard(&v4, L"void CIOObject::OnTimerCallback(int id, bool bPost)");
  v5 = 0;
  if ( !PostQueuedCompletionStatus(IOCP::g_hCompletionPort, id, (ULONG_PTR)this_, 0) )
  {
    EASSERT();
    this_->vtable->base.Release(this_, "ioc.cpp", 350, ORT_TIMER, 0);
  }
  v5 = -1;
  return unguard();
}

//----- (00408840) --------------------------------------------------------
int __thiscall CIOObject::OnIOCallback(CIOObject *this, BOOL bSucess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped)
{
  CIOObject *this_; // esi@1
  CIOObject_Vtable *vtable; // eax@1
  char v7; // [sp+14h] [bp-10h]@1
  int v8; // [sp+20h] [bp-4h]@1

  this_ = this;
  guard(&v7, L"void CIOObject::OnIOCallback(BOOL bSucess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped)");
  vtable = this_->vtable;
  v8 = 0;
  ((void (__thiscall *)(CIOObject *, DWORD))vtable->OnTimer)(this_, dwTransferred);
  this_->vtable->base.Release(this_, "ioc.cpp", 360, 2, 0);
  v8 = -1;
  return unguard();
}

//----- (004088C0) --------------------------------------------------------
bool __cdecl CIOObject::SetShortTimeStamp(DWORD *pTimeVar, DWORD nAdditional)
{
  int v2; // ecx@0
  DWORD now; // eax@1
  bool result; // al@2
  int v5; // [sp+0h] [bp-10h]@1
  int v6; // [sp+Ch] [bp-4h]@2

  v5 = v2;
  guard(&v5, L"CIOObject::SetShortTimeStamp()");
  now = nAdditional + GetTickCount();
  if ( now <= *pTimeVar )
  {
    v6 = -1;
    unguard();
    result = false;
  }
  else
  {
    InterlockedExchange((volatile LONG *)pTimeVar, now);
    v6 = -1;
    unguard();
    result = true;
  }
  return result;
}

//----- (00408950) --------------------------------------------------------
CIOBuffer *__thiscall CIOBuffer::CIOBuffer(_DWORD *this)
{
  CIOBuffer *this_; // esi@1
  char v3; // [sp+4h] [bp-4h]@1

  this_ = (CIOBuffer *)this;
  guard(&v3, L"CIOBuffer::CIOBuffer()");
  this_->m_dwSize = 0;
  this_->m_pNext = 0;
  unguard();
  return this_;
}

//----- (00408980) --------------------------------------------------------
__int32 __thiscall MemoryObject::AddRef(MemoryObject *this, const char *fileName, int line, int workType)
{
  MemoryObject *v4; // esi@1

  v4 = this;
  InterlockedIncrement(&this->m_d.m_nRefCount);
  return (__int32)v4;
}

//----- (004089A0) --------------------------------------------------------
int __thiscall CIOSocket::OnClose(CIOSocket *this)
{
  CIOSocket *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  guard(&v2, L"void CIOSocket::OnClose()");
  return unguard();
}

//----- (004089C0) --------------------------------------------------------
int __thiscall CIOSocket::Close(CIOSocket *this)
{
  CIOSocket *this_; // esi@1
  LONG socket; // edi@1
  LINGER linger; // [sp+Ch] [bp-14h]@2
  char v5; // [sp+10h] [bp-10h]@1
  int v6; // [sp+1Ch] [bp-4h]@1

  this_ = this;
  guard(&v5, L"void CIOSocket::Close()");
  v6 = 0;
  socket = InterlockedExchange((volatile LONG *)&this_->d.m_hSocket, INVALID_SOCKET);
  if ( socket != INVALID_SOCKET )
  {
    this_->vtable->OnClose(this_);
    linger.l_onoff = 1;
    linger.l_linger = 0;
    setsockopt(socket, SOL_SOCKET, SO_LINGER, (const char *)&linger, sizeof(linger));
    closesocket(socket);
    this_->vtable->base.base.Release(this_, "ioc.cpp", 823, ORT_CREATE_DELETE, 0);
  }
  v6 = -1;
  return unguard();
}

//----- (00408A70) --------------------------------------------------------
int __thiscall CIOSocket::OnCreate(CIOSocket *this)
{
  CIOSocket *this_; // esi@1
  CIOSocket_Vtable *this__; // eax@1
  char v4; // [sp+4h] [bp-10h]@1
  int v5; // [sp+10h] [bp-4h]@1

  this_ = this;
  guard(&v4, L"void CIOSocket::OnCreate()");
  this__ = this_->vtable;
  v5 = 0;
  this__->OnRead(this_);
  v5 = -1;
  return unguard();
}

//----- (00408AD0) --------------------------------------------------------
int __thiscall CIOSocket::ReadCallback(CIOSocket *this, int dwTransferred)
{
  CIOSocket *this_; // esi@1
  char v4; // [sp+4h] [bp-10h]@1
  int v5; // [sp+10h] [bp-4h]@1

  this_ = this;
  guard(&v4, L"void CIOSocket::ReadCallback(DWORD dwTransferred)");
  v5 = 0;
  if ( dwTransferred )
  {
    if ( this_->d.base.base.m_nRefCount > 0 )
    {
      this_->d.m_pReadBuf->m_dwSize += dwTransferred;
      this_->vtable->OnRead(this_);
    }
    else
    {
      CLog::Add(&g_winlog, LOG_ERROR, L"invalid socket!");
    }
  }
  else
  {
    CIOSocket::Close(this_);
  }
  v5 = -1;
  return unguard();
}

//----- (00408B60) --------------------------------------------------------
int __thiscall CIOServer::Close(CIOServer *this)
{
  CIOServer *this_; // esi@1
  char v3; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v3, L"void CIOServer::Close()");
  if ( this_->m_d.m_hSocket != INVALID_SOCKET )
  {
    closesocket(this_->m_d.m_hSocket);
    this_->m_d.m_hSocket = INVALID_SOCKET;
  }
  if ( !this_->m_d.m_hAcceptEvent )             // != WSA_INVALID_EVENT
  {
    return unguard();
  }
  WSACloseEvent(this_->m_d.m_hAcceptEvent);
  this_->m_d.m_hAcceptEvent = (HANDLE)WSA_INVALID_EVENT;
  return unguard();
}

//----- (00408BB0) --------------------------------------------------------
int __thiscall CIOServer::OnWaitCallback(CIOServer *this)
{
  CIOServer *this_; // esi@1
  char v3; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v3, L"void CIOServer::OnWaitCallback()");
  WSAResetEvent(this_->m_d.m_hAcceptEvent);
  PostQueuedCompletionStatus(IOCP::g_hCompletionPort, 0, (ULONG_PTR)this_, NULL);
  return unguard();
}

//----- (00408BF0) --------------------------------------------------------
int __thiscall CIOSocket::Initialize(CIOSocket *this)
{
  CIOSocket *this_; // esi@1
  SOCKET socket; // ST00_4@1
  SOCKET socket2; // ST00_4@1
  int zero; // [sp+8h] [bp-14h]@1
  char v6; // [sp+Ch] [bp-10h]@1
  int unused; // [sp+18h] [bp-4h]@1

  this_ = this;
  guard(&v6, L"void CIOSocket::Initialize()");
  socket = this_->d.m_hSocket;
  unused = 0;
  zero = 0;
  setsockopt(socket, SOL_SOCKET, SO_RCVBUF, (const char *)&zero, 4);
  socket2 = this_->d.m_hSocket;
  zero = 0;
  setsockopt(socket2, SOL_SOCKET, SO_SNDBUF, (const char *)&zero, 4);
  if ( CreateIoCompletionPort((HANDLE)this_->d.m_hSocket, IOCP::g_hCompletionPort, (ULONG_PTR)this_, 0) )
  {
    ((void (__thiscall *)(CIOSocket *))this_->vtable->OnCreate)(this_);
  }
  else
  {
    CIOSocket::Close(this_);
  }
  unused = -1;
  return unguard();
}

//----- (00408CB0) --------------------------------------------------------
int AddLog(char *arg0, ...)
{
  char v2; // [sp+0h] [bp-204h]@1
  char v3; // [sp+4h] [bp-200h]@1
  va_list va; // [sp+20Ch] [bp+8h]@1

  va_start(va, arg0);
  guard(&v2, L"void AddLog(char* format, ...)");
  vsprintf(&v3, arg0, va);
  return unguard();
}

//----- (00408D00) --------------------------------------------------------
_BYTE *__cdecl StrNChr(_BYTE *a1, char a2, int a3)
{
  int v3; // eax@1
  _BYTE *i; // esi@1
  char v6; // [sp+4h] [bp-10h]@1
  int v7; // [sp+10h] [bp-4h]@4

  guard(&v6, L"const char *StrNChr(const char *str, char c, int len)");
  v3 = a3;
  for ( i = a1; v3 > 0; --v3 )
  {
    if ( *i == a2 )
    {
      break;
    }
    ++i;
  }
  v7 = -1;
  unguard();
  return i;
}

//----- (00408D70) --------------------------------------------------------
int __cdecl WcsNLen(int a1, int a2)
{
  int v2; // esi@1
  int v3; // eax@2
  char v5; // [sp+4h] [bp-4h]@1

  guard(&v5, L"int WcsNLen(const unsigned char *str, int len)");
  v2 = 0;
  if ( a2 > 0 )
  {
    v3 = a1;
    do
    {
      if ( !*(_BYTE *)v3 && !*(_BYTE *)(v3 + 1) )
      {
        break;
      }
      v3 += 2;
      ++v2;
    }
    while ( v2 < a2 );
  }
  unguard();
  return v2;
}

//----- (00408DC0) --------------------------------------------------------
const unsigned __int8 *PacketUtils::Disassemble(const unsigned __int8 *packet, const char *format, ...)
{
  const char *v2; // ecx@1
  int v3; // eax@1
  const unsigned __int8 *v4; // ebx@1
  const char **v5; // ebp@2
  char *v6; // eax@4
  char *v7; // eax@5
  char *v8; // eax@6
  const char *v9; // eax@7
  size_t v10; // esi@8
  int v11; // ebp@8
  char *v12; // edi@8
  unsigned int v13; // eax@9
  int v14; // ebp@9
  int v15; // eax@9
  unsigned __int8 *v16; // edi@9
  unsigned int v17; // eax@10
  int v18; // ebp@10
  unsigned __int8 *v19; // edi@10
  const char *v21; // [sp+4h] [bp-14h]@1
  char v22; // [sp+8h] [bp-10h]@1
  int v23; // [sp+14h] [bp-4h]@1

  guard(&v22, L"const unsigned char *Disassemble(const unsigned char* packet, const char* format, ...)");
  v2 = format;
  v3 = *format;
  v4 = packet;
  v23 = 0;
  v21 = format;
  if ( v3 )
  {
    v5 = &format;
    do
    {
      format = v2 + 1;
      switch ( v3 )
      {
        case 99:
          v6 = (char *)v5[1];
          ++v5;
          *v6 = *v4++;
          break;
        case 104:
          v7 = (char *)v5[1];
          ++v5;
          *(_WORD *)v7 = *(_WORD *)v4;
          v4 += 2;
          break;
        case 100:
          v8 = (char *)v5[1];
          ++v5;
          *(_DWORD *)v8 = *(_DWORD *)v4;
          v4 += 4;
          break;
        case 102:
          v9 = v5[1];
          ++v5;
          *(_DWORD *)v9 = *(_DWORD *)v4;
          *((_DWORD *)v9 + 1) = *((_DWORD *)v4 + 1);
          v4 += 8;
          break;
        case 115:
          v10 = (size_t)v5[1];
          v11 = (int)(v5 + 1);
          v12 = *(char **)(v11 + 4);
          v5 = (const char **)(v11 + 4);
          strncpy(v12, (const char *)v4, v10);
          v12[v10 - 1] = 0;
          v4 = StrNChr(v4, 0, v10) + 1;
          break;
        case 83:
          v13 = (unsigned int)v5[1];
          v14 = (int)(v5 + 1);
          v15 = WcsNLen((int)v4, (v13 >> 1) - 1);
          v16 = *(unsigned __int8 **)(v14 + 4);
          v5 = (const char **)(v14 + 4);
          qmemcpy(v16, v4, 2 * v15);
          *(_WORD *)&v16[2 * v15] = 0;
          v4 += 2 * v15 + 2;
          break;
        case 98:
          v17 = (unsigned int)v5[1];
          v18 = (int)(v5 + 1);
          v19 = *(unsigned __int8 **)(v18 + 4);
          v5 = (const char **)(v18 + 4);
          qmemcpy(v19, v4, v17);
          v4 += v17;
          break;
        default:
          CLog::Add(&g_winlog, LOG_ERROR, L"unknown type %c in %S", v3, v21);
          break;
      }
      v2 = format;
      v3 = *format;
    }
    while ( *format );
  }
  v23 = -1;
  unguard();
  return v4;
}

//----- (00408FA0) --------------------------------------------------------
int __cdecl PacketUtils::VAssemble(char *buff, int size, const char *format, va_list ap)
{
  char *start; // edi@1
  char *end; // ebp@1
  int formatType; // eax@1
  va_list v7; // ebx@2
  int v8; // eax@4
  const char *v9; // esi@12
  unsigned int v10; // edx@13
  const char *v11; // eax@14
  int v12; // edi@14
  char v13; // cl@15
  const wchar_t *v14; // esi@19
  unsigned int v15; // ecx@20
  _BYTE *v17; // edi@23

  start = buff;
  end = &buff[size];
  formatType = *format;
  if ( !*format )
  {
    return start - buff;
  }
  v7 = ap;
  while ( 1 )
  {
    ++format;
    switch ( formatType )
    {
      case 'd':
        v8 = (int)(start + 4);
        if ( start + 4 > end )
        {
          goto LABEL_21;
        }
        *(_DWORD *)start = *(_DWORD *)v7;
        v7 += 4;
        goto LABEL_27;
      case 'c':
        v8 = (int)(start + 1);
        if ( start + 1 > end )
        {
          goto LABEL_21;
        }
        *start = *v7;
        v7 += 4;
        goto LABEL_27;
      case 'h':
        v8 = (int)(start + 2);
        if ( start + 2 > end )
        {
          goto LABEL_21;
        }
        *(_WORD *)start = *(_WORD *)v7;
        v7 += 4;
        goto LABEL_27;
      case 'f':
        v8 = (int)(start + 8);
        if ( start + 8 > end )
        {
          goto LABEL_21;
        }
        *(_DWORD *)start = *(_DWORD *)v7;
        *((_DWORD *)start + 1) = *((_DWORD *)v7 + 1);
        v7 += 8;
        goto LABEL_27;
      case 's':
        v9 = *(const char **)v7;
        v7 += 4;
        if ( v9 )
        {
          v10 = (unsigned int)&start[strlen(v9) + 1];
          if ( v10 > (unsigned int)end )
          {
            goto LABEL_21;
          }
          v11 = v9;
          v12 = start - v9;
          do
          {
            v13 = *v11;
            v11[v12] = *v11;
            ++v11;
          }
          while ( v13 );
          start = (char *)v10;
          goto LABEL_28;
        }
        v8 = (int)(start + 1);
        if ( start + 1 > end )
        {
          goto LABEL_21;
        }
        *start = 0;
        goto LABEL_27;
      case 'S':
        v14 = *(const wchar_t **)v7;
        v7 += 4;
        if ( v14 )
        {
          v15 = 2 * wcslen(v14) + 2;
          v8 = (int)&start[v15];
          if ( &start[v15] > end )
          {
            goto LABEL_21;
          }
LABEL_26:
          qmemcpy(start, v14, v15);
LABEL_27:
          start = (char *)v8;
        }
        else
        {
          if ( start + 2 > end )
          {
LABEL_21:
            CLog::Add(&g_winlog, LOG_ERROR, L"Buffer overflow in Assemble");
            CallStack::ReportCallStack();
            return 0;
          }
          *start = 0;
          v17 = start + 1;
          *v17 = 0;
          start = v17 + 1;
        }
LABEL_28:
        formatType = *format;
        if ( !*format )
        {
          return start - buff;
        }
        break;
      case 'b':
        v15 = *(_DWORD *)v7;
        v8 = (int)&start[v15];
        v7 += 8;
        if ( &start[v15] > end )
        {
          goto LABEL_21;
        }
        v14 = (const wchar_t *)*((_DWORD *)v7 - 1);
        goto LABEL_26;
      default:
        goto LABEL_28;
    }
  }
  return start - buff;
}

//----- (00409160) --------------------------------------------------------
CIOBufferPool *__thiscall CIOBufferPool::CIOBufferPool(CIOBufferPool *this, int size)
{
  CIOBufferPool *this_; // esi@1
  CIOBuffer **bufferIndexes; // eax@1
  CIOBuffer **first; // edx@1
  int i; // eax@1
  CIOBuffer *it; // ecx@2

  this_ = this;
  this->m_poolSize = size;
  this->m_buffers = (CIOBuffer *)malloc(sizeof(CIOBuffer) * size);
  bufferIndexes = (CIOBuffer **)malloc(4 * size);// sizeofs
  first = (CIOBuffer **)this_->m_buffers;
  this_->m_bufferIndexes = bufferIndexes;
  i = 0;
  *first = 0;
  if ( size > 0 )
  {
    it = 0;
    do
    {
      this_->m_bufferIndexes[i++] = (CIOBuffer *)((char *)it + (unsigned int)this_->m_buffers);
      ++it;
    }
    while ( i < size );
  }
  this_->m_allocIndex = 0;
  this_->m_freeSlots = size;
  this_->m_freeIndex = size;
  return this_;
}

//----- (004091D0) --------------------------------------------------------
int __thiscall sub_4091D0(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 4);
  if ( result )
  {
    result = (*(_DWORD *)(this + 8) - result) / 12;
  }
  return result;
}

//----- (004091F0) --------------------------------------------------------
int MemoryObject::IsUser()
{
  return false;
}

//----- (00409200) --------------------------------------------------------
__int32 __thiscall MemoryObject::RefCount(MemoryObject *this)
{
  return this->m_d.m_nRefCount;
}

//----- (00409210) --------------------------------------------------------
MemoryObject *__thiscall MemoryObject::DeletingDestructor(MemoryObject *this, char a2)
{
  MemoryObject *this_; // esi@1

  this_ = this;
  this->vtable = (MemoryObject_Vtable *)&MemoryObject_Vtable_off_424CC0;
  if ( !(a2 & 1) )
  {
    return this_;
  }
  CLog::Add(&g_winlog, LOG_ERROR, L"Never Call Oprator Delete!!! MemoryObject at file[%s], line[%d]", L"d:\\work\\l2\\server\\l2logd\\obj.h", 283);
  CallStack::ReportCallStack();
  return this_;
}
// 424CC0: using guessed type void *MemoryObject_Vtable_off_424CC0;
// 424D60: using guessed type wchar_t aDWorkL2ServerL[31];

//----- (00409260) --------------------------------------------------------
int __thiscall CIOObject::OnTimer(CIOObject *this, int id)
{
  CIOObject_Vtable *vtable; // eax@1

  vtable = this->vtable;
  this->m_d.base.m_inTimer = 0;
  return ((int (__stdcall *)(_DWORD))vtable->TimerExpired)(id);
}

//----- (00409280) --------------------------------------------------------
BOOL __thiscall CIOObject::PostObject(CIOObject *this, DWORD id)
{
  return PostQueuedCompletionStatus(IOCP::g_hCompletionPort, id, (ULONG_PTR)this, NULL);
}

//----- (004092A0) --------------------------------------------------------
CIODeadlockChecker *__thiscall CIODeadlockChecker::CIODeadlockChecker(CIODeadlockChecker *this)
{
  CIODeadlockChecker *this_; // esi@1

  this_ = this;
  MemoryObject::MemoryObject((MemoryObject *)this);
  this_->vtable = (CIOObject_Vtable *)&CIODeadlockChecker::vtable;
  this_->d.m_nLastTick = 0;
  return this_;
}
// 424DA0: using guessed type void *CIODeadlockChecker::vtable;

//----- (004092C0) --------------------------------------------------------
int CPacket::operator_delete()
{
  CLog::Add(&g_winlog, LOG_ERROR, L"Never Call Oprator Delete!!! CPacket at file[%s], line[%d]", L"d:\\work\\l2\\server\\l2logd\\ioc.h", 514);
  return CallStack::ReportCallStack();
}
// 424E68: using guessed type wchar_t aDWorkL2Serve_0[31];

//----- (004092F0) --------------------------------------------------------
int CIOBufferPool::getFreeSlotsNumberFromAllPools()
{
  int totalSize; // edi@1
  int i; // esi@1
  CIOBufferPool *pool; // eax@2
  int freeSlots; // eax@3

  totalSize = 0;
  for ( i = 0; i < CThreadManager::GetIOThreadNumber(); ++i )
  {
    pool = g_IOBufferPools[i];
    if ( pool )
    {
      freeSlots = pool->m_freeSlots;
    }
    else
    {
      freeSlots = 0;
    }
    totalSize += freeSlots;
  }
  return totalSize;
}

//----- (00409330) --------------------------------------------------------
LONG __thiscall CIODeadlockChecker::Release(CIODeadlockChecker *this, const char *file, int line, int nWorkType, bool flag)
{
  CIODeadlockChecker *this_; // esi@1
  LONG refCount; // eax@1
  LONG refCount2; // edi@1
  LONG result; // eax@5

  this_ = this;
  refCount = InterlockedDecrement(&this->d.base.base.m_nRefCount);
  refCount2 = refCount;
  if ( refCount > 0 )
  {
    return refCount2;
  }
  if ( refCount )
  {
    if ( refCount > -1 )
    {
      return refCount2;
    }
    CLog::Add_Ansi(&g_winlog, LOG_ERROR, "Invalid Memory (%d) on CIODeadlockChecker(%d)", refCount, this_->d.base.base.m_identity);
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "           Caller : file[%s], line[%d]", file, line);
    }
    MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
    CallStack::ReportCallStack();
    return refCount2;
  }
  if ( this_->d.base.base.m_inTimer )
  {
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![CIODeadlockChecker] at file[%s], line[%d]", file, line);
      MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * CIODeadlockChecker::s_nAlloc + 0x455E50));
      result = refCount2;
    }
    else
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![CIODeadlockChecker]");
      MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * CIODeadlockChecker::s_nAlloc + 0x455E50));
      result = refCount2;
    }
  }
  else
  {
    this_->vtable->base.DeletingDestructor(this_, 0);
    MMU::deallocate(&g_mmu, this_);
    InterlockedDecrement((volatile LONG *)(4 * CIODeadlockChecker::s_nAlloc + 0x455E50));
    result = refCount2;
  }
  return result;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (00409460) --------------------------------------------------------
CIOBuffer *__cdecl CIOBuffer::Alloc()
{
  int v0; // ecx@0
  int tls; // edi@1
  CIOBufferPool *pool; // esi@1
  unsigned int used; // eax@1
  CIOBuffer *buffer; // esi@1
  int guard; // [sp+0h] [bp-4h]@1

  guard = v0;
  tls = *(_DWORD *)(__readfsdword(44) + 4 * TlsIndex);
  pool = g_IOBufferPools[*(_DWORD *)(tls + 8)];
  InterlockedDecrement(&pool->m_freeSlots);
  used = pool->m_allocIndex + 1;
  pool->m_allocIndex = used;
  buffer = pool->m_bufferIndexes[used % pool->m_poolSize];
  buffer->m_threadIndex = *(_DWORD *)(tls + 8);
  if ( g_IOBufferPools[*(_DWORD *)(tls + 8)]->m_freeSlots < 8 )
  {
    ::guard(&guard, L"io_buffer_crash");
    LOBYTE(::v0) = 1;                           // CRASH
    unguard();
  }
  buffer->m_dwSize = 0;
  buffer->m_pNext = 0;
  buffer->m_nRefCount = 1;
  return buffer;
}
// 1BD5478: using guessed type int TlsIndex;

//----- (00409500) --------------------------------------------------------
CIOBuffer **__thiscall CIOBuffer::Free(CIOBuffer *this)
{
  CIOBuffer *this_; // edi@1
  CIOBufferPool *pool; // esi@1
  unsigned int lastUsed; // edx@1
  CIOBuffer **result; // eax@1

  this_ = this;
  pool = g_IOBufferPools[this->m_threadIndex];
  InterlockedIncrement(&pool->m_freeSlots);
  lastUsed = (unsigned int)InterlockedIncrement(&pool->m_freeIndex) % pool->m_poolSize;
  result = pool->m_bufferIndexes;
  result[lastUsed] = this_;
  return result;
}

//----- (00409540) --------------------------------------------------------
LONG __thiscall CIOSocket::Release(CIOSocket *this, const char *file, int line, int nWorkType, bool flag)
{
  CIOSocket *this_; // esi@1
  LONG refCount; // eax@1
  LONG refCount_; // edi@1
  LONG result; // eax@5

  this_ = this;
  refCount = InterlockedDecrement(&this->d.base.base.m_nRefCount);
  refCount_ = refCount;
  if ( refCount > 0 )
  {
    return refCount_;
  }
  if ( refCount )
  {
    if ( refCount > -1 )
    {
      return refCount_;
    }
    CLog::Add_Ansi(&g_winlog, LOG_ERROR, "Invalid Memory (%d) on CIOSocket(%d)", refCount, this_->d.base.base.m_identity);
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "           Caller : file[%s], line[%d]", file, line);
    }
    MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
    CallStack::ReportCallStack();
    return refCount_;
  }
  if ( this_->d.base.base.m_inTimer )
  {
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![CIOSocket] at file[%s], line[%d]", file, line);
      MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * CIOSocket::s_nAlloc + 0x455E50));
      result = refCount_;
    }
    else
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![CIOSocket]");
      MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * CIOSocket::s_nAlloc + 0x455E50));
      result = refCount_;
    }
  }
  else
  {
    this_->vtable->base.base.DeletingDestructor(this_, 0);
    MMU::deallocate(&g_mmu, this_);
    InterlockedDecrement((volatile LONG *)(4 * CIOSocket::s_nAlloc + 0x455E50));
    result = refCount_;
  }
  return result;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (00409670) --------------------------------------------------------
CIOSocket *__thiscall CIOSocket::CIOSocket(CIOSocket *this, SOCKET socket)
{
  CIOSocket *this_; // esi@1
  OVERLAPPED *overlappedRead; // edx@1
  OVERLAPPED *overlappedWrite; // ecx@1
  char v6; // [sp+8h] [bp-14h]@1
  CIOSocket *this__; // [sp+Ch] [bp-10h]@1
  int v8; // [sp+18h] [bp-4h]@1

  this_ = this;
  this__ = this;
  MemoryObject::MemoryObject((MemoryObject *)this);
  v8 = 0;
  this_->vtable = (CIOSocket_Vtable *)&CIOSocket_vtable_425060;
  CIOCriticalSection::CIOCriticalSection(&this_->d.m_lock);
  LOBYTE(v8) = 1;
  guard(&v6, L"CIOSocket::CIOSocket(SOCKET s)");
  this_->d.m_hSocket = socket;
  overlappedRead = &this_->d.m_overlappedRead;
  overlappedRead->Internal = 0;
  overlappedRead->InternalHigh = 0;
  overlappedRead->Offset = 0;
  overlappedRead->OffsetHigh = 0;
  overlappedRead->hEvent = 0;
  overlappedWrite = &this_->d.m_overlappedWrite;
  overlappedWrite->Internal = 0;
  overlappedWrite->InternalHigh = 0;
  overlappedWrite->Offset = 0;
  overlappedWrite->OffsetHigh = 0;
  LOBYTE(v8) = 2;
  overlappedWrite->hEvent = 0;
  this_->d.m_pReadBuf = CIOBuffer::Alloc();
  this_->d.m_nPendingWrite = 0;
  this_->d.m_pLastBuf = 0;
  this_->d.m_pFirstBuf = 0;
  LOBYTE(v8) = 1;
  unguard();
  return this_;
}

//----- (00409730) --------------------------------------------------------
LONG __thiscall CIOServer::Release(CIOServer *this, const char *file, int line, int nWorkType)
{
  CIOServer *this_; // esi@1
  LONG refCount; // eax@1
  LONG refCount_; // edi@1
  LONG result; // eax@5

  this_ = this;
  refCount = InterlockedDecrement(&this->m_d.base.m_nRefCount);
  refCount_ = refCount;
  if ( refCount > 0 )
  {
    return refCount_;
  }
  if ( refCount )
  {
    if ( refCount > -1 )
    {
      return refCount_;
    }
    CLog::Add_Ansi(&g_winlog, LOG_ERROR, "Invalid Memory (%d) on CIOServer(%d)", refCount, this_->m_d.base.m_identity);
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "           Caller : file[%s], line[%d]", file, line);
    }
    MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
    CallStack::ReportCallStack();
    return refCount_;
  }
  if ( this_->m_d.base.m_inTimer )
  {
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![CIOServer] at file[%s], line[%d]", file, line);
      MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * CIOServer::s_nAlloc + 0x455E50));
      result = refCount_;
    }
    else
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![CIOServer]");
      MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * CIOServer::s_nAlloc + 0x455E50));
      result = refCount_;
    }
  }
  else
  {
    this_->vtable->base.base.DeletingDestructor(this_, 0);
    MMU::deallocate(&g_mmu, this_);
    InterlockedDecrement((volatile LONG *)(4 * CIOServer::s_nAlloc + 0x455E50));
    result = refCount_;
  }
  return result;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (00409860) --------------------------------------------------------
CIOServer *__thiscall CIOServer::CIOServer(CIOServer *this)
{
  CIOServer *this_; // esi@1
  char v3; // [sp+4h] [bp-14h]@1
  CIOServer *this_2; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  this_ = this;
  this_2 = this;
  MemoryObject::MemoryObject((MemoryObject *)this);
  v5 = 0;
  this_->vtable = (CIOServer_Vtable *)&CIOServer_vtable_offset;
  guard(&v3, L"CIOServer::CIOServer()");
  this_->m_d.m_hSocket = INVALID_SOCKET;
  this_->m_d.m_hAcceptEvent = (HANDLE)WSA_INVALID_EVENT;
  unguard();
  return this_;
}
// 425130: using guessed type void *CIOServer_vtable_offset;

//----- (004098D0) --------------------------------------------------------
int __thiscall CIOServer::Destructor(CIOServer *this)
{
  CIOServer *this_; // esi@1
  int result; // eax@1
  char v3; // [sp+4h] [bp-14h]@1
  CIOServer *this2; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  this_ = this;
  this2 = this;
  this->vtable = (CIOServer_Vtable *)&CIOServer_vtable_offset;
  v5 = 0;
  guard(&v3, L"CIOServer::~CIOServer()");
  LOBYTE(v5) = 1;
  CIOServer::Close(this_);
  LOBYTE(v5) = 0;
  result = unguard();
  this_->vtable = (CIOServer_Vtable *)&MemoryObject_Vtable_off_424CC0;
  return result;
}
// 424CC0: using guessed type void *MemoryObject_Vtable_off_424CC0;
// 425130: using guessed type void *CIOServer_vtable_offset;

//----- (00409940) --------------------------------------------------------
int __thiscall CIOServer::OnIOCallback(CIOServer *this, BOOL bSuccess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped)
{
  CIOServer *this_; // esi@1
  SOCKET hSocket; // ST00_4@1
  SOCKET newSocket; // edi@1
  int err; // eax@4
  CIOSocket *pSocket; // eax@5
  char v10; // [sp+Ch] [bp-24h]@1
  int clientAddressLength; // [sp+10h] [bp-20h]@1
  sockaddr_in clientAddress; // [sp+14h] [bp-1Ch]@1
  MACRO_WSASYS v13; // [sp+2Ch] [bp-4h]@1

  this_ = this;
  guard(&v10, L"void CIOServer::OnIOCallback(BOOL bSuccess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped)");
  hSocket = this_->m_d.m_hSocket;
  v13 = 0;
  clientAddressLength = sizeof(sockaddr_in);
  newSocket = accept(hSocket, (struct sockaddr *)&clientAddress, &clientAddressLength);
  if ( newSocket == INVALID_SOCKET )
  {
    if ( WSAGetLastError() != WSAEWOULDBLOCK && this_->m_d.m_hSocket != INVALID_SOCKET )
    {
      err = WSAGetLastError();
      AddLog("accept error: %d", err);
    }
  }
  else
  {
    pSocket = (CIOSocket *)this_->vtable->CreateSocket(this_, newSocket, &clientAddress);
    if ( pSocket )
    {
      CIOSocket::Initialize(pSocket);
    }
    else
    {
      closesocket(newSocket);
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "Socket Create fail");
    }
  }
  v13 = INVALID_SOCKET;
  return unguard();
}

//----- (00409A20) --------------------------------------------------------
LONG __thiscall CPacket::Release(CPacket *this, const char *file, int line, int nWorkType, bool flag)
{
  CPacket *this_; // esi@1
  LONG refCount; // eax@1
  LONG refCount2; // edi@1
  LONG result; // eax@5

  this_ = this;
  refCount = InterlockedDecrement(&this->d.base.base.m_nRefCount);
  refCount2 = refCount;
  if ( refCount > 0 )
  {
    return refCount2;
  }
  if ( refCount )
  {
    if ( refCount > -1 )
    {
      return refCount2;
    }
    CLog::Add_Ansi(&g_winlog, LOG_ERROR, "Invalid Memory (%d) on CPacket(%d)", refCount, this_->d.base.base.m_identity);
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "           Caller : file[%s], line[%d]", file, line);
    }
    MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
    CallStack::ReportCallStack();
    return refCount2;
  }
  if ( this_->d.base.base.m_inTimer )
  {
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![CPacket] at file[%s], line[%d]", file, line);
      MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * CPacket::s_nAlloc + 0x455E50));
      result = refCount2;
    }
    else
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![CPacket]");
      MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * CPacket::s_nAlloc + 0x455E50));
      result = refCount2;
    }
  }
  else
  {
    this_->vtable->base.DeletingDestructor(this_, 0);
    MMU::deallocate(&g_mmu, this_);
    InterlockedDecrement((volatile LONG *)(4 * CPacket::s_nAlloc + 0x455E50));
    result = refCount2;
  }
  return result;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (00409B50) --------------------------------------------------------
int CPacket::FreeAll()
{
  CSlot *slot; // esi@1
  CPacket *i; // ecx@4
  char v3; // [sp+14h] [bp-10h]@1
  int unused; // [sp+20h] [bp-4h]@1

  guard(&v3, L"void CPacket::FreeAll()");
  unused = 0;
  slot = CPacketPool::s_slots;
  do
  {
    if ( InterlockedExchange(&slot->m_lock.lock, 1) )// inlined
    {
      SpinLock::Wait(&slot->m_lock);
    }
    for ( i = slot->m_pPacket; slot->m_pPacket; i = slot->m_pPacket )
    {
      slot->m_pPacket = (CPacket *)i->d.m_pSocket;
      ((void (__stdcall *)(signed int))i->vtable->base.DeletingDestructor)(1);
    }
    InterlockedExchange(&slot->m_lock.lock, 0);
    ++slot;
  }
  while ( (signed int)slot < (signed int)&CPacketPool::s_size );
  unused = -1;
  return unguard();
}

//----- (00409C00) --------------------------------------------------------
_DWORD *__cdecl sub_409C00(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // eax@1
  int i; // ecx@1
  _DWORD *result; // eax@3

  v4 = a3;
  for ( i = a4; v4 != a2; *(_DWORD *)(i + 8) = *(_DWORD *)(v4 + 8) )
  {
    v4 -= 12;
    i -= 12;
    *(_DWORD *)i = *(_DWORD *)v4;
    *(_DWORD *)(i + 4) = *(_DWORD *)(v4 + 4);
  }
  result = a1;
  *a1 = i;
  return result;
}

//----- (00409C40) --------------------------------------------------------
_DWORD *__cdecl sub_409C40(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // ecx@1
  _DWORD *result; // eax@1

  v3 = a1;
  for ( result = a3; v3 != a2; ++result )
  {
    if ( result )
    {
      *result = *v3;
    }
    ++v3;
  }
  return result;
}

//----- (00409C70) --------------------------------------------------------
int __cdecl sub_409C70(int a1, int a2, int a3)
{
  int v3; // ecx@1
  int result; // eax@1

  v3 = a1;
  for ( result = a3; v3 != a2; result += 12 )
  {
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)v3;
      *(_DWORD *)(result + 4) = *(_DWORD *)(v3 + 4);
      *(_DWORD *)(result + 8) = *(_DWORD *)(v3 + 8);
    }
    v3 += 12;
  }
  return result;
}

//----- (00409CB0) --------------------------------------------------------
LONG __thiscall CIOBuffer::Release(CIOBuffer *this)
{
  CIOBuffer *this_; // esi@1
  LONG refCount; // eax@1

  this_ = this;
  refCount = InterlockedDecrement(&this->m_nRefCount);
  if ( !refCount )
  {
    refCount = (LONG)CIOBuffer::Free(this_);
  }
  return refCount;
}

//----- (00409CD0) --------------------------------------------------------
CIODeadlockChecker *__thiscall CIODeadlockChecker::DeletingDestructor(CIODeadlockChecker *this, char a2)
{
  CIODeadlockChecker *this_; // esi@1

  this_ = this;
  CIOObject::Destructor((CIOObject *)this);
  if ( !(a2 & 1) )
  {
    return this_;
  }
  CLog::Add(&g_winlog, LOG_ERROR, L"Never Call Oprator Delete!!! CIODeadlockChecker at file[%s], line[%d]", L"d:\\work\\l2\\server\\l2logd\\ioc.h", 459);
  CallStack::ReportCallStack();
  return this_;
}
// 424E68: using guessed type wchar_t aDWorkL2Serve_0[31];

//----- (00409D10) --------------------------------------------------------
int __thiscall CIOSocket::Destructor(CIOSocket *this)
{
  CIOSocket *this_; // esi@1
  CIOBuffer *readBuf; // edi@1
  CIOBuffer *buf; // edi@4
  int result; // eax@7
  char v5; // [sp+Ch] [bp-14h]@1
  CIOSocket *this__; // [sp+10h] [bp-10h]@1
  int unused; // [sp+1Ch] [bp-4h]@1

  this_ = this;
  this__ = this;
  this->vtable = (CIOSocket_Vtable *)&CIOSocket_vtable_425060;
  unused = 1;
  guard(&v5, L"CIOSocket::~CIOSocket()");
  readBuf = this_->d.m_pReadBuf;
  if ( !InterlockedDecrement(&readBuf->m_nRefCount) )// INLINED RELEASE
  {
    CIOBuffer::Free(readBuf);
  }
  while ( this_->d.m_pFirstBuf )
  {
    buf = this_->d.m_pFirstBuf;
    this_->d.m_pFirstBuf = buf->m_pNext;
    if ( !InterlockedDecrement(&buf->m_nRefCount) )
    {
      CIOBuffer::Free(buf);
    }
  }
  unguard();
  LOBYTE(unused) = 0;
  result = CIOCriticalSection::Destructor(&this_->d.m_lock);
  this_->vtable = (CIOSocket_Vtable *)&MemoryObject_Vtable_off_424CC0;
  return result;
}
// 424CC0: using guessed type void *MemoryObject_Vtable_off_424CC0;

//----- (00409DD0) --------------------------------------------------------
int __thiscall CIOSocket::Read(CIOSocket *this, size_t dwLeft)
{
  CIOSocket *this_; // ebp@1
  CIOBuffer *readBuf; // eax@1
  unsigned int bytesLeft; // ebx@1
  size_t size; // esi@1
  CIOBuffer *readBuf_; // eax@1
  bool v7; // zf@1
  bool v8; // sf@1
  unsigned __int8 v9; // of@1
  CIOBuffer *readBuf2; // esi@2
  CIOBuffer *readBuf3; // eax@6
  SOCKET socket; // edx@6
  DWORD error; // eax@8
  char v15; // [sp+10h] [bp-28h]@2
  char v16; // [sp+14h] [bp-24h]@1
  DWORD flags; // [sp+18h] [bp-20h]@6
  char v18; // [sp+1Ch] [bp-1Ch]@1
  DWORD NumberOfBytesRecvd; // [sp+20h] [bp-18h]@6
  struct _WSABUF buffers; // [sp+24h] [bp-14h]@6
  int v21; // [sp+34h] [bp-4h]@1
  CIOBuffer *nextBuf; // [sp+3Ch] [bp+4h]@2

  this_ = this;
  guard(&v18, L"void CIOSocket::Read(DWORD dwLeft)");
  readBuf = this_->d.m_pReadBuf;
  bytesLeft = dwLeft;
  size = readBuf->m_dwSize - dwLeft;
  v21 = 0;
  readBuf->m_dwSize = size;
  guard(&v16, L"read_copy");
  readBuf_ = this_->d.m_pReadBuf;
  v9 = __OFSUB__(readBuf_->m_nRefCount, 1);
  v7 = readBuf_->m_nRefCount == 1;
  v8 = readBuf_->m_nRefCount - 1 < 0;
  LOBYTE(v21) = 1;
  if ( (unsigned __int8)(v8 ^ v9) | v7 )        // less or equal 1
  {
    memcpy(readBuf_->m_Buffer, &readBuf_->m_Buffer[readBuf_->m_dwSize], dwLeft);
  }
  else
  {
    guard(&v15, L"read_alloc");
    LOBYTE(v21) = 2;
    nextBuf = CIOBuffer::Alloc();
    qmemcpy(nextBuf->m_Buffer, &this_->d.m_pReadBuf->m_Buffer[this_->d.m_pReadBuf->m_dwSize], bytesLeft);
    readBuf2 = this_->d.m_pReadBuf;
    if ( !InterlockedDecrement(&readBuf2->m_nRefCount) )// INLINED Release
    {
      CIOBuffer::Free(readBuf2);
    }
    this_->d.m_pReadBuf = nextBuf;
    LOBYTE(v21) = 1;
    unguard();
  }
  this_->d.m_pReadBuf->m_dwSize = bytesLeft;
  LOBYTE(v21) = 0;
  unguard();
  this_->vtable->base.base.AddRef((MemoryObject *)this_, "ioc.cpp", 995, ORT_IO_RETAIN);
  readBuf3 = this_->d.m_pReadBuf;
  buffers.len = 8192 - readBuf3->m_dwSize;
  socket = this_->d.m_hSocket;
  buffers.buf = (char *)&readBuf3->m_Buffer[readBuf3->m_dwSize];
  flags = 0;
  if ( WSARecv(socket, &buffers, 1u, &NumberOfBytesRecvd, &flags, (LPWSAOVERLAPPED)&this_->d.m_overlappedRead, 0) && GetLastError() != ERROR_IO_PENDING )
  {
    error = GetLastError();
    if ( error != WSAENOTSOCK && error != WSAECONNRESET && error != WSAECONNABORTED )
    {
      AddLog("CIOSocket::Read %x(%x) err = %d", this_->d.m_hSocket, this_, error);
    }
    CIOSocket::Close(this_);
    this_->vtable->base.base.Release(this_, "ioc.cpp", 1011, ORT_IO_RETAIN, 0);
  }
  v21 = -1;
  return unguard();
}

//----- (00409FC0) --------------------------------------------------------
void __thiscall CIOSocket::WriteCallback(CIOSocket *this, DWORD dwTransferred)
{
  CIOSocket *this_; // esi@1
  CIOCriticalSection *lock; // ebp@1
  int size; // eax@1
  signed int i; // edi@2
  signed int j; // edi@4
  int bytesLeft; // ecx@7
  CIOBuffer *firstBuff; // eax@7
  CIOBuffer *firstBuff2; // ebx@7
  CIOBuffer *nextBuf; // eax@7
  SOCKET socket; // ST00_4@8
  DWORD error; // eax@10
  struct _WSABUF buffers; // [sp+Ch] [bp-8h]@8

  this_ = this;
  lock = &this->d.m_lock;
  CIOCriticalSection::Enter(&this->d.m_lock, 0, 0);
  size = this_->d.m_pFirstBuf->m_dwSize;
  if ( dwTransferred == size )
  {
    bytesLeft = this_->d.m_nPendingWrite - size;
    firstBuff = this_->d.m_pFirstBuf;
    this_->d.m_nPendingWrite = bytesLeft;
    InterlockedExchangeAdd(&CIOSocket::s_pendingWriteBytes, -firstBuff->m_dwSize);
    firstBuff2 = this_->d.m_pFirstBuf;
    nextBuf = firstBuff2->m_pNext;
    this_->d.m_pFirstBuf = nextBuf;
    if ( nextBuf )
    {
      buffers.len = nextBuf->m_dwSize;
      buffers.buf = (char *)nextBuf->m_Buffer;
      CIOCriticalSection::Leave(lock, 0, 0);
      this_->vtable->base.base.AddRef((MemoryObject *)this_, "ioc.cpp", 1052, ORT_IO_RETAIN);
      socket = this_->d.m_hSocket;
      dwTransferred = 0;
      if ( WSASend(socket, &buffers, 1u, &dwTransferred, 0, (LPWSAOVERLAPPED)&this_->d.m_overlappedWrite, 0) && GetLastError() != ERROR_IO_PENDING )
      {
        error = GetLastError();
        if ( error != WSAENOTSOCK && error != WSAECONNRESET && error != WSAECONNABORTED )
        {
          CLog::Add_Ansi(&g_winlog, LOG_ERROR, "CIOSocket::WriteCallback %x(%x) err=%d", this_->d.m_hSocket, this_, error);
        }
        this_->vtable->base.base.Release(this_, "ioc.cpp", 1063, ORT_IO_RETAIN, 0);
      }
    }
    else
    {
      this_->d.m_pLastBuf = 0;
      CIOCriticalSection::Leave(lock, 0, 0);
    }
    if ( !InterlockedDecrement(&firstBuff2->m_nRefCount) )
    {
      CIOBuffer::Free(firstBuff2);
    }
    InterlockedDecrement(&dword_1BD3BD0);
  }
  else
  {
    CLog::Add_Ansi(&g_winlog, LOG_ERROR, "different write count %x(%x) %d != %d", this_->d.m_hSocket, this_, dwTransferred, this_->d.m_pFirstBuf->m_dwSize);
    i = 0;
    do
    {
      CLog::Add(&g_winlog, LOG_ERROR, L"[%x]", this_->d.m_pFirstBuf->pad1[i++]);
    }
    while ( i < 16 );
    j = 0;
    do
    {
      CLog::Add(&g_winlog, LOG_ERROR, L"[%x]", this_->d.m_pFirstBuf->pad2[j++]);
    }
    while ( j < 16 );
    CIOCriticalSection::Leave(lock, 0, 0);
  }
}

//----- (0040A180) --------------------------------------------------------
int __thiscall CIOSocket::Write(CIOSocket *this, CIOBuffer *buffer)
{
  CIOSocket *this_; // ebx@1
  CIOBuffer *buffer1; // ebp@1
  int size; // eax@1
  int result; // eax@4
  type_info *v6; // eax@8
  int v7; // ST18_4@8
  CIOBuffer *lastBuf; // eax@10
  SOCKET socket; // edx@11
  DWORD err; // eax@13
  int lastBuf_size; // edx@19
  CIOCriticalSection *lock; // ecx@20
  char v13; // [sp+8h] [bp-18h]@1
  struct _WSABUF buffers; // [sp+Ch] [bp-14h]@11
  int unused; // [sp+1Ch] [bp-4h]@1

  this_ = this;
  guard(&v13, L"void CIOSocket::Write(CIOBuffer *pBuffer)");
  buffer1 = buffer;
  size = buffer->m_dwSize;
  unused = 0;
  if ( size )
  {
    buffer = (CIOBuffer *)&this_->d.m_lock;
    CIOCriticalSection::Enter(&this_->d.m_lock, 0, 0);
    this_->d.m_nPendingWrite += buffer1->m_dwSize;
    InterlockedExchangeAdd(&CIOSocket::s_pendingWriteBytes, buffer1->m_dwSize);
    if ( this_->d.m_nPendingWrite > 0x200000 )
    {
      if ( this_->d.m_hSocket == INVALID_SOCKET )
      {
        CLog::Add(&g_winlog, LOG_ERROR, L"[%s][%d] Write to invalid socket.", L"ioc.cpp", 1103);
      }
      v6 = (type_info *)typeid(this_, (int)&off_42D820);
      if ( unknown_libname_3(v6, v7) )
      {
        CallStack::ReportCallStack();
      }
    }
    lastBuf = this_->d.m_pLastBuf;
    if ( lastBuf )
    {
      if ( this_->d.m_pFirstBuf == lastBuf || (lastBuf_size = lastBuf->m_dwSize, (unsigned int)(lastBuf_size + buffer1->m_dwSize) > 0x2000) )
      {
        lastBuf->m_pNext = buffer1;
        this_->d.m_pLastBuf = buffer1;
        CIOCriticalSection::Leave(&this_->d.m_lock, 0, 0);
      }
      else
      {
        qmemcpy(&lastBuf->m_Buffer[lastBuf_size], buffer1->m_Buffer, buffer1->m_dwSize);
        lock = (CIOCriticalSection *)buffer;
        this_->d.m_pLastBuf->m_dwSize += buffer1->m_dwSize;
        CIOCriticalSection::Leave(lock, 0, 0);
        CIOBuffer::Release(buffer1);
      }
    }
    else
    {
      this_->d.m_pLastBuf = buffer1;
      this_->d.m_pFirstBuf = buffer1;
      CIOCriticalSection::Leave(&this_->d.m_lock, 0, 0);
      this_->vtable->base.base.AddRef((MemoryObject *)this_, "ioc.cpp", 1113, ORT_IO_RETAIN);
      socket = this_->d.m_hSocket;
      buffers.len = buffer1->m_dwSize;
      buffers.buf = (char *)buffer1->m_Buffer;
      if ( WSASend(socket, &buffers, 1u, (LPDWORD)&buffer, 0, (LPWSAOVERLAPPED)&this_->d.m_overlappedWrite, 0) && GetLastError() != ERROR_IO_PENDING )
      {
        err = GetLastError();
        if ( err != WSAENOTSOCK && err != WSAECONNRESET && err != WSAECONNABORTED )
        {
          CLog::Add_Ansi(&g_winlog, LOG_ERROR, "CIOSocket::Write %x(%x) err=%d", this_->d.m_hSocket, this_, err);
        }
        this_->vtable->base.base.Release(this_, "ioc.cpp", 1126, ORT_IO_RETAIN, 0);
      }
    }
    unused = -1;
    result = unguard();
  }
  else
  {
    if ( !InterlockedDecrement(&buffer->m_nRefCount) )
    {
      CIOBuffer::Free(buffer1);
    }
    unused = -1;
    result = unguard();
  }
  return result;
}
// 4255B4: using guessed type wchar_t aIoc_cpp_0[8];
// 42D820: using guessed type int (__thiscall **off_42D820)(void *, char);

//----- (0040A3D0) --------------------------------------------------------
CIOServer *__thiscall CIOServer::DeletingDestructor(CIOServer *this, char a2)
{
  CIOServer *this_; // esi@1

  this_ = this;
  CIOServer::Destructor(this);
  if ( !(a2 & 1) )
  {
    return this_;
  }
  CLog::Add(&g_winlog, LOG_ERROR, L"Never Call Oprator Delete!!! CIOServer at file[%s], line[%d]", L"d:\\work\\l2\\server\\l2logd\\ioc.h", 476);
  CallStack::ReportCallStack();
  return this_;
}
// 424E68: using guessed type wchar_t aDWorkL2Serve_0[31];

//----- (0040A410) --------------------------------------------------------
CPacket *__thiscall CPacket::DeletingDestructor(CPacket *this, char a2)
{
  CPacket *v2; // esi@1

  v2 = this;
  CIOObject::Destructor((CIOObject *)this);
  if ( !(a2 & 1) )
  {
    return v2;
  }
  CLog::Add(&g_winlog, LOG_ERROR, L"Never Call Oprator Delete!!! CPacket at file[%s], line[%d]", L"d:\\work\\l2\\server\\l2logd\\ioc.h", 514);
  CallStack::ReportCallStack();
  return v2;
}
// 424E68: using guessed type wchar_t aDWorkL2Serve_0[31];

//----- (0040A450) --------------------------------------------------------
void __thiscall CIOObject::Destructor(CIOObject *this)
{
  this->vtable = (CIOObject_Vtable *)&MemoryObject_Vtable_off_424CC0;
}
// 424CC0: using guessed type void *MemoryObject_Vtable_off_424CC0;

//----- (0040A460) --------------------------------------------------------
int __thiscall CPacket::OnIOCallback(CPacket *this, BOOL bSuccess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped)
{
  CPacket *this_; // esi@1
  const unsigned __int8 *buff; // edi@1
  CLogSocket *logSocket; // ST0C_4@1
  CIOBuffer *buffer; // edi@3
  char v9; // [sp+20h] [bp-10h]@1
  int v10; // [sp+2Ch] [bp-4h]@1

  this_ = this;
  guard(&v9, L"void CPacket::OnIOCallback(BOOL bSuccess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped)");
  buff = &this_->d.m_pBuf->m_Buffer[dwTransferred];
  v10 = 0;
  guard(&dwTransferred, L"cpacket::oniocallback_funccall");
  logSocket = this_->d.m_pSocket;
  LOBYTE(v10) = 1;
  if ( this_->d.m_pFunc(logSocket, buff + 1) )
  {
    CIOSocket::Close((CIOSocket *)this_->d.m_pSocket);
  }
  LOBYTE(v10) = 0;
  unguard();
  ((void (__stdcall *)(const char *, signed int, ORTs, _DWORD))this_->d.m_pSocket->vtable->base.base.Release)("ioc.cpp", 1500, ORT_IO_RETAIN, 0);
  buffer = this_->d.m_pBuf;
  if ( !InterlockedDecrement(&buffer->m_nRefCount) )
  {
    CIOBuffer::Free(buffer);
  }
  InterlockedDecrement(&CPacket::g_nPendingPacket);
  this_->vtable->base.Release(this_, "ioc.cpp", 1505, ORT_CREATE_DELETE, 0);
  v10 = -1;
  return unguard();
}

//----- (0040A550) --------------------------------------------------------
_DWORD *__cdecl sub_40A550(_DWORD *a1, int a2, int a3, _DWORD *a4)
{
  int v4; // eax@1
  _DWORD *i; // ecx@1
  int v6; // esi@2
  _DWORD *result; // eax@3

  v4 = a3;
  for ( i = a4; v4 != a2; *i = v6 )
  {
    v6 = *(_DWORD *)(v4 - 4);
    v4 -= 4;
    --i;
  }
  result = a1;
  *a1 = i;
  return result;
}

//----- (0040A580) --------------------------------------------------------
_DWORD *__cdecl sub_40A580(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax@1

  for ( result = a1; result != a2; ++result )
  {
    *result = *a3;
  }
  return result;
}

//----- (0040A5A0) --------------------------------------------------------
int __cdecl sub_40A5A0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edi@2

  for ( result = a1; result != a2; *(_DWORD *)(v4 + 8) = *(_DWORD *)(a3 + 8) )
  {
    v4 = result;
    *(_DWORD *)result = *(_DWORD *)a3;
    *(_DWORD *)(result + 4) = *(_DWORD *)(a3 + 4);
    result += 12;
  }
  return result;
}

//----- (0040A5E0) --------------------------------------------------------
_DWORD *__cdecl sub_40A5E0(_DWORD *a1, int a2, int a3, int a4)
{
  sub_409C00(a1, a2, a3, a4);
  return a1;
}

//----- (0040A620) --------------------------------------------------------
int __cdecl std::vector_CIOTimer::_Ufill(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // ecx@2

  result = a2;
  if ( !a2 )
  {
    return result;
  }
  v4 = a2;
  result = a1;
  do
  {
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)a3;
      *(_DWORD *)(result + 4) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(result + 8) = *(_DWORD *)(a3 + 8);
    }
    result += 12;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (0040A660) --------------------------------------------------------
int __cdecl std::_Push_heap(std::vector_CIOTimer::iterator *_First, int _Hole, int _Top, int m_dwTime, int a5, int a6)
{
  int _Hole2; // ecx@1
  int i; // eax@1
  std::vector_CIOTimer::iterator *v8; // ecx@4
  int result; // eax@4

  _Hole2 = _Hole;
  for ( i = (_Hole - 1) / 2; _Top < _Hole2; i = (i - 1) / 2 )
  {
    if ( (signed __int32)(_First[i].value.m_dwTime - m_dwTime) <= 0 )// inlined operator less
    {
      break;
    }
    _First[_Hole2] = _First[i];
    _Hole2 = i;
  }
  v8 = &_First[_Hole2];
  result = a6;
  v8->value.m_dwTime = m_dwTime;
  v8->value.m_pObject = (CIOObject *)a5;
  v8->value.m_id = a6;
  return result;
}

//----- (0040A6D0) --------------------------------------------------------
int __cdecl std::pop_heap(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ecx@1
  int v7; // eax@1
  bool i; // zf@1
  int v9; // edx@4
  int v10; // ecx@4
  int v11; // eax@6
  int v12; // ecx@6

  v6 = a2;
  v7 = 2 * a2 + 2;
  for ( i = v7 == a3; v7 < a3; i = v7 == a3 )
  {
    if ( *(_DWORD *)(a1 + 12 * v7) - *(_DWORD *)(a1 + 12 * v7 - 12) > 0 )
    {
      --v7;
    }
    v9 = a1 + 12 * v7;
    v10 = a1 + 12 * v6;
    *(_DWORD *)v10 = *(_DWORD *)(a1 + 12 * v7);
    *(_DWORD *)(v10 + 4) = *(_DWORD *)(v9 + 4);
    *(_DWORD *)(v10 + 8) = *(_DWORD *)(v9 + 8);
    v6 = v7;
    v7 = 2 * v7 + 2;
  }
  if ( !i )
  {
    return std::_Push_heap((std::vector_CIOTimer::iterator *)a1, v6, a2, a4, a5, a6);
  }
  v11 = a1 + 12 * a3 - 12;
  v12 = a1 + 12 * v6;
  *(_DWORD *)v12 = *(_DWORD *)v11;
  *(_DWORD *)(v12 + 4) = *(_DWORD *)(v11 + 4);
  *(_DWORD *)(v12 + 8) = *(_DWORD *)(v11 + 8);
  v6 = a3 - 1;
  return std::_Push_heap((std::vector_CIOTimer::iterator *)a1, v6, a2, a4, a5, a6);
}

//----- (0040A780) --------------------------------------------------------
CIOSocket *__thiscall CIOSocket::DeletingDestructor(CIOSocket *this, char a2)
{
  CIOSocket *v2; // esi@1

  v2 = this;
  CIOSocket::Destructor(this);
  if ( !(a2 & 1) )
  {
    return v2;
  }
  CLog::Add(&g_winlog, LOG_ERROR, L"Never Call Oprator Delete!!! CIOSocket at file[%s], line[%d]", L"d:\\work\\l2\\server\\l2logd\\ioc.h", 359);
  CallStack::ReportCallStack();
  return v2;
}
// 424E68: using guessed type wchar_t aDWorkL2Serve_0[31];

//----- (0040A7C0) --------------------------------------------------------
int __thiscall CIOSocket::OnIOCallback(CIOSocket *this, BOOL bSuccess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped)
{
  CIOSocket *this_; // esi@1
  int result; // eax@4

  this_ = this;
  if ( bSuccess )
  {
    if ( lpOverlapped )
    {
      if ( lpOverlapped == &this->d.m_overlappedRead )
      {
        CIOSocket::ReadCallback(this, dwTransferred);
        result = this_->vtable->base.base.Release(this_, "ioc.cpp", 925, ORT_IO_RETAIN, 0);
      }
      else if ( lpOverlapped == &this->d.m_overlappedWrite )
      {
        CIOSocket::WriteCallback(this, dwTransferred);
        result = this_->vtable->base.base.Release(this_, "ioc.cpp", 930, ORT_IO_RETAIN, 0);
      }
      else
      {
        result = CLog::Add(&g_winlog, LOG_ERROR, L"[%s][%d] Invalid overlapped!!!", L"ioc.cpp", 934);
      }
    }
    else
    {
      this->vtable->base.OnTimer(dwTransferred);
      result = this_->vtable->base.base.Release(this_, "ioc.cpp", 920, ORT_TIMER, 0);
    }
  }
  else
  {
    if ( lpOverlapped == &this->d.m_overlappedRead )
    {
      CIOSocket::Close(this);
    }
    result = this_->vtable->base.base.Release(this_, "ioc.cpp", 915, ORT_IO_RETAIN, 0);
  }
  return result;
}
// 4255B4: using guessed type wchar_t aIoc_cpp_0[8];

//----- (0040A8A0) --------------------------------------------------------
_DWORD *__stdcall sub_40A8A0(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  return sub_409C40(a1, a2, a3);
}

//----- (0040A8D0) --------------------------------------------------------
int __stdcall sub_40A8D0(int a1, int a2, int a3)
{
  return sub_409C70(a1, a2, a3);
}

//----- (0040A900) --------------------------------------------------------
_DWORD *__stdcall sub_40A900(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  sub_4116C0(a1, a2, a3);
  return &a1[(_DWORD)a2];
}

//----- (0040A930) --------------------------------------------------------
int __stdcall sub_40A930(int a1, int a2, int a3)
{
  std::vector_CIOTimer::_Ufill(a1, a2, a3);
  return a1 + 12 * a2;
}

//----- (0040A960) --------------------------------------------------------
unsigned int __cdecl std::push_heap(int a1, int a2, int c)
{
  unsigned int result; // eax@1
  int v4; // edx@1

  result = (unsigned int)((unsigned __int64)(715827883i64 * (a2 - a1)) >> 32) >> 31;
  v4 = (a2 - a1) / 12;
  if ( v4 > 1 )
  {
    result = std::_Push_heap((std::vector_CIOTimer::iterator *)a1, v4 - 1, 0, *(_DWORD *)(a2 - 12), *(_DWORD *)(a2 - 12 + 4), *(_DWORD *)(a2 - 12 + 8));
  }
  return result;
}

//----- (0040A9C0) --------------------------------------------------------
void __thiscall std::vector_HANDLE::Destructor(std::vector_HANDLE *this)
{
  std::vector_HANDLE *this_; // esi@1

  this_ = this;
  if ( this->_First )
  {
    MMU::deallocate(&g_mmu, this->_First);
  }
  this_->_First = 0;
  this_->_Last = 0;
  this_->_End = 0;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (0040A9F0) --------------------------------------------------------
int __cdecl CIOObject::TimerDispatch()
{
  int tls; // eax@1
  int threadId; // eax@1
  std::priority_queue_CIOTimer *timerQueue; // edi@1
  CIOTimer *topTimer; // ecx@2
  std::vector_CIOTimer::iterator *last; // esi@3
  int id; // ebp@5
  CIOObject *object; // ebx@5
  char v7; // ST30_1@5
  std::vector_CIOTimer::iterator *v8; // eax@6
  std::vector_CIOTimer::iterator *v9; // edi@6
  int v10; // edx@6
  CIOObject *v11; // esi@6
  std::vector_CIOTimer::iterator *v12; // eax@7
  unsigned int v13; // edx@8
  DWORD tick; // [sp+10h] [bp-34h]@1
  std::priority_queue_CIOTimer *timerQueue2; // [sp+18h] [bp-2Ch]@1
  int id2; // [sp+1Ch] [bp-28h]@5
  CIOObject *object2; // [sp+20h] [bp-24h]@5
  int tls2; // [sp+24h] [bp-20h]@1
  char guard; // [sp+28h] [bp-1Ch]@1
  int v21; // [sp+34h] [bp-10h]@6
  int unused; // [sp+40h] [bp-4h]@1

  ::guard(&guard, L"void CIOObject::TimerDispatch(bool bRootLoop)");
  unused = 0;
  tick = GetTickCount();
  tls = *(_DWORD *)(__readfsdword(44) + 4 * TlsIndex);
  tls2 = tls;
  threadId = *(_DWORD *)(tls + 8);
  timerQueue = (std::priority_queue_CIOTimer *)(20 * threadId + 0x1BD3C38);// g_timerQueue[threadID];
  timerQueue2 = (std::priority_queue_CIOTimer *)(20 * threadId + 0x1BD3C38);
  while ( true )
  {
    topTimer = &timerQueue->c._First->value;    // inlined top
    if ( !topTimer )
    {
      break;
    }
    last = timerQueue->c._Last;
    if ( !((signed int)((char *)timerQueue->c._Last - (char *)topTimer) / 12) || topTimer->m_dwTime > tick )
    {
      break;
    }
    id = topTimer->m_id;
    object = topTimer->m_pObject;
    v7 = timerQueue->comp;
    id2 = topTimer->m_id;
    object2 = topTimer->m_pObject;              // std::queue::pop
    if ( ((char *)last - (char *)topTimer) / 12 > 1 )// inlined algorithm::pop
    {
      v8 = last - 1;
      v9 = last - 1;
      v10 = last[-1].value.m_dwTime;
      v11 = last[-1].value.m_pObject;
      v21 = v9->value.m_id;
      *v8 = (std::vector_CIOTimer::iterator)*topTimer;
      std::pop_heap((int)topTimer, 0, ((char *)v8 - (char *)topTimer) / 12, v10, (int)v11, v21);
      timerQueue = timerQueue2;
      id = id2;
      object = object2;
    }                                           // /inlined algorithm::pop
    v12 = timerQueue->c._First;                 // std::vector::pop_back
    if ( v12 )
    {
      v13 = (signed int)((unsigned __int64)(0x2AAAAAABi64 * (unsigned int)((char *)timerQueue->c._Last - (char *)v12)) >> 32) >> 1;
      if ( (v13 >> 31) + v13 )
      {
        --timerQueue->c._Last;
      }
    }                                           // /std::vector::pop_back
                                                // /std::queue::pop
    InterlockedDecrement(&CIOObject::s_objectInTimer);
    if ( *(_DWORD *)(tls2 + 8) == 12 )
    {
      object->vtable->OnTimerCallback(object, id);
    }
    else
    {
      ((void (__thiscall *)(CIOObject *, signed int, int, _DWORD))object->vtable->OnIOCallback)(object, 1, id, 0);
    }
  }
  unused = -1;
  return unguard();
}
// 1BD5478: using guessed type int TlsIndex;

//----- (0040ABB0) --------------------------------------------------------
void __noreturn Threads::WaitThread()
{
  signed int size2; // eax@2
  DWORD dwTick; // esi@5
  DWORD nMinNextTime; // edi@5
  DWORD nWait2; // edi@8
  DWORD size; // eax@13
  DWORD waitResult; // eax@15
  bool sleep; // [sp+13h] [bp-15h]@4
  char v7; // [sp+14h] [bp-14h]@6
  char v8; // [sp+18h] [bp-10h]@5
  int unused; // [sp+24h] [bp-4h]@5

  g_deadlock_checker.vtable->TimerExpired(&g_deadlock_checker, FALSE);// inlined Init
  if ( g_vHandle._First )
  {
    size2 = g_vHandle._Last - g_vHandle._First; // size == 0
  }
  else
  {
    size2 = 0;
  }
  sleep = size2 == FALSE;
  while ( 1 )
  {
    guard(&v8, L"unsigned __stdcall WaitThread(void *)");
    unused = FALSE;
    dwTick = GetTickCount();
    nMinNextTime = GetTickCount() + 10000;      // #define CIO_DEADLOCK_CHECKER_INTERVAL (5000)
    if ( dwTick > g_deadlock_checker.d.m_nLastTick + 180000 )
    {
      guard(&v7, L"!!! deadlock or super-lag detected !!!");
      LOBYTE(unused) = 1;
      GetTickCount();
      CLog::Add(&g_winlog, LOG_ERROR, L"!!! deadlock or super-lag detected!!!  (diff %d sec) ", (dwTick - g_deadlock_checker.d.m_nLastTick) / 1000);
      LOBYTE(v0) = 1;                           // CRASH - dereferencing 0 ptr: *(int*)0=1;
      LOBYTE(unused) = FALSE;
      unguard();
    }
    CIOObject::TimerDispatch();
    if ( nMinNextTime - GetTickCount() >= 100 )
    {
      nWait2 = 100;
    }
    else
    {
      nWait2 = nMinNextTime - GetTickCount();
    }
    if ( sleep )
    {
      Sleep(nWait2);
    }
    else
    {
      if ( g_vHandle._First )
      {
        size = g_vHandle._Last - g_vHandle._First;
      }
      else
      {
        size = 0;
      }
      waitResult = WaitForMultipleObjects(size, &g_vHandle._First->value, FALSE, nWait2);//  &g_vHandle[0]
      if ( g_vHandle._First && waitResult < g_vHandle._Last - g_vHandle._First )
      {
        g_vObject._First[waitResult].value->vtable->OnWaitCallback(g_vObject._First[waitResult].value);
      }
    }
    if ( *(_DWORD *)&Threads::g_bTerminating )
    {
      LOBYTE(v0) = 1;                           // CRASH
    }
    unused = -1;
    unguard();
  }
}

//----- (0040AD20) --------------------------------------------------------
void __cdecl __noreturn Threads::IOThread__common(int threadId)
{
  signed int ioBufferCount; // edi@1
  CIOBufferPool *pool; // esi@1
  signed int ioThreadNumber; // eax@2
  CIOBufferPool *pool2; // eax@2
  DWORD nextSyncTime; // eax@4
  HANDLE completionPort; // ebx@4
  DWORD nextSyncTime_; // edi@4
  unsigned int seed; // eax@4
  DWORD now; // eax@5
  DWORD waitTick; // esi@6
  BOOL success; // esi@8
  CIOObject *object; // [sp+10h] [bp-1Ch]@5
  char guard; // [sp+14h] [bp-18h]@5
  LPOVERLAPPED overlapped; // [sp+18h] [bp-14h]@8
  DWORD dwTransferred; // [sp+1Ch] [bp-10h]@8
  int unused; // [sp+28h] [bp-4h]@5

  ioBufferCount = GetPrivateProfileIntW(L"Setting", L"IOBufferCount", 20000, L".\\l2server.ini");
  pool = (CIOBufferPool *)operator new(24u);
  if ( pool )
  {
    ioThreadNumber = CThreadManager::GetMaxIOThreadNumber();
    pool2 = CIOBufferPool::CIOBufferPool(pool, ioBufferCount / ioThreadNumber);
  }
  else
  {
    pool2 = 0;
  }
  g_IOBufferPools[*(_DWORD *)(*(_DWORD *)(__readfsdword(44) + 4 * TlsIndex) + 8)] = pool2;
  nextSyncTime = GetTickCount();
  completionPort = IOCP::g_hCompletionPort;
  nextSyncTime_ = nextSyncTime;
  seed = time(0);
  srand(seed);
  while ( 1 )
  {
    ::guard(&guard, L"void IOThread_common(void *arglist)");
    unused = 0;
    object = 0;
    now = GetTickCount();
    if ( nextSyncTime_ >= now )
    {
      waitTick = nextSyncTime_ - now;
    }
    else
    {
      CIOObject::TimerDispatch();
      nextSyncTime_ = GetTickCount() + 50;      // volatile long g_nIocWait = 50;
      waitTick = 50;
    }
    InterlockedIncrement(&CReporter::g_nRunningThread);
    success = GetQueuedCompletionStatus(completionPort, &dwTransferred, (PULONG_PTR)&object, &overlapped, waitTick);
    InterlockedDecrement(&CReporter::g_nRunningThread);
    if ( success || overlapped || object )
    {
      object->vtable->OnIOCallback(success, dwTransferred, overlapped);
    }
    unused = -1;
    unguard();
  }
}
// 1BD5478: using guessed type int TlsIndex;

//----- (0040AE60) --------------------------------------------------------
void __cdecl __noreturn Threads::IOThread__mailing(void *arglist)
{
  Threads::IOThread__common(arglist);
}

//----- (0040AF00) --------------------------------------------------------
void __stdcall __noreturn Threads::IOThread(void *threadIndex)
{
  CThreadManager::RegisterThisThread((ThreadIndices)threadIndex);
  if ( Config::ExceptionMailing() )             // void IOThread_mailing(void *arglist)
                                                // {
                                                //     _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_DEBUG );
                                                //     _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );
                                                //     _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_DEBUG );
                                                // 
                                                //     _BEFORE
                                                //         IOThread_common(arglist);
                                                //     _AFTER_FIN  
                                                // }
                                                // 
                                                // 
                                                // void IOThread_debug(void *arglist)
                                                // {
                                                //     IOThread_common(arglist);
                                                // }
                                                // 
                                                // 
                                                // unsigned __stdcall IOThread(void *arglist)
                                                // {
                                                //     CThreadManager::RegisterThisThread((int)arglist);
                                                // 
                                                //     if (ExceptionMailing())
                                                //         IOThread_mailing(arglist);
                                                //     else
                                                //         IOThread_debug(arglist);
                                                // 
                                                //     return 0;
                                                // }
                                                // 
  {
    Threads::IOThread__mailing(threadIndex);
  }
  Threads::IOThread__debug(threadIndex);
}

//----- (0040AF40) --------------------------------------------------------
signed int __cdecl Threads::CreateIOThread(signed __int32 threadNumber)
{
  signed __int32 maxIOThread; // ebp@1
  signed int numberOfProcessors; // ebx@1
  int i; // esi@1
  HANDLE threadId; // edi@2
  char v6; // [sp+10h] [bp-34h]@1
  struct _SYSTEM_INFO systemInfo; // [sp+14h] [bp-30h]@1
  int v8; // [sp+40h] [bp-4h]@1

  guard(&v6, L"BOOL CreateIOThread(int nThread)");
  v8 = 0;
  *(_DWORD *)&Threads::g_bTerminating = 0;
  Threads::s_timer = CreateEventW(0u, 0, 0, 0u);
  IOCP::g_hCompletionPort = CreateIoCompletionPort((HANDLE)INVALID_HANDLE_VALUE, 0u, 0u, 0u);
  IOCP::g_hWorldCompletionPort = CreateIoCompletionPort((HANDLE)INVALID_HANDLE_VALUE, 0u, 0u, 0u);
  GetSystemInfo(&systemInfo);
  maxIOThread = threadNumber;
  numberOfProcessors = systemInfo.dwNumberOfProcessors;
  for ( i = 0; i < maxIOThread; ++i )
  {
    threadId = _beginthreadex(0, 0, (int)Threads::IOThread, i, 0, (LPDWORD)&threadNumber);
    CThreadManager::SetThread(i, threadId);
    SetThreadAffinityMask(threadId, 1 << i % numberOfProcessors);
  }
  v8 = -1;
  unguard();
  return 1;
}

//----- (0040B030) --------------------------------------------------------
void __noreturn sub_40B030()
{
  char v0; // [sp+0h] [bp-50h]@1
  char v1; // [sp+4h] [bp-4Ch]@1
  int v2; // [sp+14h] [bp-3Ch]@1
  int v3; // [sp+18h] [bp-38h]@1
  int (__thiscall **v4)(void *, char); // [sp+1Ch] [bp-34h]@1
  int v5; // [sp+4Ch] [bp-4h]@1

  v3 = 15;
  v2 = 0;
  v1 = 0;
  sub_405710((int)&v0, "vector<T> too long", strlen("vector<T> too long"));
  v5 = 0;
  sub_4057B0(&v4, (int)&v0);
  v4 = &std::length_error::`vftable';
  _CxxThrowException(&v4, &unk_42AC38);
}
// 413348: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 4293B4: using guessed type int (__thiscall *std::length_error::`vftable')(void *, char);

//----- (0040B0B0) --------------------------------------------------------
unsigned int __thiscall sub_40B0B0(void *this, _DWORD *a2, unsigned int a3, _DWORD *a4)
{
  int *v4; // esi@1
  _DWORD *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@2
  int v8; // ecx@6
  int v9; // ecx@11
  unsigned int v10; // eax@15
  int v11; // ecx@18
  int v12; // eax@22
  _DWORD *v13; // eax@25
  _DWORD *v14; // ebx@25
  _DWORD *v15; // eax@25
  _DWORD *v16; // edi@25
  _DWORD *v17; // ecx@25
  void *v18; // ecx@25
  int v19; // eax@26
  unsigned int v20; // edi@28
  _DWORD *v21; // ebx@31
  _DWORD *v22; // edi@31
  _DWORD *v23; // ecx@32
  int v24; // ebx@32
  int v25; // [sp-Ch] [bp-38h]@32
  _DWORD *v26; // [sp-8h] [bp-34h]@25
  _DWORD *v27; // [sp-4h] [bp-30h]@25
  int v28; // [sp+0h] [bp-2Ch]@1
  int *v29; // [sp+Ch] [bp-20h]@1
  _DWORD *v30; // [sp+10h] [bp-1Ch]@25
  unsigned int v31; // [sp+14h] [bp-18h]@25
  unsigned int v32; // [sp+18h] [bp-14h]@17
  int *v33; // [sp+1Ch] [bp-10h]@1
  int v34; // [sp+28h] [bp-4h]@25
  unsigned int v35; // [sp+34h] [bp+8h]@32
  unsigned int v36; // [sp+34h] [bp+8h]@33

  v4 = (int *)this;
  v5 = (_DWORD *)*a4;
  v6 = v4[1];
  v33 = &v28;
  v29 = v4;
  a4 = v5;
  if ( v6 )
  {
    result = (v4[3] - v6) >> 2;
  }
  else
  {
    result = 0;
  }
  if ( !a3 )
  {
    return result;
  }
  if ( v6 )
  {
    v8 = (v4[2] - v6) >> 2;
  }
  else
  {
    v8 = 0;
  }
  if ( 0x3FFFFFFF - v8 < a3 )
  {
    sub_40B030();
  }
  if ( v6 )
  {
    v9 = (v4[2] - v6) >> 2;
  }
  else
  {
    v9 = 0;
  }
  if ( result >= a3 + v9 )
  {
    v21 = (_DWORD *)v4[2];
    v22 = a2;
    if ( (v4[2] - (signed int)a2) >> 2 >= a3 )
    {
      v27 = (_DWORD *)v4[2];
      v36 = a3;
      a3 = (unsigned int)&v21[-a3];
      v4[2] = (int)sub_40A8A0((_DWORD *)a3, v21, v27);
      v29 = (int *)&v26;
      v26 = (_DWORD *)a3;
      a3 = (unsigned int)&v25;
      sub_40A550(&a3, (int)v22, (int)v26, v21);
      v27 = &a4;
      v26 = &v22[v36];
    }
    else
    {
      v35 = 4 * a3;
      v29 = &v25;
      sub_40A8A0(v22, v21, &v22[a3]);
      v23 = (_DWORD *)v4[2];
      v34 = 2;
      sub_40A900(v23, (_DWORD *)(a3 - (v23 - v22)), &a4);
      v24 = v35 + v4[2];
      v4[2] = v24;
      v27 = &a4;
      v26 = (_DWORD *)(v24 - v35);
    }
    a3 = (unsigned int)&v25;
    result = (unsigned int)sub_40A580(v22, v26, v27);
  }
  else
  {
    if ( 0x3FFFFFFF - (result >> 1) >= result )
    {
      v10 = (result >> 1) + result;
    }
    else
    {
      v10 = 0;
    }
    v32 = v10;
    if ( v6 )
    {
      v11 = (v4[2] - v6) >> 2;
    }
    else
    {
      v11 = 0;
    }
    if ( v10 < a3 + v11 )
    {
      if ( v6 )
      {
        v12 = (v4[2] - v6) >> 2;
      }
      else
      {
        v12 = 0;
      }
      v10 = a3 + v12;
      v32 = v10;
    }
    v31 = 4 * v10;
    v13 = Allocator::allocate(&g_mmu, 4 * v10, 0, &name);
    v27 = (_DWORD *)a3;
    v14 = v13;
    v15 = (_DWORD *)v4[1];
    v30 = v14;
    v34 = 0;
    v16 = sub_409C40(v15, a2, v14);
    v27 = (_DWORD *)a3;
    v26 = v4;
    sub_4116C0(v16, (_DWORD *)a3, &a4);
    v17 = (_DWORD *)v4[2];
    v27 = (_DWORD *)a3;
    v26 = v4;
    sub_409C40(a2, v17, &v16[a3]);
    v18 = (void *)v4[1];
    v34 = -1;
    if ( v18 )
    {
      v19 = (v4[2] - (signed int)v18) >> 2;
    }
    else
    {
      v19 = 0;
    }
    v20 = v19 + a3;
    if ( v18 )
    {
      MMU::deallocate(&g_mmu, v18);
    }
    result = (unsigned int)&v14[v20];
    v4[3] = (int)&v14[v31 / 4];
    v4[2] = result;
    v4[1] = (int)v14;
  }
  return result;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (0040B370) --------------------------------------------------------
int __thiscall sub_40B370(void *this, char *a2, unsigned int a3, int *a4)
{
  void *v4; // esi@1
  int v5; // ecx@1
  int v6; // ebx@1
  signed __int64 v7; // rax@1
  unsigned int v8; // ecx@2
  int v9; // edi@4
  int v10; // edx@6
  int v11; // edx@11
  unsigned int v12; // ecx@15
  int v13; // edx@18
  int v14; // eax@21
  int v15; // ebx@22
  void *v16; // eax@22
  int v17; // ecx@22
  int v18; // ecx@22
  void *v19; // ecx@22
  int v20; // edx@23
  int v21; // edi@25
  int v22; // ecx@28
  char *v23; // ebx@28
  unsigned int v24; // edx@28
  int v25; // ecx@29
  char *v26; // ecx@29
  char *v27; // edx@29
  unsigned int v28; // edi@30
  int v29; // eax@30
  char *v30; // edx@30
  int v32; // [sp-Ch] [bp-3Ch]@29
  int v33; // [sp-8h] [bp-38h]@22
  int *v34; // [sp-4h] [bp-34h]@22
  int v35; // [sp+0h] [bp-30h]@1
  int v36; // [sp+Ch] [bp-24h]@1
  int v37; // [sp+10h] [bp-20h]@1
  int v38; // [sp+14h] [bp-1Ch]@1
  void *v39; // [sp+18h] [bp-18h]@1
  int v40; // [sp+1Ch] [bp-14h]@22
  int *v41; // [sp+20h] [bp-10h]@1
  int v42; // [sp+2Ch] [bp-4h]@22

  v4 = this;
  v5 = *a4;
  HIDWORD(v7) = a4[1];
  v6 = *((_DWORD *)v4 + 1);
  LODWORD(v7) = a4[2];
  v41 = &v35;
  v39 = v4;
  v36 = v5;
  v37 = HIDWORD(v7);
  v38 = v7;
  if ( v6 )
  {
    v7 = 715827883i64 * (*((_DWORD *)v4 + 3) - v6);
    v8 = (HIDWORD(v7) >> 31) + (SHIDWORD(v7) >> 1);
  }
  else
  {
    v8 = 0;
  }
  v9 = a3;
  if ( !a3 )
  {
    return v7;
  }
  if ( v6 )
  {
    v10 = (*((_DWORD *)v4 + 2) - v6) / 12;
  }
  else
  {
    v10 = 0;
  }
  if ( 357913941 - v10 < a3 )
  {
    sub_40B030();
  }
  if ( v6 )
  {
    v11 = (*((_DWORD *)v4 + 2) - v6) / 12;
  }
  else
  {
    v11 = 0;
  }
  if ( v8 >= a3 + v11 )
  {
    v22 = *((_DWORD *)v4 + 2);
    v23 = a2;
    v24 = (*((_DWORD *)v4 + 2) - (signed int)a2) / 12;
    a4 = (int *)*((_DWORD *)v4 + 2);
    if ( v24 >= a3 )
    {
      v28 = 12 * a3;
      a2 = (char *)(v22 - 12 * a3);
      v29 = sub_40A8D0(v22 - 12 * a3, v22, v22);
      v30 = a2;
      *((_DWORD *)v4 + 2) = v29;
      v34 = a4;
      a3 = (unsigned int)&v34;
      a4 = &v33;
      a2 = (char *)&v32;
      sub_40A5E0(&a2, (int)v23, (int)v30, (int)v34);
      v34 = &v36;
      v33 = (int)&v23[v28];
    }
    else
    {
      a2 = (char *)(12 * a3);
      a4 = &v32;
      sub_40A8D0((int)v23, v22, (int)&v23[12 * a3]);
      v25 = *((_DWORD *)v4 + 2);
      v42 = 2;
      sub_40A930(v25, v9 - (v25 - (signed int)v23) / 12, (int)&v36);
      v26 = a2;
      v27 = &a2[*((_DWORD *)v4 + 2)];
      *((_DWORD *)v4 + 2) = v27;
      v34 = &v36;
      v33 = v27 - v26;
    }
    a2 = (char *)&v32;
    LODWORD(v7) = sub_40A5A0((int)v23, v33, (int)v34);
  }
  else
  {
    if ( 357913941 - (v8 >> 1) >= v8 )
    {
      v12 = (v8 >> 1) + v8;
    }
    else
    {
      v12 = 0;
    }
    a4 = (int *)v12;
    if ( v6 )
    {
      v13 = (*((_DWORD *)v4 + 2) - v6) / 12;
    }
    else
    {
      v13 = 0;
    }
    if ( v12 < a3 + v13 )
    {
      v14 = sub_4091D0((int)v4);
      v12 = v9 + v14;
      a4 = (int *)(v9 + v14);
    }
    v15 = 12 * v12;
    v16 = Allocator::allocate(&g_mmu, 12 * v12, 0, &name);
    v17 = *((_DWORD *)v4 + 1);
    a3 = (unsigned int)v16;
    v42 = 0;
    v33 = (int)v4;
    v40 = sub_409C70(v17, (int)a2, (int)v16);
    std::vector_CIOTimer::_Ufill(v40, v9, (int)&v36);
    v34 = (int *)a2;
    v18 = *((_DWORD *)v4 + 2);
    v33 = (int)v4;
    sub_409C70((int)a2, v18, v40 + 12 * v9);
    v19 = (void *)*((_DWORD *)v4 + 1);
    v42 = -1;
    if ( v19 )
    {
      v20 = (*((_DWORD *)v4 + 2) - (signed int)v19) / 12;
    }
    else
    {
      v20 = 0;
    }
    v21 = v20 + v9;
    if ( v19 )
    {
      MMU::deallocate(&g_mmu, v19);
    }
    LODWORD(v7) = a3;
    HIDWORD(v7) = a3 + 12 * v21;
    *((_DWORD *)v4 + 3) = a3 + v15;
    *(_QWORD *)((char *)v4 + 4) = v7;
  }
  return v7;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (0040B690) --------------------------------------------------------
_DWORD *__thiscall std::vector_CIOTimer::insert(int this, _DWORD *a2, char *a3, int *a4)
{
  int v4; // esi@1
  int v5; // edi@1
  int v6; // edi@3
  unsigned int v7; // edx@4
  _DWORD *result; // eax@5

  v4 = this;
  v5 = *(_DWORD *)(this + 4);
  if ( v5 && (*(_DWORD *)(this + 8) - v5) / 12 )
  {
    v7 = (signed int)((unsigned __int64)(0x2AAAAAABi64 * (signed int)&a3[-v5]) >> 32) >> 1;
    v6 = (v7 >> 31) + v7;
  }
  else
  {
    v6 = 0;
  }
  sub_40B370((void *)this, a3, 1u, a4);
  result = a2;
  *a2 = *(_DWORD *)(v4 + 4) + 12 * v6;
  return result;
}

//----- (0040B700) --------------------------------------------------------
_DWORD *__thiscall std::vector_HANDLE::push_back(std::vector_HANDLE *this, _DWORD *a2)
{
  std::vector_HANDLE *v2; // esi@1
  std::vector_HANDLE::iterator *v3; // edx@1
  unsigned int v4; // ecx@2
  std::vector_HANDLE::iterator *v5; // edi@6
  _DWORD *result; // eax@6

  v2 = this;
  v3 = this->_First;
  if ( v3 )
  {
    v4 = this->_Last - v3;
  }
  else
  {
    v4 = 0;
  }
  if ( v3 && v4 < v2->_End - v3 )
  {
    v5 = v2->_Last;
    result = sub_4116C0(&v2->_Last->value, (_DWORD *)1, a2);
    v2->_Last = v5 + 1;
  }
  else
  {
    result = (_DWORD *)sub_40B0B0(v2, &v2->_Last->value, 1u, a2);
  }
  return result;
}

//----- (0040B770) --------------------------------------------------------
std::vector_HANDLE *__thiscall std::vector_HANDLE::std::vector_HANDLE(std::vector_HANDLE *this)
{
  std::vector_HANDLE *result; // eax@1

  result = this;
  this->_First = 0;
  this->_Last = 0;
  this->_End = 0;
  return result;
}

//----- (0040B780) --------------------------------------------------------
_DWORD *__thiscall std::vector_CIOTimer::push_back(std::vector_CIOTimer *this, CIOTimer *timer)
{
  std::vector_CIOTimer *this_; // esi@1
  std::vector_CIOTimer::iterator *first; // edi@1
  unsigned int size_; // ebx@2
  unsigned int v5; // edx@5
  std::vector_CIOTimer::iterator *v6; // edi@6
  _DWORD *result; // eax@6

  this_ = this;
  first = this->_First;
  if ( first )
  {
    size_ = this->_Last - first;
  }
  else
  {
    size_ = 0;
  }
  if ( first && (v5 = (signed int)((unsigned __int64)(0x2AAAAAABi64 * (unsigned int)(this->_End - (void *)first)) >> 32) >> 1, size_ < (v5 >> 31) + v5) )
  {
    v6 = this->_Last;
    result = (_DWORD *)std::vector_CIOTimer::_Ufill((int)this->_Last, 1, (int)timer);
    this_->_Last = v6 + 1;
  }
  else
  {
    result = std::vector_CIOTimer::insert((int)this, &timer, (char *)this->_Last, (int *)timer);
  }
  return result;
}

//----- (0040B810) --------------------------------------------------------
MACRO_FALSE __thiscall CIOObject::RegisterWait(CIOObject *this, HANDLE handle)
{
  CIOObject *this_; // esi@1
  MACRO_FALSE result; // eax@3
  char v4; // [sp+4h] [bp-10h]@1
  int unused; // [sp+10h] [bp-4h]@1

  this_ = this;
  guard(&v4, L"BOOL CIOObject::RegisterWait(HANDLE handle)");
  unused = 0;
  CIOCriticalSection::Enter(&g_globalLockTimer, 0, 0);
  if ( g_vHandle._First && (unsigned int)(g_vHandle._Last - g_vHandle._First) >= 64 )// MAXIMUM_WAIT_OBJECTS == 64
  {
    CIOCriticalSection::Leave(&g_globalLockTimer, 0, 0);
    unused = -1;
    unguard();
    result = FALSE;
  }
  else
  {
    std::vector_HANDLE::push_back(&g_vHandle, &handle);
    handle = this_;
    std::vector_HANDLE::push_back((std::vector_HANDLE *)&g_vObject, &handle);
    CIOCriticalSection::Leave(&g_globalLockTimer, 0, 0);
    unused = -1;
    unguard();
    result = TRUE;
  }
  return result;
}

//----- (0040B900) --------------------------------------------------------
MACRO_FALSE __thiscall CIOServer::Create(CIOServer *this, int port)
{
  CIOServer *this_; // esi@1
  SOCKET socket; // eax@1
  int err1; // eax@2
  u_short v6; // ax@3
  SOCKET socket2; // ecx@3
  int err; // ST08_4@4
  int err2; // ST08_4@6
  HANDLE acceptEvent; // eax@7
  char v11; // [sp+4h] [bp-20h]@1
  sockaddr_in name; // [sp+8h] [bp-1Ch]@3
  int unused; // [sp+20h] [bp-4h]@1

  this_ = this;
  guard(&v11, L"BOOL CIOServer::Create(int nPort)");
  unused = 0;
  socket = ::socket(AF_INET, AF_UNIX, IPPROTO_IP);
  this_->m_d.m_hSocket = socket;
  if ( socket == INVALID_SOCKET )
  {
    err1 = WSAGetLastError();
    AddLog("socket error %d", err1);
    unused = -1;
    unguard();
    return FALSE;
  }
  name.sin_family = AF_INET;
  name.sin_addr.S_un.S_addr = htonl(INADDR_ANY);
  v6 = htons(port);
  socket2 = this_->m_d.m_hSocket;
  name.sin_port = v6;
  if ( bind(socket2, (const struct sockaddr *)&name, sizeof(sockaddr_in)) )
  {
    err = WSAGetLastError();
    AddLog("bind error %d", err);
fail:
    CIOServer::Close(this_);
    unused = -1;
    unguard();
    return FALSE;
  }
  if ( listen(this_->m_d.m_hSocket, 5) )
  {
    err2 = WSAGetLastError();
    AddLog("listen error %d", err2);
    goto fail;
  }
  acceptEvent = WSACreateEvent();
  this_->m_d.m_hAcceptEvent = acceptEvent;
  WSAEventSelect(this_->m_d.m_hSocket, acceptEvent, FD_ACCEPT);
  if ( CIOObject::RegisterWait((CIOObject *)this_, this_->m_d.m_hAcceptEvent) == FALSE )
  {
    AddLog("RegisterWait error on port %d", port);
    goto fail;
  }
  unused = -1;
  unguard();
  return TRUE;
}

//----- (0040BA70) --------------------------------------------------------
bool __thiscall CIOObject::AddTimer(CIOObject *this, unsigned int time, int id)
{
  CIOObject *this_; // edi@1
  unsigned int time2; // ebx@1
  bool v5; // sf@2
  unsigned __int8 v6; // of@2
  DWORD now; // eax@5
  int tls; // edx@5
  std::priority_queue_CIOTimer *prioQueue; // esi@5
  char v11; // [sp+Ch] [bp-1Ch]@1
  CIOTimer timer; // [sp+10h] [bp-18h]@5
  int unused; // [sp+24h] [bp-4h]@1

  this_ = this;
  guard(&v11, L"bool CIOObject::AddTimer(unsigned dwTime, int id)");
  time2 = time;
  unused = 0;
  if ( time < 80 )
  {
    v6 = __OFSUB__(s_count, 30);                // local static int
    v5 = s_count++ - 30 < 0;
    if ( v5 ^ v6 )
    {
      CLog::Add(&g_winlog, LOG_ERROR, L"dwTime[%d] < 80 !!!!!!!", time);
      CallStack::ReportCallStack();
    }
    time2 = 80;
  }
  InterlockedIncrement(&CIOObject::s_objectInTimer);
  this_->vtable->base.AddRef((MemoryObject *)this_, "ioc.cpp", 325, ORT_TIMER);
  now = GetTickCount();
  tls = *(_DWORD *)(__readfsdword(44) + 4 * TlsIndex);
  this_->m_d.base.m_inTimer = true;
  prioQueue = (std::priority_queue_CIOTimer *)(20 * *(_DWORD *)(tls + 8) + 0x1BD3C38);// g_timerQueue
  timer.m_dwTime = now + time2;
  timer.m_pObject = this_;
  timer.m_id = id;                              // inlinsed push
  std::vector_CIOTimer::push_back(&prioQueue->c, &timer);
  std::push_heap((int)prioQueue->c._First, (int)prioQueue->c._Last, prioQueue->comp);
  unused = -1;                                  // /inlinsed push
  unguard();
  return true;
}
// 1BD3E10: using guessed type int s_count;
// 1BD5478: using guessed type int TlsIndex;

//----- (0040BB90) --------------------------------------------------------
std::priority_queue_CIOTimer *__thiscall sub_40BB90(std::priority_queue_CIOTimer *this, _BYTE *a2, int a3)
{
  std::priority_queue_CIOTimer *result; // eax@1

  result = this;
  this->c._First = 0;
  this->c._Last = 0;
  this->c._End = 0;
  this->comp = *a2;
  return result;
}

//----- (0040BBB0) --------------------------------------------------------
bool __thiscall CIODeadlockChecker::TimerExpired(CIODeadlockChecker *this, int id)
{
  CIODeadlockChecker *this_; // esi@1

  this_ = this;
  CIOObject::SetShortTimeStamp(&this->d.m_nLastTick, 0);
  return CIOObject::AddTimer((CIOObject *)this_, 5000u, 0);// CIO_DEADLOCK_CHECKER_INTERVAL = 5 * 1000
}

//----- (0040BBE0) --------------------------------------------------------
std::priority_queue_CIOTimer *__thiscall std::priority_queue::priority_queue(std::priority_queue_CIOTimer *this)
{
  std::priority_queue_CIOTimer *this_; // [sp-2h] [bp-4h]@1

  this_ = this;
  return sub_40BB90(this, (_BYTE *)&this_ + 3, (int)&this_ + 3);
}

//----- (0040BC00) --------------------------------------------------------
CIOCriticalSection *__thiscall CIOCriticalSection::CIOCriticalSection(CIOCriticalSection *this)
{
  CIOCriticalSection *this_; // esi@1
  char v3; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v3, L"CIOCriticalSection::CIOCriticalSection()");
  InitializeCriticalSection(&this_->m_criticalSection);
  this_->m_bActive = false;
  unguard();
  return this_;
}

//----- (0040BC30) --------------------------------------------------------
CIOCriticalSection *__thiscall CIOCriticalSection::CIOCriticalSection2(CIOCriticalSection *this, DWORD spinCount)
{
  CIOCriticalSection *this_; // esi@1
  char v4; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v4, L"CIOCriticalSection::CIOCriticalSection(DWORD dwSpinCount)");
  InitializeCriticalSectionAndSpinCount(&this_->m_criticalSection, spinCount);
  this_->m_bActive = 0;
  unguard();
  return this_;
}

//----- (0040BC70) --------------------------------------------------------
int __thiscall CIOCriticalSection::Destructor(CIOCriticalSection *this)
{
  CIOCriticalSection *this_; // esi@1
  char v3; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v3, L"CIOCriticalSection::~CIOCriticalSection()");
  DeleteCriticalSection(&this_->m_criticalSection);
  return unguard();
}

//----- (0040BCA0) --------------------------------------------------------
void __thiscall CIOCriticalSection::Enter(CIOCriticalSection *this, const wchar_t *lockName, int line)
{
  CIOCriticalSection *this_; // esi@1
  int line_2; // ecx@1
  const wchar_t *lockName_1; // eax@3

  this_ = this;
  line_2 = line;
  if ( !line )
  {
    line_2 = (int)this_;
  }
  lockName_1 = lockName;
  if ( !lockName )
  {
    lockName_1 = L"CriticalSection Lock";
  }
  LockStack::Push(&LockStack::g_stacks[*(_DWORD *)(*(_DWORD *)(__readfsdword(0x2C) + 4 * TlsIndex) + 8)], 0, 0, lockName_1, line_2);
  EnterCriticalSection(&this_->m_criticalSection);
  this_->m_bActive = true;
}
// 425D4C: using guessed type wchar_t aCriticalsectio[21];
// 1BD5478: using guessed type int TlsIndex;

//----- (0040BD00) --------------------------------------------------------
void __thiscall CIOCriticalSection::Leave(CIOCriticalSection *this, const wchar_t *unlockName, int line)
{
  CIOCriticalSection *this_; // esi@1
  int unlocker_; // ecx@1
  const wchar_t *unlockName_; // eax@3

  this_ = this;
  unlocker_ = line;
  this_->m_bActive = 0;
  if ( !line )
  {
    unlocker_ = (int)this_;
  }
  unlockName_ = unlockName;
  if ( !unlockName )
  {
    unlockName_ = L"CriticalSection Unlock";
  }
  LockStack::Pop(&LockStack::g_stacks[*(_DWORD *)(*(_DWORD *)(__readfsdword(44) + 4 * TlsIndex) + 8)], 0, 0, unlockName_, unlocker_);
  LeaveCriticalSection(&this_->m_criticalSection);
}
// 425D78: using guessed type wchar_t aCriticalsect_0[23];
// 1BD5478: using guessed type int TlsIndex;

//----- (0040BDE0) --------------------------------------------------------
int __thiscall CLog::Set(CLog *this, HWND logWnd)
{
  CLog *this_; // esi@1
  char v4; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v4, L"CLog::Set");
  this_->m_window = logWnd;
  return unguard();
}

//----- (0040BE10) --------------------------------------------------------
CHAR *__usercall Utils::UnicodeToMultibyte@<eax>(const WCHAR *wideMsg1@<ebx>)
{
  int newLength; // esi@1
  CHAR *multiByte; // edi@1
  char v4; // [sp+Ch] [bp-4h]@1

  guard(&v4, L"UnicodeToMultibyte");
  newLength = WideCharToMultiByte(CP_ACP, 0, wideMsg1, -1, 0, 0, 0, 0);
  GetLastError();
  multiByte = (CHAR *)malloc(newLength + 1);
  WideCharToMultiByte(CP_ACP, 0, wideMsg1, -1, multiByte, newLength, 0, 0);
  multiByte[newLength - 1] = 0;
  unguard();
  return multiByte;
}

//----- (0040BE80) --------------------------------------------------------
bool __thiscall CLog::CanAppend(CLog *this, int nYear, int nMonth, int nDay, int nHour, int nHalf)
{
  bool result; // al@1

  result = true;
  if ( this->m_createNewFile == true )
  {
    result = false;
  }
  else if ( nHalf != this->m_half || this->m_hour != nHour || this->m_year != nYear || this->m_month != nMonth || this->m_day != nDay )
  {
    result = false;
  }
  return result;
}

//----- (0040BEF0) --------------------------------------------------------
void __thiscall CLog::LockBuffer(CLog *this, int bufferIndex)
{
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 8 * (3 * bufferIndex + 18)));
}

//----- (0040BF10) --------------------------------------------------------
void __thiscall CLog::UnlockBuffer(CLog *this, int bufferIndex)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 8 * (3 * bufferIndex + 18)));
}

//----- (0040BF30) --------------------------------------------------------
int __thiscall CLog::Redraw(CLog *this)
{
  CLog *this_; // esi@1
  int result; // eax@2
  HDC hdc; // ebx@3
  HGDIOBJ font; // eax@4
  LONG y; // ebp@4
  int currLine; // edi@4
  LONG lineHeight; // eax@7
  LONG right; // edx@7
  HBRUSH brush; // ST10_4@7
  LogEntry *outputBuffer; // eax@7
  int currLine1; // edi@7
  int currLine3; // edi@7
  LogEntry *logEntry; // eax@7
  char v14; // [sp+4h] [bp-64h]@1
  int currLine2; // [sp+8h] [bp-60h]@6
  RECT rc; // [sp+Ch] [bp-5Ch]@7
  struct tagPAINTSTRUCT Paint; // [sp+1Ch] [bp-4Ch]@3
  int unused; // [sp+64h] [bp-4h]@2

  this_ = this;
  guard(&v14, L"CLog::Redraw");
  if ( this_->m_enabled )
  {
    GetClientRect(this_->m_window, &this_->m_loginWndRect);
    hdc = BeginPaint(this_->m_window, &Paint);
    if ( this_->m_font )
    {
      SelectObject(hdc, this_->m_font);
      y = this_->m_loginWndRect.bottom;
      currLine = this_->m_currentLine;
    }
    else
    {
      font = GetStockObject(SYSTEM_FIXED_FONT);
      this_->m_font = font;
      SelectObject(hdc, font);
      this_->m_brush = (int)GetStockObject(WHITE_BRUSH);
      GetTextExtentPoint32W(hdc, L"H", 1, &this_->m_textSize);
      y = this_->m_loginWndRect.bottom;
      currLine = this_->m_currentLine;
    }
    while ( 1 )
    {
      lineHeight = this_->m_textSize.cy;
      right = this_->m_loginWndRect.right;
      y -= lineHeight;
      rc.bottom = y + lineHeight;
      brush = (HBRUSH)this_->m_brush;
      rc.left = 0;
      rc.right = right;
      rc.top = y;
      FillRect(hdc, &rc, brush);
      outputBuffer = this_->m_outputBuffer;
      currLine1 = (this_->m_bufferLength - 1) & (currLine - 1);
      currLine2 = currLine1;
      currLine3 = currLine1;
      logEntry = &outputBuffer[currLine3];
      if ( logEntry != (LogEntry *)-4 )
      {
        SetTextColor(hdc, color[logEntry->logType]);
        TextOutW(hdc, 0, y, this_->m_outputBuffer[currLine3].log, this_->m_outputBuffer[currLine3].logSize);
      }
      if ( y < 0 )
      {
        break;
      }
      currLine = currLine2;
    }
    EndPaint(this_->m_window, &Paint);
    unused = -1;
    result = unguard();
  }
  else
  {
    unused = -1;
    result = unguard();
  }
  return result;
}

//----- (0040C0A0) --------------------------------------------------------
int __thiscall CLog::Enable(CLog *this, bool enable)
{
  CLog *this_; // esi@1
  char v4; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v4, L"CLog::Enable");
  this_->m_enabled = enable;
  if ( enable )
  {
    InvalidateRect(this_->m_window, 0, 0);
  }
  return unguard();
}

//----- (0040C0E0) --------------------------------------------------------
int __thiscall CLog::Sendable(CLog *this, bool sendable)
{
  CLog *this_; // esi@1
  char v4; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v4, L"void CLog::Sendable(bool flag)");
  this_->m_sendable = sendable;
  return unguard();
}

//----- (0040C110) --------------------------------------------------------
int __thiscall CLog::FlushLogFile(CLog *this)
{
  CLog *this_; // esi@1
  HANDLE *fileBuffer; // esi@1
  signed int buffersCount; // edi@1
  char v5; // [sp+Ch] [bp-8h]@1
  DWORD written; // [sp+10h] [bp-4h]@1

  this_ = this;
  guard(&v5, L"CLog::FlushLogFile");
  WriteFile(this_->m_fileBuffers[FileBuffers_Error], "\nException occured. Flush Flush!!!\n", strlen("\nException occured. Flush Flush!!!\n"), &written, 0);
  fileBuffer = this_->m_fileBuffers;
  buffersCount = 8;
  do
  {
    FlushFileBuffers(*fileBuffer);
    ++fileBuffer;
    --buffersCount;
  }
  while ( buffersCount );
  return unguard();
}

//----- (0040C180) --------------------------------------------------------
int __thiscall CLog::CreateNewLogFile(CLog *this, int nYear, int nMonth, int nDay, int nHour, int nHalf)
{
  CLog *this_; // esi@1
  int result; // eax@2
  wchar_t **logCategory; // ebp@10
  HANDLE *fileBuffer; // edi@10
  struct _RTL_CRITICAL_SECTION *bufferLock; // [sp+4h] [bp-280h]@10
  FileName *fileNameIterator; // [sp+8h] [bp-27Ch]@10
  char v12; // [sp+Ch] [bp-278h]@1
  DWORD fileSize; // [sp+10h] [bp-274h]@12
  wchar_t pathName[50]; // [sp+14h] [bp-270h]@14
  wchar_t fileName[256]; // [sp+78h] [bp-20Ch]@10
  int unused; // [sp+280h] [bp-4h]@2

  this_ = this;
  guard(&v12, L"void CLog::CreateNewLogFile(int nYear, int nMonth, int nDay, int nHour, int nHalf )");
  if ( (this_->m_logComponent & 0x80000000) == 0 )
  {
    if ( this_->m_createNewFile == true || nHalf != this_->m_half || this_->m_hour != nHour || this_->m_year != nYear || this_->m_month != nMonth || this_->m_day != nDay )
    {
      fileName[0] = 0;
      memset(&fileName[1], 0, 508u);
      fileName[255] = 0;
      this_->m_year = nYear;
      this_->m_half = nHalf;
      this_->m_day = nDay;
      this_->m_hour = nHour;
      this_->m_month = nMonth;
      this_->m_createNewFile = false;
      logCategory = CLog::s_logCategories;
      bufferLock = this_->m_bufferLocks;
      fileBuffer = this_->m_fileBuffers;
      fileNameIterator = this_->m_fileNames;
      do
      {
        EnterCriticalSection(bufferLock);
        if ( *fileBuffer != (HANDLE)INVALID_HANDLE_VALUE )
        {
          FlushFileBuffers(*fileBuffer);
          fileSize = GetFileSize(*fileBuffer, 0);
          CloseHandle(*fileBuffer);
          if ( !fileSize )
          {
            DeleteFileW(fileNameIterator->path);
          }
        }
        swprintf(fileName, L"log\\%s\\%04d-%02d-%02d-100%02d-%02d-%s-%s%d.log", *logCategory, this_->m_year, this_->m_month, this_->m_day, this_->m_hour, this_->m_worldID, CLog::s_logComponents[this_->m_logComponent], *logCategory, this_->m_half);
        CreateDirectoryW(L"log", 0);
        wsprintfW(pathName, L"log\\%s", *logCategory);
        CreateDirectoryW(pathName, 0);
        *fileBuffer = CreateFileW(fileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        wcscpy(fileNameIterator->path, fileName);
        if ( *fileBuffer != (HANDLE)INVALID_HANDLE_VALUE )
        {
          SetFilePointer(*fileBuffer, 0, 0, FILE_END);
        }
        LeaveCriticalSection(bufferLock);
        ++bufferLock;
        ++logCategory;
        ++fileBuffer;
        ++fileNameIterator;
      }
      while ( (signed int)logCategory < (signed int)CLogSocket::s_packetHandlers );// check real offset here
      unused = -1;
      result = unguard();
    }
    else
    {
      unused = -1;
      result = unguard();
    }
  }
  else
  {
    unused = -1;
    result = unguard();
  }
  return result;
}

//----- (0040C3F0) --------------------------------------------------------
void __noreturn CLogCli::Job()
{
  while ( 1 )
  {
    CLogCli::Init(&g_cliLog);
    SuspendThread(g_winlog.m_logThreadId);
  }
}

//----- (0040C420) --------------------------------------------------------
void __noreturn Threads::CliLogThread_mailing()
{
  CLogCli::Job();                               //  INLINED COMMON
}

//----- (0040C4C0) --------------------------------------------------------
int __thiscall CLog::AddV(CLog *this, LogType severity, const char *format, va_list params)
{
  CLog *this_; // esi@1
  int tls; // eax@1
  int threadIndex; // edx@1
  int funcCount; // ecx@1
  int msgLength; // ebx@5
  char *msg; // eax@6
  unsigned int msgIndex; // ecx@6
  char msgEnd; // dl@7
  int hour; // eax@15
  int half; // ST28_4@15
  int month; // edx@15
  int day; // ST20_4@15
  int year; // ST18_4@15
  CHAR *cliMessage; // edi@16
  bool invalidateWindow; // [sp+13h] [bp-1CE5h]@3
  DWORD bytesWritten; // [sp+14h] [bp-1CE4h]@8
  struct _SYSTEMTIME systemTime; // [sp+18h] [bp-1CE0h]@12
  char v22; // [sp+28h] [bp-1CD0h]@1
  int tls2; // [sp+2Ch] [bp-1CCCh]@1
  char messageBuff[1000]; // [sp+30h] [bp-1CC8h]@3
  wchar_t cliBuffer[2176]; // [sp+418h] [bp-18E0h]@13
  wchar_t messageBuffW[1000]; // [sp+1518h] [bp-7E0h]@3
  DWORD written; // [sp+1CF4h] [bp-4h]@1

  this_ = this;
  guard(&v22, L"CLog::AddV");
  tls = *(_DWORD *)(__readfsdword(44) + 4 * TlsIndex);
  threadIndex = *(_DWORD *)(tls + 8);
  funcCount = CLog::s_stackSizes[threadIndex] + 1;
  written = 0;
  tls2 = tls;
  CLog::s_stackSizes[threadIndex] = funcCount;
  LOBYTE(written) = 1;
  if ( funcCount <= 1 && this_->m_outputBuffer && (messageBuff[0] = 0, memset(&messageBuff[1], 0, 996u), *(_WORD *)&messageBuff[997] = 0, messageBuff[999] = 0, messageBuffW[0] = 0, memset(&messageBuffW[1], 0, 1996u), messageBuffW[999] = 0, invalidateWindow = false, severity != LOG_UNKNOWN) )
  {
    msgLength = vsprintf(messageBuff, format, params);
    if ( msgLength > 0 )
    {
      msg = messageBuff;
      msgIndex = 0;
      do
      {
        msgEnd = *msg++;
      }
      while ( msgEnd );
      bytesWritten = msg - &messageBuff[1];
      if ( msg != &messageBuff[1] )
      {
        do
        {
          messageBuffW[msgIndex] = messageBuff[msgIndex];
          ++msgIndex;
        }
        while ( msgIndex < strlen(messageBuff) );
      }
      messageBuffW[msgIndex] = 0;
      if ( severity < LOG_UNKNOWN )
      {
        EnterCriticalSection(&this_->m_criticalSection);
        this_->m_outputBuffer[this_->m_currentLine].logType = severity;
        wcscpy(this_->m_outputBuffer[this_->m_currentLine].log, messageBuffW);
        this_->m_outputBuffer[this_->m_currentLine].logSize = msgLength;
        this_->m_currentLine = (this_->m_currentLine + 1) & (this_->m_bufferLength - 1);
        LeaveCriticalSection(&this_->m_criticalSection);
        invalidateWindow = true;
      }
      GetLocalTime(&systemTime);
      if ( this_->m_sendable )
      {
        cliBuffer[0] = 0;
        memset(&cliBuffer[1], 0, 0x10FCu);
        cliBuffer[2175] = 0;
        swprintf(cliBuffer, L"%02d/%02d/%04d %02d:%02d:%02d.%03d, %s\r\n", systemTime.wMonth, systemTime.wDay, systemTime.wYear, systemTime.wHour, systemTime.wMinute, systemTime.wSecond, systemTime.wMilliseconds, messageBuffW);
        CLogCli::LogSendMsg(&g_cliLog, severity, cliBuffer);
      }
      else
      {
        if ( !CLog::CanAppend(this_, systemTime.wYear, systemTime.wMonth, systemTime.wDay, systemTime.wHour, systemTime.wMinute >= 30u) )
        {
          EnterCriticalSection(&this_->m_criticalSection);
          hour = systemTime.wHour;
          half = systemTime.wMinute >= 30u;
          month = systemTime.wMonth;
          this_->m_worldID = Config::s_worldId;
          day = systemTime.wDay;
          year = systemTime.wYear;
          this_->m_logComponent = ServerType_LogD;
          CLog::CreateNewLogFile(this_, year, month, day, hour, half);
          LeaveCriticalSection(&this_->m_criticalSection);
        }
        LOBYTE(cliBuffer[0]) = 0;
        memset((char *)cliBuffer + 1, 0, 2172u);
        *(wchar_t *)((char *)&cliBuffer[1086] + 1) = 0;
        HIBYTE(cliBuffer[1087]) = 0;
        cliMessage = Utils::UnicodeToMultibyte(messageBuffW);
        sprintf((char *)cliBuffer, "%02d/%02d/%04d %02d:%02d:%02d.%03d, %s\r\n", systemTime.wMonth, systemTime.wDay, systemTime.wYear, systemTime.wHour, systemTime.wMinute, systemTime.wSecond, systemTime.wMilliseconds, cliMessage);
        free(cliMessage);
        switch ( severity )
        {
          case LOG_IN:
            CLog::LockBuffer(this_, FileBuffers_In);
            WriteFile(this_->m_fileBuffers[FileBuffers_In], cliBuffer, strlen((const char *)cliBuffer), &bytesWritten, 0);
            CLog::UnlockBuffer(this_, FileBuffers_In);
            break;
          case LOG_DB:
            CLog::LockBuffer(this_, FileBuffers_Db);
            WriteFile(this_->m_fileBuffers[FileBuffers_Db], cliBuffer, strlen((const char *)cliBuffer), &bytesWritten, 0);
            CLog::UnlockBuffer(this_, FileBuffers_Db);
            break;
          case LOG_AUDIT:
            CLog::LockBuffer(this_, FileBuffers_Audit);
            WriteFile(this_->m_fileBuffers[FileBuffers_Audit], cliBuffer, strlen((const char *)cliBuffer), &bytesWritten, 0);
            CLog::UnlockBuffer(this_, FileBuffers_Audit);
            break;
          case LOG_ERROR:
            CLog::LockBuffer(this_, FileBuffers_Error);
            WriteFile(this_->m_fileBuffers[FileBuffers_Error], cliBuffer, strlen((const char *)cliBuffer), &bytesWritten, 0);
            CLog::UnlockBuffer(this_, FileBuffers_Error);
            break;
          case LOG_CHAT:
            CLog::LockBuffer(this_, FileBuffers_Chat);
            WriteFile(this_->m_fileBuffers[FileBuffers_Chat], cliBuffer, strlen((const char *)cliBuffer), &bytesWritten, 0);
            CLog::UnlockBuffer(this_, FileBuffers_Chat);
            break;
          default:
            EnterCriticalSection(this_->m_bufferLocks);
            WriteFile(this_->m_fileBuffers[FileBuffers_System], cliBuffer, strlen((const char *)cliBuffer), &bytesWritten, 0);
            LeaveCriticalSection(this_->m_bufferLocks);
            break;
        }
      }
      if ( this_->m_enabled && invalidateWindow )
      {
        InvalidateRect(this_->m_window, 0, 0);
      }
    }
    --CLog::s_stackSizes[*(_DWORD *)(tls2 + 8)];
  }
  else
  {
    CLog::s_stackSizes[threadIndex] = funcCount - 1;
  }
  written = -1;
  return unguard();
}
// 1BD5478: using guessed type int TlsIndex;

//----- (0040CA10) --------------------------------------------------------
int __thiscall CLog::AddVW(CLog *this, LogType severity, const wchar_t *format, va_list params)
{
  CLog *this_; // esi@1
  int tls; // eax@1
  int threadIndex; // eax@1
  int funcCount; // ebx@1
  int funcCount2; // ecx@1
  int msgLength; // edi@4
  int half; // ST28_4@10
  int month; // eax@10
  int hour; // ST24_4@10
  int year; // ecx@10
  int day; // ST20_4@10
  CHAR *message; // edi@11
  char invalidateWindow; // [sp+Fh] [bp-1901h]@4
  DWORD bytesWritten; // [sp+10h] [bp-1900h]@4
  struct _SYSTEMTIME systemTime; // [sp+14h] [bp-18FCh]@7
  char guard_; // [sp+24h] [bp-18ECh]@1
  int msgLength2; // [sp+28h] [bp-18E8h]@4
  int tls2; // [sp+2Ch] [bp-18E4h]@1
  wchar_t msg[2176]; // [sp+30h] [bp-18E0h]@8
  wchar_t messageBuff[1000]; // [sp+1130h] [bp-7E0h]@4
  int written; // [sp+190Ch] [bp-4h]@1

  this_ = this;
  guard(&guard_, L"CLog::AddV");
  tls = *(_DWORD *)(__readfsdword(44) + 4 * TlsIndex);
  tls2 = tls;
  threadIndex = *(_DWORD *)(tls + 8);
  funcCount = CLog::s_stackSizes[threadIndex] + 1;
  written = 0;
  CLog::s_stackSizes[threadIndex] = funcCount;
  funcCount2 = funcCount;
  LOBYTE(written) = 1;
  if ( funcCount <= 1 && this_->m_outputBuffer && severity != LOG_UNKNOWN )
  {
    messageBuff[0] = 0;
    memset(&messageBuff[1], 0, 1996u);
    messageBuff[999] = 0;
    invalidateWindow = 0;
    guard(&bytesWritten, L"Log::AddV - vswprintf");
    msgLength = vswprintf(messageBuff, format, params);
    msgLength2 = msgLength;
    unguard();
    if ( msgLength > 0 )
    {
      if ( severity < LOG_UNKNOWN )
      {
        EnterCriticalSection(&this_->m_criticalSection);
        this_->m_outputBuffer[this_->m_currentLine].logType = severity;
        wcscpy(this_->m_outputBuffer[this_->m_currentLine].log, messageBuff);
        this_->m_outputBuffer[this_->m_currentLine].logSize = msgLength2;
        this_->m_currentLine = (this_->m_currentLine + 1) & (this_->m_bufferLength - 1);
        LeaveCriticalSection(&this_->m_criticalSection);
        invalidateWindow = true;
      }
      GetLocalTime(&systemTime);
      if ( this_->m_sendable )
      {
        msg[0] = 0;
        memset(&msg[1], 0, 0x10FCu);
        msg[2175] = 0;
        swprintf(msg, L"%02d/%02d/%04d %02d:%02d:%02d.%03d, %s\r\n", systemTime.wMonth, systemTime.wDay, systemTime.wYear, systemTime.wHour, systemTime.wMinute, systemTime.wSecond, systemTime.wMilliseconds, messageBuff);
        CLogCli::LogSendMsg(&g_cliLog, severity, msg);
      }
      else
      {
        if ( !CLog::CanAppend(this_, systemTime.wYear, systemTime.wMonth, systemTime.wDay, systemTime.wHour, systemTime.wMinute >= 30u) )
        {
          EnterCriticalSection(&this_->m_criticalSection);
          half = systemTime.wMinute >= 30u;
          month = systemTime.wMonth;
          hour = systemTime.wHour;
          year = systemTime.wYear;
          this_->m_worldID = Config::s_worldId;
          day = systemTime.wDay;
          this_->m_logComponent = ServerType_LogD;
          CLog::CreateNewLogFile(this_, year, month, day, hour, half);
          LeaveCriticalSection(&this_->m_criticalSection);
        }
        LOBYTE(msg[0]) = 0;
        memset((char *)msg + 1, 0, 0x87Cu);
        *(wchar_t *)((char *)&msg[1086] + 1) = 0;
        HIBYTE(msg[1087]) = 0;
        message = Utils::UnicodeToMultibyte(messageBuff);
        sprintf((char *)msg, "%02d/%02d/%04d %02d:%02d:%02d.%03d, %s\r\n", systemTime.wMonth, systemTime.wDay, systemTime.wYear, systemTime.wHour, systemTime.wMinute, systemTime.wSecond, systemTime.wMilliseconds, message);
        free(message);
        switch ( severity )
        {
          case LOG_IN:
            CLog::LockBuffer(this_, FileBuffers_In);
            WriteFile(this_->m_fileBuffers[FileBuffers_In], msg, strlen((const char *)msg), &bytesWritten, 0);
            CLog::UnlockBuffer(this_, FileBuffers_In);
            break;
          case LOG_DB:
            CLog::LockBuffer(this_, FileBuffers_Db);
            WriteFile(this_->m_fileBuffers[FileBuffers_Db], msg, strlen((const char *)msg), &bytesWritten, 0);
            CLog::UnlockBuffer(this_, FileBuffers_Db);
            break;
          case LOG_AUDIT:
            CLog::LockBuffer(this_, FileBuffers_Audit);
            WriteFile(this_->m_fileBuffers[FileBuffers_Audit], msg, strlen((const char *)msg), &bytesWritten, 0);
            CLog::UnlockBuffer(this_, FileBuffers_Audit);
            break;
          case LOG_ERROR:
            CLog::LockBuffer(this_, FileBuffers_Error);
            WriteFile(this_->m_fileBuffers[FileBuffers_Error], msg, strlen((const char *)msg), &bytesWritten, 0);
            CLog::UnlockBuffer(this_, FileBuffers_Error);
            break;
          case LOG_CHAT:
            CLog::LockBuffer(this_, FileBuffers_Chat);
            WriteFile(this_->m_fileBuffers[FileBuffers_Chat], msg, strlen((const char *)msg), &bytesWritten, 0);
            CLog::UnlockBuffer(this_, FileBuffers_Chat);
            break;
          default:
            CLog::LockBuffer(this_, FileBuffers_System);
            WriteFile(this_->m_fileBuffers[FileBuffers_System], msg, strlen((const char *)msg), &bytesWritten, 0);
            CLog::UnlockBuffer(this_, FileBuffers_System);
            break;
        }
      }
      if ( this_->m_enabled && invalidateWindow )
      {
        InvalidateRect(this_->m_window, 0, 0);
      }
    }
    threadIndex = *(_DWORD *)(tls2 + 8);
    funcCount2 = CLog::s_stackSizes[threadIndex];
  }
  CLog::s_stackSizes[threadIndex] = funcCount2 - 1;
  written = -1;
  return unguard();
}
// 1BD5478: using guessed type int TlsIndex;

//----- (0040CEC0) --------------------------------------------------------
void __stdcall __noreturn Threads::CliLogThread(int a1)
{
  CIOBufferPool *pool; // eax@1
  CIOBufferPool *pool2; // eax@2

  CThreadManager::RegisterThisThread(ThreadIndex_Log);
  pool = (CIOBufferPool *)operator new(sizeof(CIOBufferPool));
  if ( pool )
  {
    pool2 = CIOBufferPool::CIOBufferPool(pool, 50);
  }
  else
  {
    pool2 = 0;
  }
  g_IOBufferPools[*(_DWORD *)(*(_DWORD *)(__readfsdword(44) + 4 * TlsIndex) + 8)] = pool2;
  if ( Config::ExceptionMailing() )
  {
    Threads::CliLogThread_mailing();
  }
  Threads::CliLogThread_common();
}
// 1BD5478: using guessed type int TlsIndex;

//----- (0040CF20) --------------------------------------------------------
CLog *__thiscall CLog::CLog(CLog *this, int size)
{
  CLog *this_; // esi@1
  LogEntry *logEntries; // eax@1
  wchar_t *logEntryText; // ecx@3
  int i; // edx@3
  LogEntry *logEntries2; // edi@5
  HANDLE logThreadId; // eax@7
  struct _RTL_CRITICAL_SECTION *bufferLocks; // ebp@7
  HANDLE *fileBuffers; // edi@7
  char v11; // [sp+10h] [bp-10h]@1
  LogComponent unused; // [sp+1Ch] [bp-4h]@1
  FileBuffers buffersCount; // [sp+24h] [bp+4h]@7

  this_ = this;
  guard(&v11, L"CLog::CLog");
  unused = 0;
  this_->m_bufferLength = size;
  logEntries = (LogEntry *)operator new(sizeof(LogEntry) * size);
  if ( logEntries )
  {
    if ( size - 1 >= 0 )
    {
      logEntryText = logEntries->log;           // TODO: probably some optimization iteration. Fix it
      i = size;
      do
      {
        *logEntryText = 0;
        logEntryText += 1004;
        --i;
      }
      while ( i );
    }
    logEntries2 = logEntries;
  }
  else
  {
    logEntries2 = 0;
  }
  this_->m_outputBuffer = logEntries2;
  memset(logEntries2, 0, sizeof(LogEntry) * size);
  this_->m_currentLine = 0;
  this_->m_font = 0;
  this_->m_enabled = 0;
  this_->m_sendable = 0;
  this_->m_enabled3 = 0;
  InitializeCriticalSection(&this_->m_criticalSection);
  logThreadId = _beginthreadex(0u, 0u, (int)Threads::CliLogThread, 0, CREATE_SUSPENDED, &this_->m_threadAddr);
  this_->m_logThreadId = logThreadId;
  CThreadManager::SetThread(ThreadIndex_Log, logThreadId);
  bufferLocks = this_->m_bufferLocks;
  fileBuffers = this_->m_fileBuffers;
  buffersCount = FileBuffers_BuffersCount;
  do
  {
    *fileBuffers = (HANDLE)-1;
    InitializeCriticalSection(bufferLocks);
    ++fileBuffers;
    ++bufferLocks;
    --buffersCount;
  }
  while ( buffersCount );
  this_->m_createNewFile = 1;
  this_->m_month = 0;
  this_->m_day = 0;
  this_->m_hour = 0;
  this_->m_half = 0;
  this_->m_worldID = 0;
  this_->m_logComponent = ServerType_Unset;
  memset(this_->m_fileNames, 0, sizeof(this_->m_fileNames));
  unused = ServerType_Unset;
  unguard();
  return this_;
}

//----- (0040D060) --------------------------------------------------------
int CLog::Add_Ansi(CLog *this, LogType severity, const char *format, ...)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-10h]@1
  int v6; // [sp+Ch] [bp-4h]@1
  va_list va; // [sp+20h] [bp+10h]@1

  va_start(va, format);
  v5 = v3;
  guard(&v5, L"CLog::Add");
  v6 = 0;
  CLog::AddV(this, severity, format, va);
  v6 = -1;
  return unguard();
}

//----- (0040D0D0) --------------------------------------------------------
int CLog::Add(CLog *this, LogType severity, const wchar_t *format, ...)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-10h]@1
  int v6; // [sp+Ch] [bp-4h]@1
  va_list va; // [sp+20h] [bp+10h]@1

  va_start(va, format);
  v5 = v3;
  guard(&v5, L"CLog::Add");
  v6 = 0;
  CLog::AddVW(this, severity, format, va);
  v6 = -1;
  return unguard();
}

//----- (0040D140) --------------------------------------------------------
void *__cdecl CLogSocket::operator_new(int size)
{
  void *memory; // esi@1
  int nAlloc; // eax@1

  memory = Allocator::allocate(&g_mmu, size, 1, L"CLogSocket");
  InterlockedIncrement((volatile LONG *)(4 * CLogSocket::s_nAlloc + 0x455E50));
  nAlloc = CLogSocket::s_nAlloc;
  Allocator::g_allocatedObjName[CLogSocket::s_nAlloc] = "CLogSocket";
  Allocator::g_allocatedMemory[nAlloc] = sizeof(CLogSocket);
  return memory;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (0040D190) --------------------------------------------------------
int CLogSocket::operator_delete()
{
  CLog::Add(&g_winlog, LOG_ERROR, L"Never Call Oprator Delete!!! CLogSocket at file[%s], line[%d]", L"d:\\work\\l2\\server\\l2logd\\logSocket.h", 21);
  return CallStack::ReportCallStack();
}
// 4261E0: using guessed type wchar_t aDWorkL2Serve_4[37];

//----- (0040D1B0) --------------------------------------------------------
CLogCli *__thiscall CLogCli::CLogCli(CLogCli *this)
{
  CLogCli *this_; // esi@1
  char v3; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v3, L"CLogCli::CLogCli()");
  this_->m_logSocket = NULL;
  InitializeCriticalSection(&this_->m_lock);
  unguard();
  return this_;
}

//----- (0040D1F0) --------------------------------------------------------
bool __thiscall CLogCli::Connect(CLogCli *this)
{
  CLogCli *this_; // edi@1
  SOCKET socket; // esi@1
  bool result; // al@2
  void *memory; // eax@3
  CLogSocket *logSocket; // eax@4
  char v6; // [sp+8h] [bp-24h]@1
  void *v7; // [sp+Ch] [bp-20h]@3
  sockaddr_in name; // [sp+10h] [bp-1Ch]@1
  int unused; // [sp+28h] [bp-4h]@1

  this_ = this;
  guard(&v6, L"bool CLogCli::Connect()");
  unused = 0;
  socket = ::socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
  name.sin_family = AF_INET;
  name.sin_addr = Config::s_ipAddr;
  name.sin_port = htons(Config::s_port);
  if ( connect(socket, (const struct sockaddr *)&name, sizeof(sockaddr_in)) == SOCKET_ERROR )
  {
    closesocket(socket);
    CLog::Add(&g_winlog, LOG_ERROR, L"Can't connect to log server");
    unused = -1;
    unguard();
    result = 0;
  }
  else
  {
    CLog::Add(&g_winlog, 0, L"Connected to log server");
    memory = CLogSocket::operator_new(sizeof(CLogSocket));// in-place new for CLogSocket
    v7 = memory;
    LOBYTE(unused) = 1;
    if ( memory )
    {
      logSocket = CLogSocket::CLogSocket((CLogSocket *)memory, socket, CLogSocket::s_packetHandlers);
    }
    else
    {
      logSocket = 0;
    }
    LOBYTE(unused) = 0;
    g_cliLog.m_logSocket = logSocket;
    CIOSocket::Initialize((CIOSocket *)logSocket);
    CLogSocket::Send(this_->m_logSocket, "cd", LogD_SetCheckStatus, 1);
    CLogSocket::Send(this_->m_logSocket, "cdd", LogD_ServerStarted, Config::s_worldId, ServerType_LogD);
    unused = -1;
    unguard();
    result = 1;
  }
  return result;
}

//----- (0040D350) --------------------------------------------------------
int __thiscall CLogCli::LogSendMsg(CLogCli *this, LogType logType, const wchar_t *msg)
{
  CLogCli *this_; // esi@1
  CLogSocket *socket; // ST00_4@1
  char v6; // [sp+4h] [bp-10h]@1
  int unused; // [sp+10h] [bp-4h]@1

  this_ = this;
  guard(&v6, L"void CLogCli::LogSendMsg(LogType nLogType, WCHAR* szSendMsg)");
  socket = this_->m_logSocket;
  unused = 0;
  CLogSocket::Send(socket, "cddS", 0, 5, logType, msg);
  unused = -1;
  return unguard();
}

//----- (0040D3C0) --------------------------------------------------------
bool __thiscall CLogCli::Init(CLogCli *this)
{
  CLogCli *this_; // esi@1
  struct _RTL_CRITICAL_SECTION *lock; // edi@1
  bool result_1; // bl@1

  this_ = this;
  lock = &this->m_lock;
  EnterCriticalSection(&this->m_lock);
  result_1 = true;
  if ( !g_winlog.m_sendable )
  {
    CLog::Add(&g_winlog, 0, L"CLogCli::Init()  Connect()");
    result_1 = CLogCli::Connect(this_);
    if ( result_1 )
    {
      CLog::Sendable(&g_winlog, true);
      LeaveCriticalSection(lock);
      return result_1;
    }
    CLog::Sendable(&g_winlog, false);
  }
  LeaveCriticalSection(lock);
  return result_1;
}

//----- (0040D430) --------------------------------------------------------
bool __cdecl CLogSocket::packet0_SendMsg(CLogSocket *socket, const unsigned __int8 *packet)
{
  int v2; // ecx@0
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  guard(&v4, L"static bool LogSendMsgPacket(CLogSocket *socket, const unsigned char *packet)");
  unguard();
  return 0;
}

//----- (0040D450) --------------------------------------------------------
bool __cdecl CLogSocket::packet1_CheckStatus(CLogSocket *socket, const unsigned __int8 *packet)
{
  char v3; // [sp+0h] [bp-14h]@1
  char status; // [sp+4h] [bp-10h]@1
  int v5; // [sp+10h] [bp-4h]@1

  guard(&v3, L"static bool LogCheckStatus(CLogSocket *socket, const unsigned char *packet)");
  v5 = 0;
  PacketUtils::Disassemble(packet, L"d", &status);
  v5 = -1;
  unguard();
  return 0;
}

//----- (0040D4C0) --------------------------------------------------------
bool __cdecl CLogSocket::packet2_TestPacket(CLogSocket *socket, const unsigned __int8 *packet)
{
  int v2; // ecx@0
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  guard(&v4, L"static bool LogTestPacket(CLogSocket *socket, const unsigned char *packet)");
  unguard();
  return 0;
}

//----- (0040D4E0) --------------------------------------------------------
CLogSocket *__thiscall CLogSocket::CLogSocket(CLogSocket *this, SOCKET socket, bool (__cdecl **packetTable)(CLogSocket *, const unsigned __int8 *))
{
  SOCKET socket1; // edi@1
  CLogSocket *this_; // esi@1
  bool (__cdecl **packetHandlers)(CLogSocket *, const unsigned __int8 *); // eax@1

  socket1 = socket;
  this_ = this;
  CIOSocket::CIOSocket((CIOSocket *)this, socket);
  this_->vtable = (CIOSocket_Vtable *)&CLogSocket_vtable_426588;
  guard(&socket, L"CLogSocket::CLogSocket(SOCKET s, LogPacketFunc *aPacketTable) : CIOSocket(s)");
  packetHandlers = packetTable;
  this_->d.m_socket = socket1;
  this_->d.field_2 = 0;
  this_->d.m_packetHandlers = packetHandlers;
  this_->d.m_status = 0;                        // SocketStatus
  this_->d.m_packetSize = 0;
  unguard();
  return this_;
}

//----- (0040D560) --------------------------------------------------------
int __thiscall CLogSocket::Destructor(CLogSocket *this)
{
  this->vtable = (CIOSocket_Vtable *)&CLogSocket_vtable_426588;
  return CIOSocket::Destructor((CIOSocket *)this);
}

//----- (0040D570) --------------------------------------------------------
int __thiscall CLogSocket::OnClose(CLogSocket *this)
{
  CLogSocket *this_; // esi@1
  char v3; // [sp+4h] [bp-10h]@1
  int v4; // [sp+10h] [bp-4h]@1

  this_ = this;
  guard(&v3, L"void CLogSocket::OnClose()");
  v4 = 0;
  CLog::Sendable(&g_winlog, 0);
  CLog::Add(&g_winlog, LOG_NORMAL, L"CLogSocket Close %x(%x)", this_->d.m_socket, this_);
  v4 = -1;
  return unguard();
}

//----- (0040D5F0) --------------------------------------------------------
int CLogSocket::Send(CLogSocket *this, const char *format, ...)
{
  bool closed; // zf@1
  int result; // eax@2
  _DWORD *buffer; // eax@3
  CIOBuffer *buffer1; // esi@4
  int payloadSize; // eax@6
  int payloadSize2; // ebx@6
  char v8; // [sp+4h] [bp-10h]@1
  int unused; // [sp+10h] [bp-4h]@1
  va_list va; // [sp+20h] [bp+Ch]@1

  va_start(va, format);
  guard(&v8, L"void CLogSocket::Send(const char* format, ...)");
  closed = this->d.m_status == SocketStatus_Closed;
  unused = 0;
  if ( closed )
  {
    unused = -1;
    result = unguard();
  }
  else
  {
    buffer = operator new(sizeof(CIOBuffer));
    LOBYTE(unused) = 1;
    if ( buffer )
    {
      buffer1 = CIOBuffer::CIOBuffer(buffer);
    }
    else
    {
      buffer1 = 0;
    }
    LOBYTE(unused) = 0;
    payloadSize = PacketUtils::VAssemble((char *)&buffer1->m_Buffer[2], 8190, format, va);
    payloadSize2 = payloadSize;
    if ( payloadSize )
    {
      payloadSize2 = payloadSize + 2;
      buffer1->m_Buffer[0] = payloadSize + 2;
      buffer1->m_Buffer[1] = BYTE1(payloadSize2);
    }
    else
    {
      CLog::Add(&g_winlog, LOG_ERROR, L"%d: assemble too large packet. format %s", socket, format);
    }
    buffer1->m_dwSize = payloadSize2;
    CIOSocket::Write((CIOSocket *)this, buffer1);
    unused = -1;
    result = unguard();
  }
  return result;
}

//----- (0040D700) --------------------------------------------------------
LONG __thiscall CLogSocket::Release(CLogSocket *this, const char *file, int line, int nWorkType, bool flag)
{
  CLogSocket *this_; // esi@1
  LONG refCount; // eax@1
  LONG readBuf2; // edi@1
  LONG result; // eax@5

  this_ = this;
  refCount = InterlockedDecrement(&this->d.base.base.base.m_nRefCount);
  readBuf2 = refCount;
  if ( refCount > 0 )
  {
    return readBuf2;
  }
  if ( refCount )
  {
    if ( refCount > -1 )
    {
      return readBuf2;
    }
    CLog::Add_Ansi(&g_winlog, LOG_ERROR, "Invalid Memory (%d) on CLogSocket(%d)", refCount, this_->d.base.base.base.m_identity);
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "           Caller : file[%s], line[%d]", file, line);
    }
    MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
    CallStack::ReportCallStack();
    return readBuf2;
  }
  if ( this_->d.base.base.base.m_inTimer )
  {
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![CLogSocket] at file[%s], line[%d]", file, line);
      MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * CLogSocket::s_nAlloc + 0x455E50));
      result = readBuf2;
    }
    else
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![CLogSocket]");
      MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * CLogSocket::s_nAlloc + 0x455E50));
      result = readBuf2;
    }
  }
  else
  {
    this_->vtable->base.base.DeletingDestructor(this_, 0);
    MMU::deallocate(&g_mmu, this_);
    InterlockedDecrement((volatile LONG *)(4 * CLogSocket::s_nAlloc + 0x455E50));
    result = readBuf2;
  }
  return result;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (0040D830) --------------------------------------------------------
CLogSocket *__thiscall CLogSocket::DeletingDestructor(CLogSocket *this, char a2)
{
  CLogSocket *v2; // esi@1

  v2 = this;
  CLogSocket::Destructor(this);
  if ( !(a2 & 1) )
  {
    return v2;
  }
  CLog::Add(&g_winlog, LOG_ERROR, L"Never Call Oprator Delete!!! CLogSocket at file[%s], line[%d]", L"d:\\work\\l2\\server\\l2logd\\logSocket.h", 21);
  CallStack::ReportCallStack();
  return v2;
}
// 4261E0: using guessed type wchar_t aDWorkL2Serve_4[37];

//----- (0040D870) --------------------------------------------------------
int __thiscall CLogSocket::OnRead(CLogSocket *this)
{
  CLogSocket *this_; // esi@1
  CIOBuffer *readBuf; // edx@1
  SocketStatus status; // eax@1
  int readBufSize; // ecx@1
  signed __int32 readBytes; // edi@1
  SocketStatus status_1; // eax@4
  int payloadSize; // eax@6
  CPacket *packet; // ebp@12
  volatile __int32 nAlloc; // eax@12
  CIOBuffer *readBuf3; // ecx@15
  CIOSocket_Vtable *this_2; // edx@15
  char v13; // [sp+Ch] [bp-1Ch]@1
  CIOBuffer *readBuf2; // [sp+10h] [bp-18h]@1
  int readBufSize2; // [sp+14h] [bp-14h]@1
  CPacket *v16; // [sp+18h] [bp-10h]@12
  int unused; // [sp+24h] [bp-4h]@1

  this_ = this;
  guard(&v13, L"void CLogSocket::OnRead()");
  readBuf = this_->d.base.m_pReadBuf;
  status = this_->d.m_status;
  readBufSize = readBuf->m_dwSize;
  readBytes = 0;
  unused = 0;
  readBuf2 = readBuf;
  readBufSize2 = readBufSize;
  if ( status == SocketStatus_Closed )
  {
    CIOSocket::Close((CIOSocket *)this_);
    unused = -1;
    return unguard();
  }
  if ( readBufSize <= 0 )
  {
LABEL_17:
    CIOSocket::Read((CIOSocket *)this_, 0);
    goto LABEL_21;
  }
  while ( true )
  {
    status_1 = this_->d.m_status;
    if ( status_1 )
    {
      break;
    }
    if ( readBytes + 2 > readBufSize )
    {
      goto LABEL_23;
    }
    payloadSize = (readBuf->m_Buffer[readBytes + 1] << 8) + readBuf->m_Buffer[readBytes] - 2;
    this_->d.m_packetSize = payloadSize;
    if ( payloadSize <= 0 || payloadSize > 0x2000 )
    {
      CLog::Add(&g_winlog, LOG_ERROR, L"dbsocket %d: bad packet size %d", socket, payloadSize);
      goto LABEL_19;
    }
    readBytes += 2;
    this_->d.m_status = SocketStatus_BytesRead;
LABEL_16:
    if ( readBytes >= readBufSize )
    {
      goto LABEL_17;
    }
  }
  if ( status_1 != SocketStatus_BytesRead )
  {
    goto LABEL_20;
  }
  if ( readBytes + this_->d.m_packetSize <= readBufSize )
  {
    if ( readBuf->m_Buffer[readBytes] < 3u )
    {
      packet = (CPacket *)Allocator::allocate(&g_mmu, sizeof(CPacket), 1, L"CPacket");
      InterlockedIncrement((volatile LONG *)(4 * CPacket::s_nAlloc + 0x455E50));
      nAlloc = CPacket::s_nAlloc;
      Allocator::g_allocatedObjName[CPacket::s_nAlloc] = "CPacket";
      Allocator::g_allocatedMemory[nAlloc] = sizeof(CPacket);
      v16 = packet;
      LOBYTE(unused) = 1;
      if ( packet )
      {
        MemoryObject::MemoryObject((MemoryObject *)packet);// INLINE CTOR
        packet->vtable = (CIOObject_Vtable *)&CLogPacket_vtable_425334;
      }
      else
      {
        packet = 0;
      }
      readBuf3 = readBuf2;
      packet->d.m_pSocket = this_;
      packet->d.m_pBuf = this_->d.base.m_pReadBuf;
      packet->d.m_pFunc = this_->d.m_packetHandlers[readBuf3->m_Buffer[readBytes]];
      this_2 = this_->vtable;
      LOBYTE(unused) = 0;
      this_2->base.base.AddRef((MemoryObject *)this_, "logsocket.cpp", 155, ORT_IO_RETAIN);
      InterlockedIncrement(&this_->d.base.m_pReadBuf->m_nRefCount);// INLINE
      InterlockedIncrement(&CPacket::g_nPendingPacket);
      packet->vtable->PostObject((CIOObject *)packet, readBytes);
      readBuf = readBuf2;
      readBufSize = readBufSize2;
      readBytes += this_->d.m_packetSize;
      this_->d.m_status = SocketStatus_Init;
      goto LABEL_16;
    }
    CLog::Add(&g_winlog, LOG_ERROR, L"unknown protocol %d", readBuf->m_Buffer[readBytes]);
LABEL_19:
    this_->d.m_status = SocketStatus_Closed;
LABEL_20:
    CIOSocket::Close((CIOSocket *)this_);
    goto LABEL_21;
  }
LABEL_23:
  CIOSocket::Read((CIOSocket *)this_, readBufSize - readBytes);
LABEL_21:
  unused = -1;
  return unguard();
}
// 425334: using guessed type void *CLogPacket_vtable_425334;
// 1BD3B5C: using guessed type int g_mmu;

//----- (0040DAB0) --------------------------------------------------------
MemoryObject *__thiscall MemoryObject::MemoryObject(MemoryObject *this)
{
  MemoryObject *this_; // esi@1
  char v3; // [sp+4h] [bp-4h]@1

  this_ = this;
  this->vtable = (MemoryObject_Vtable *)&MemoryObject_Vtable_off_424CC0;
  guard(&v3, L"MemoryObject::MemoryObject()");
  this_->m_d.m_inTimer = 0;
  this_->m_d.m_nRefCount = 0;
  this_->m_d.m_identity = InterlockedIncrement(&MemoryObject::s_instances);
  MemoryObject::AddRef(this_, "obj.cpp", 67, ORT_CREATE_DELETE);
  unguard();
  return this_;
}
// 424CC0: using guessed type void *MemoryObject_Vtable_off_424CC0;

//----- (0040DB00) --------------------------------------------------------
int __thiscall MemoryObject::ReportOrt(MemoryObject *this, int a2, int a3)
{
  MemoryObject *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  guard(&this_, L"void MemoryObject::ReportOrt()");
  return unguard();
}

//----- (0040DB20) --------------------------------------------------------
LONG __thiscall MemoryObject::Release(MemoryObject *this, const char *file, int line, int nWorkType, bool flag)
{
  MemoryObject *this_; // esi@1
  LONG refCount; // eax@1
  LONG refCount_; // edi@1
  LONG result; // eax@5

  this_ = this;
  refCount = InterlockedDecrement(&this->m_d.m_nRefCount);
  refCount_ = refCount;
  if ( refCount > 0 )
  {
    return refCount_;
  }
  if ( refCount )
  {
    if ( refCount > -1 )
    {
      return refCount_;
    }
    CLog::Add_Ansi(&g_winlog, LOG_ERROR, "Invalid Memory (%d) on MemoryObject(%d)", refCount, this_->m_d.m_identity);
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "           Caller : file[%s], line[%d]", file, line);
    }
    MemoryObject::ReportOrt(this_, 0, 0);
    CallStack::ReportCallStack();
    return refCount_;
  }
  if ( this_->m_d.m_inTimer )
  {
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![MemoryObject] at file[%s], line[%d]", file, line);
      MemoryObject::ReportOrt(this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * MemoryObject::s_nAlloc + 0x455E50));
      result = refCount_;
    }
    else
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![MemoryObject]");
      MemoryObject::ReportOrt(this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * MemoryObject::s_nAlloc + 0x455E50));
      result = refCount_;
    }
  }
  else
  {
    this_->vtable->DeletingDestructor(this_, 0);
    MMU::deallocate(&g_mmu, this_);
    InterlockedDecrement((volatile LONG *)(4 * MemoryObject::s_nAlloc + 0x455E50));
    result = refCount_;
  }
  return result;
}
// 1BD3B5C: using guessed type int g_mmu;
// 1BD4FC8: using guessed type int MemoryObject::s_nAlloc;

//----- (0040DC50) --------------------------------------------------------
PerfMonitor *__thiscall PerfMonitor::PerfMonitor(PerfMonitor *this)
{
  PerfMonitor *this_; // esi@1

  this_ = this;
  this->m_checkPerformance = 0;
  this->m_memUsage = 0;
  this->m_processId = 0;
  this->m_memoryLoad = 0;
  this->m_availablePhysMemory = 0;
  this->m_totalPhysMemory = 0;
  this->m_physicallyUsedMemory = 0;
  this->m_counterElements = 0;
  this->m_pdhCountersNumber = 0;
  this->m_pdhCounters = 0;
  this->m_initialized = 0;
  this->m_interval = 0;
  this->m_startTime = time(0u);
  return this_;
}

//----- (0040DC90) --------------------------------------------------------
bool __thiscall PerfMonitor::Init(PerfMonitor *this)
{
  PerfMonitor *this_; // ebx@1
  int pdhCountersNumber; // eax@2
  PDH_HCOUNTER *pdhCounters; // eax@3
  PDH_STATUS pdhResult; // eax@4
  int i; // esi@7
  signed int elementIndex; // ebp@7
  wchar_t *counterTitle; // edi@8
  wchar_t *counterObjectName; // edi@8
  wchar_t *counterInstanceName; // edi@8
  wchar_t *counterName; // edi@8
  CounterElement *counterElements; // eax@8
  PDH_STATUS pdhStatus; // eax@8
  PDH_STATUS pdhStatus2; // eax@9
  int i2; // [sp+14h] [bp-43Ch]@7
  DWORD bufferSize; // [sp+18h] [bp-438h]@8
  WCHAR fileName[14]; // [sp+1Ch] [bp-434h]@1
  PDH_COUNTER_PATH_ELEMENTS_W counterPathElements; // [sp+38h] [bp-418h]@8
  WCHAR keyName[256]; // [sp+50h] [bp-400h]@8
  WCHAR fullPathBuffer[256]; // [sp+250h] [bp-200h]@8

  this_ = this;
  qmemcpy(fileName, L".\\perfmon.ini", sizeof(fileName));
  this->m_checkPerformance = GetPrivateProfileIntW(L"PerfMon", L"CheckPerfMon", 0, fileName);
  this_->m_pdhCountersNumber = GetPrivateProfileIntW(L"PerfMon", L"Count", 0, fileName);
  this_->m_interval = GetPrivateProfileIntW(L"PerfMon", L"Interval", 6000, fileName);
  this_->m_memUsage = GetPrivateProfileIntW(L"PerfMon", L"Memusage", 0, fileName);
  if ( !this_->m_checkPerformance )
  {
    return false;
  }
  this_->m_processId = GetCurrentProcessId();
  pdhCountersNumber = this_->m_pdhCountersNumber;
  if ( pdhCountersNumber < 1 )
  {
    return true;
  }
  pdhCounters = (PDH_HCOUNTER *)operator new(4 * pdhCountersNumber);
  this_->m_pdhCounters = pdhCounters;
  if ( !pdhCounters )
  {
    return false;
  }
  pdhResult = PdhOpenQueryW(0, 0, &this_->m_pdhQuery);
  if ( !pdhResult )
  {
    this_->m_counterElements = (CounterElement *)operator new(0x7FC * this_->m_pdhCountersNumber);
    if ( this_->m_pdhCountersNumber > 0 )
    {
      i2 = 0;
      i = 0;
      elementIndex = 1;
      while ( true )
      {
        counterTitle = this_->m_counterElements[i].title;
        memset(counterTitle, 0, 508u);
        counterTitle[254] = 0;
        counterObjectName = this_->m_counterElements[i].counterName;// TODO: fix me! objectName
        memset(counterObjectName, 0, 508u);
        counterObjectName[254] = 0;
        counterInstanceName = this_->m_counterElements[i].instanceName;
        memset(counterInstanceName, 0, 508u);
        counterInstanceName[254] = 0;
        counterName = this_->m_counterElements[i].counterName;
        memset(counterName, 0, 508u);
        counterName[254] = 0;
        this_->m_counterElements[i].counterValue = 0;
        memset(keyName, 0, 508u);
        keyName[254] = 0;
        wsprintfW(keyName, L"Perf%dTitle", elementIndex);
        GetPrivateProfileStringW(L"PerfMon", keyName, L"Title", this_->m_counterElements[i].title, 510u, fileName);
        memset(keyName, 0, 0x1FCu);
        keyName[254] = 0;
        wsprintfW(keyName, L"Perf%dObjectName", elementIndex);
        GetPrivateProfileStringW(L"PerfMon", keyName, L"Processor", this_->m_counterElements[i].objectName, 510u, fileName);
        memset(keyName, 0, 0x1FCu);
        keyName[254] = 0;
        wsprintfW(keyName, L"Perf%dInstanceName", elementIndex);
        GetPrivateProfileStringW(L"PerfMon", keyName, L"0", this_->m_counterElements[i].instanceName, 510u, fileName);
        memset(keyName, 0, 0x1FCu);
        keyName[254] = 0;
        wsprintfW(keyName, L"Perf%dCounterName", elementIndex);
        GetPrivateProfileStringW(L"PerfMon", keyName, L"% Processor Time", this_->m_counterElements[i].counterName, 510u, fileName);
        counterElements = &this_->m_counterElements[i];
        counterPathElements.szObjectName = counterElements->objectName;
        counterPathElements.szInstanceName = counterElements->instanceName;
        counterPathElements.szCounterName = counterElements->counterName;
        counterPathElements.szMachineName = 0;
        counterPathElements.szParentInstance = 0;
        memset(fullPathBuffer, 0, sizeof(fullPathBuffer));
        counterPathElements.dwInstanceIndex = -1;
        bufferSize = 512;
        pdhStatus = PdhMakeCounterPathW(&counterPathElements, fullPathBuffer, &bufferSize, 0);
        if ( pdhStatus )
        {
          CLog::Add(&g_winlog, LOG_ERROR, L"MCP failed %08x", pdhStatus);
          return false;
        }
        pdhStatus2 = PdhAddCounterW(this_->m_pdhQuery, fullPathBuffer, 0, &this_->m_pdhCounters[i2]);
        if ( pdhStatus2 )
        {
          break;
        }
        CLog::Add(&g_winlog, 0, L"PdhMakeCounterPath %s", fullPathBuffer);
        ++elementIndex;
        ++i;
        ++i2;
        if ( elementIndex - 1 >= this_->m_pdhCountersNumber )
        {
          goto LABEL_11;
        }
      }
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "PAC failed %08x", pdhStatus2);
      return false;
    }
LABEL_11:
    this_->m_initialized = true;
    return true;
  }
  CLog::Add(&g_winlog, LOG_ERROR, L"POQ failed %08x", pdhResult);
  return false;
}
// 426FE0: using guessed type wchar_t aPoqFailed08x[16];
// 427060: using guessed type wchar_t a_Perfmon_ini[14];

//----- (0040E030) --------------------------------------------------------
char __thiscall PerfMonitor::Clean(PerfMonitor *this)
{
  PerfMonitor *this_; // edi@1
  int i; // esi@1

  this_ = this;
  for ( i = 0; i < this_->m_pdhCountersNumber; ++i )
  {
    PdhRemoveCounter(this_->m_pdhCounters[i]);
  }
  PdhCloseQuery(this_->m_pdhQuery);
  return 1;
}

//----- (0040E070) --------------------------------------------------------
bool __thiscall PerfMonitor::Reload(PerfMonitor *this)
{
  PerfMonitor *this_; // esi@1

  this_ = this;
  if ( !this->m_initialized || this->m_pdhCountersNumber <= 0 )
  {
    return true;
  }
  PerfMonitor::Clean(this);
  PerfMonitor::Init(this_);
  return true;
}

//----- (0040E0A0) --------------------------------------------------------
bool __thiscall PerfMonitor::CheckPerformance(PerfMonitor *this)
{
  PerfMonitor *this_; // esi@1
  DWORD memoryLoad; // ecx@2
  unsigned int hi; // edx@2
  DWORD processId; // ST48_4@2
  HANDLE process; // eax@2
  void *process2; // edi@2
  PDH_STATUS pdhStatus; // eax@8
  int i; // edi@10
  int i2; // ebp@11
  PDH_STATUS pdhStatus2; // eax@12
  signed int totalPhysMemory; // ecx@16
  int physMemUsage; // eax@17
  int counterValue; // ecx@19
  signed int totalPhysMemory2; // edi@21
  int physMemUsage2; // eax@22
  SYSTEMTIME systemTime; // [sp+Ch] [bp-1078h]@16
  MEMORYSTATUSEX memoryStatus; // [sp+1Ch] [bp-1068h]@2
  PROCESS_MEMORY_COUNTERS memoryCounters; // [sp+5Ch] [bp-1028h]@3
  WCHAR sqlQuery[1280]; // [sp+84h] [bp-1000h]@19

  this_ = this;
  if ( this->m_memUsage == true )
  {
    memoryStatus.dwLength = sizeof(MEMORYSTATUSEX);
    GlobalMemoryStatusEx(&memoryStatus);
    memoryLoad = memoryStatus.dwMemoryLoad;
    this_->m_availablePhysMemory = memoryStatus.ullAvailPhys >> 10;
    hi = HIDWORD(memoryStatus.ullTotalPhys);
    this_->m_memoryLoad = memoryLoad;
    processId = this_->m_processId;
    this_->m_totalPhysMemory = __PAIR__(hi, memoryStatus.ullTotalPhys) >> 10;
    process = OpenProcess(0x410u, FALSE, processId);// PROCESS_VM_READ | PROCESS_QUERY_INFORMATION
    process2 = process;
    if ( process )
    {
      if ( GetProcessMemoryInfo(process, &memoryCounters, sizeof(PROCESS_MEMORY_COUNTERS)) )
      {
        this_->m_physicallyUsedMemory = memoryCounters.WorkingSetSize >> 10;
      }
      CloseHandle(process2);
    }
  }
  if ( this_->m_pdhCountersNumber > 0 && this_->m_initialized == true )
  {
    pdhStatus = PdhCollectQueryData(this_->m_pdhQuery);
    if ( pdhStatus )
    {
      CLog::Add(&g_winlog, LOG_ERROR, L"PCQD failed %08x", pdhStatus);
      return false;
    }
    i = 0;
    if ( this_->m_pdhCountersNumber > 0 )
    {
      i2 = 0;
      do
      {
        pdhStatus2 = PdhGetFormattedCounterValue(this_->m_pdhCounters[i], PDH_FMT_DOUBLE, NULL, (PPDH_FMT_COUNTERVALUE)&this_->m_counterValue);
        if ( pdhStatus2 )
        {
          CLog::Add(&g_winlog, LOG_ERROR, L"PGFCV failed %08x", pdhStatus2);// PDH_INVALID_DATA
        }
        else
        {
          this_->m_counterElements[i2].counterValue = (unsigned __int64)this_->m_counterValue.doubleValue;
        }
        ++i;
        ++i2;
      }
      while ( i < this_->m_pdhCountersNumber );
    }
  }
  GetLocalTime(&systemTime);
  totalPhysMemory = this_->m_totalPhysMemory;
  if ( totalPhysMemory <= 0 )
  {
    physMemUsage = 0;
  }
  else
  {
    physMemUsage = 100 * this_->m_availablePhysMemory / totalPhysMemory;
  }
  wsprintfW(sqlQuery, L"insert into L%04d_%02d_%02d_log_realtime_%d(act_time, log_id, etc_num1, etc_num2, etc_num3) values('%02d/%02d/%04d %02d:%02d:%02d.%03d', %d, %d,%d,%d )\r\n", systemTime.wYear, systemTime.wMonth, systemTime.wDay, Config::s_worldId, systemTime.wMonth, systemTime.wDay, systemTime.wYear, systemTime.wHour, systemTime.wMinute, systemTime.wSecond, systemTime.wMilliseconds, 1605, this_->m_counterElements->counterValue, physMemUsage, this_->m_physicallyUsedMemory);
  CSQLQueue::PushSQL(&g_sqlPollingQueue, sqlQuery);
  counterValue = 0;
  if ( this_->m_pdhCountersNumber > 0 )
  {
    counterValue = this_->m_counterElements->counterValue;
  }
  totalPhysMemory2 = this_->m_totalPhysMemory;
  if ( totalPhysMemory2 <= 0 )
  {
    physMemUsage2 = 0;
  }
  else
  {
    physMemUsage2 = 100 * this_->m_availablePhysMemory / totalPhysMemory2;
  }
  CLog::Add(&g_winlog, LOG_DB, L"%d,,,,,,,,,,,%d,%d,%d,,,,,,,,,,,,", 1605, counterValue, physMemUsage2, this_->m_physicallyUsedMemory);
  return true;
}

//----- (0040E2F0) --------------------------------------------------------
void *__thiscall CReadFile::CReadFile(void *this)
{
  void *v1; // esi@1
  char v3; // [sp+4h] [bp-4h]@1

  v1 = this;
  guard(&v3, L"CReadFile::CReadFile()");
  unguard();
  return v1;
}

//----- (0040E330) --------------------------------------------------------
char CReadFile::ParseItemName()
{
  char v0; // bl@1
  FILE *v1; // ebp@1
  char result; // al@2
  __int32 v3; // ebx@6
  signed int v4; // edi@7
  wchar_t *v5; // esi@7
  wint_t v6; // ax@8
  wchar_t *v7; // esi@23
  char v8; // [sp+13h] [bp-1425h]@5
  __int32 v9; // [sp+14h] [bp-1424h]@1
  wchar_t v10; // [sp+18h] [bp-1420h]@7
  wchar_t v11; // [sp+218h] [bp-1220h]@24
  wchar_t v12; // [sp+418h] [bp-1020h]@7
  wchar_t v13; // [sp+618h] [bp-E20h]@24
  wchar_t v14; // [sp+818h] [bp-C20h]@19
  int a1; // [sp+A18h] [bp-A20h]@1
  wchar_t v16; // [sp+E28h] [bp-610h]@24
  wchar_t v17; // [sp+1028h] [bp-410h]@19
  int v18; // [sp+1434h] [bp-4h]@1

  guard(&v9, L"bool CReadFile::ParseItemName()");
  v18 = 0;
  v0 = 0;
  v1 = _wfopen(L".\\Itemname-k.txt", L"rb");
  DBConn::DBConn((DBConn *)&a1);
  LOBYTE(v18) = 1;
  if ( v1 )
  {
    if ( !fseek(v1, 0, 0) )
    {
      v0 = 1;
    }
    fgetwc(v1);
    DBConn::Execute((DBConn *)&a1, L"delete from lin2report.dbo.ItemName");
    v8 = 0;
    if ( v0 )
    {
      v3 = v9;
      while ( 1 )
      {
        memset(&v10, 0, 0x200u);
        memset(&v12, 0, 0x200u);
        v4 = 0;
        v5 = &v10;
        do
        {
          v6 = fgetwc(v1);
          if ( v6 == 9 || v6 == 10 || v6 == 13 )
          {
            break;
          }
          if ( v6 == -1 )
          {
            goto LABEL_30;
          }
          if ( v6 != 91 && v6 != 93 && v6 != 39 )
          {
            *v5 = v6;
            ++v5;
          }
          ++v4;
        }
        while ( v4 < 512 );
        if ( v6 == -1 )
        {
          break;
        }
        sub_406340(&v10, (int)&v12);
        if ( !wcscmp(&v12, L"item_name_begin") )
        {
          memset(&v14, 0, 0x200u);
          v8 = 1;
          v3 = 0;
          memset(&v17, 0, 0x400u);
        }
        else if ( !wcscmp(&v12, L"item_name_end") )
        {
          v8 = 0;
          DBConn::Execute((DBConn *)&a1, L"insert into lin2report.dbo.ItemName(item_id, item_name, item_desc) values(%d, '%s', '%s') ", v3, &v14, &v17);
        }
        else if ( v8 == 1 )
        {
          v7 = wcschr(&v10, 0x3Du);
          if ( v7 )
          {
            *v7 = 0;
            wcscpy(&v16, &v10);
            wcscpy(&v13, v7 + 1);
            sub_406340(&v16, (int)&v11);
            if ( !wcsncmp(&v11, L"id", 2u) )
            {
              v3 = j___wtol(&v13);
            }
            else if ( !wcsncmp(&v11, L"name", 4u) )
            {
              wcscpy(&v14, &v13);
            }
            else if ( !wcsncmp(&v11, L"description", 0xBu) )
            {
              wcscpy(&v17, &v13);
            }
          }
        }
      }
    }
LABEL_30:
    fclose(v1);
    LOBYTE(v18) = 0;
    DBConn::DestructorDBConn((DBConn *)&a1);
    v18 = -1;
    unguard();
    result = 1;
  }
  else
  {
    LOBYTE(v18) = 0;
    DBConn::DestructorDBConn((DBConn *)&a1);
    v18 = -1;
    unguard();
    result = 0;
  }
  return result;
}

//----- (0040E680) --------------------------------------------------------
char CReadFile::ParseNPCName()
{
  char v0; // bl@1
  FILE *v1; // ebp@1
  char result; // al@2
  __int32 v3; // ebx@6
  signed int v4; // edi@7
  wchar_t *v5; // esi@7
  wint_t v6; // ax@8
  wchar_t *v7; // esi@23
  char v8; // [sp+13h] [bp-1025h]@5
  __int32 v9; // [sp+14h] [bp-1024h]@1
  wchar_t v10; // [sp+18h] [bp-1020h]@7
  wchar_t v11; // [sp+218h] [bp-E20h]@7
  wchar_t v12; // [sp+418h] [bp-C20h]@24
  wchar_t v13; // [sp+618h] [bp-A20h]@19
  wchar_t v14; // [sp+818h] [bp-820h]@24
  int a1; // [sp+A18h] [bp-620h]@1
  wchar_t v16; // [sp+E28h] [bp-210h]@24
  int v17; // [sp+1034h] [bp-4h]@1

  guard(&v9, L"bool CReadFile::ParseNPCName()");
  v17 = 0;
  v0 = 0;
  v1 = _wfopen(L".\\npcname-k.txt", L"rb");
  DBConn::DBConn((DBConn *)&a1);
  LOBYTE(v17) = 1;
  if ( v1 )
  {
    if ( !fseek(v1, 0, 0) )
    {
      v0 = 1;
    }
    fgetwc(v1);
    DBConn::Execute((DBConn *)&a1, L"delete from lin2report.dbo.NPCName");
    v8 = 0;
    if ( v0 )
    {
      v3 = v9;
      while ( 1 )
      {
        memset(&v10, 0, 0x200u);
        memset(&v11, 0, 0x200u);
        v4 = 0;
        v5 = &v10;
        do
        {
          v6 = fgetwc(v1);
          if ( v6 == 9 || v6 == 10 || v6 == 13 )
          {
            break;
          }
          if ( v6 == -1 )
          {
            goto LABEL_28;
          }
          if ( v6 != 91 && v6 != 93 && v6 != 39 )
          {
            *v5 = v6;
            ++v5;
          }
          ++v4;
        }
        while ( v4 < 512 );
        if ( v6 == -1 )
        {
          break;
        }
        sub_406340(&v10, (int)&v11);
        if ( !wcscmp(&v11, L"npc_begin") )
        {
          v8 = 1;
          v3 = 0;
          memset(&v13, 0, 0x200u);
        }
        else if ( !wcscmp(&v11, L"npc_end") )
        {
          v8 = 0;
          DBConn::Execute((DBConn *)&a1, L"insert into lin2report.dbo.NPCName(NPC_id, NPC_name) values(%d, '%s') ", v3, &v13);
        }
        else if ( v8 == 1 )
        {
          v7 = wcschr(&v10, 0x3Du);
          if ( v7 )
          {
            *v7 = 0;
            wcscpy(&v16, &v10);
            wcscpy(&v14, v7 + 1);
            sub_406340(&v16, (int)&v12);
            if ( !wcsncmp(&v12, L"id", 2u) )
            {
              v3 = j___wtol(&v14);
            }
            else if ( !wcsncmp(&v12, L"name", 4u) )
            {
              wcscpy(&v13, &v14);
            }
          }
        }
      }
    }
LABEL_28:
    fclose(v1);
    LOBYTE(v17) = 0;
    DBConn::DestructorDBConn((DBConn *)&a1);
    v17 = -1;
    unguard();
    result = 1;
  }
  else
  {
    LOBYTE(v17) = 0;
    DBConn::DestructorDBConn((DBConn *)&a1);
    v17 = -1;
    unguard();
    result = 0;
  }
  return result;
}

//----- (0040E980) --------------------------------------------------------
char CReadFile::ParseQuestName()
{
  char v0; // bl@1
  FILE *v1; // ebp@1
  char result; // al@2
  __int32 v3; // ebx@6
  signed int v4; // edi@7
  wchar_t *v5; // esi@7
  wint_t v6; // ax@8
  wchar_t *v7; // esi@23
  char v8; // [sp+13h] [bp-2A25h]@5
  __int32 v9; // [sp+14h] [bp-2A24h]@1
  wchar_t v10; // [sp+18h] [bp-2A20h]@24
  wchar_t v11; // [sp+218h] [bp-2820h]@19
  int a1; // [sp+418h] [bp-2620h]@1
  wchar_t v13; // [sp+828h] [bp-2210h]@24
  wchar_t v14; // [sp+A28h] [bp-2010h]@7
  wchar_t v15; // [sp+1228h] [bp-1810h]@7
  wchar_t v16; // [sp+1A28h] [bp-1010h]@24
  wchar_t v17; // [sp+2228h] [bp-810h]@19
  int v18; // [sp+2A34h] [bp-4h]@1

  guard(&v9, L"bool CReadFile::ParseQuestName()");
  v18 = 0;
  v0 = 0;
  v1 = _wfopen(L".\\questname-k.txt", L"rb");
  DBConn::DBConn((DBConn *)&a1);
  LOBYTE(v18) = 1;
  if ( v1 )
  {
    if ( !fseek(v1, 0, 0) )
    {
      v0 = 1;
    }
    fgetwc(v1);
    DBConn::Execute((DBConn *)&a1, L"delete from lin2report.dbo.QuestName");
    v8 = 0;
    if ( v0 )
    {
      v3 = v9;
      while ( 1 )
      {
        memset(&v14, 0, 0x800u);
        memset(&v15, 0, 0x800u);
        v4 = 0;
        v5 = &v14;
        do
        {
          v6 = fgetwc(v1);
          if ( v6 == 9 || v6 == 10 || v6 == 13 )
          {
            break;
          }
          if ( v6 == -1 )
          {
            goto LABEL_30;
          }
          if ( v6 != 91 && v6 != 93 && v6 != 39 )
          {
            *v5 = v6;
            ++v5;
          }
          ++v4;
        }
        while ( v4 < 1024 );
        if ( v6 == -1 )
        {
          break;
        }
        sub_406340(&v14, (int)&v15);
        if ( !wcscmp(&v15, L"quest_begin") )
        {
          memset(&v11, 0, 0x200u);
          v8 = 1;
          v3 = 0;
          memset(&v17, 0, 0x800u);
        }
        else if ( !wcsncmp(&v15, L"quest_end", 9u) )
        {
          v8 = 0;
          DBConn::Execute((DBConn *)&a1, L"insert into lin2report.dbo.QuestName(quest_id, quest_name, quest_desc) values(%d, '%s', '%s') ", v3, &v11, &v17);
        }
        else if ( v8 == 1 )
        {
          v7 = wcschr(&v14, 0x3Du);
          if ( v7 )
          {
            *v7 = 0;
            wcscpy(&v13, &v14);
            wcscpy(&v16, v7 + 1);
            sub_406340(&v13, (int)&v10);
            if ( !wcsncmp(&v10, L"id", 2u) )
            {
              v3 = j___wtol(&v16);
            }
            else if ( !wcsncmp(&v10, L"name", 4u) )
            {
              wcscpy(&v11, &v16);
            }
            else if ( !wcsncmp(&v10, L"desc", 4u) )
            {
              wcscpy(&v17, &v16);
            }
          }
        }
      }
    }
LABEL_30:
    fclose(v1);
    LOBYTE(v18) = 0;
    DBConn::DestructorDBConn((DBConn *)&a1);
    v18 = -1;
    unguard();
    result = 1;
  }
  else
  {
    LOBYTE(v18) = 0;
    DBConn::DestructorDBConn((DBConn *)&a1);
    v18 = -1;
    unguard();
    result = 0;
  }
  return result;
}

//----- (0040ECE0) --------------------------------------------------------
char CReadFile::ParseSkillName()
{
  char v0; // bl@1
  FILE *v1; // esi@1
  char result; // al@2
  __int32 v3; // ebp@6
  __int32 v4; // ebx@6
  signed int v5; // edi@7
  wchar_t *v6; // esi@7
  wint_t v7; // ax@8
  wchar_t *v8; // eax@23
  const wchar_t *v9; // esi@24
  char v10; // [sp+17h] [bp-1429h]@5
  __int32 v11; // [sp+18h] [bp-1428h]@1
  FILE *v12; // [sp+1Ch] [bp-1424h]@1
  wchar_t v13; // [sp+20h] [bp-1420h]@24
  wchar_t v14; // [sp+220h] [bp-1220h]@7
  wchar_t v15; // [sp+420h] [bp-1020h]@24
  wchar_t v16; // [sp+620h] [bp-E20h]@7
  wchar_t v17; // [sp+820h] [bp-C20h]@19
  int a1; // [sp+A20h] [bp-A20h]@1
  wchar_t v19; // [sp+E30h] [bp-610h]@24
  wchar_t v20; // [sp+1030h] [bp-410h]@19
  int v21; // [sp+143Ch] [bp-4h]@1

  guard(&v11, L"bool CReadFile::ParseSkillName()");
  v21 = 0;
  v0 = 0;
  v1 = _wfopen(L".\\skillname-k.txt", L"rb");
  v12 = v1;
  DBConn::DBConn((DBConn *)&a1);
  LOBYTE(v21) = 1;
  if ( v1 )
  {
    if ( !fseek(v1, 0, 0) )
    {
      v0 = 1;
    }
    fgetwc(v1);
    DBConn::Execute((DBConn *)&a1, L"delete from lin2report.dbo.SkillName");
    v10 = 0;
    if ( v0 )
    {
      v3 = v11;
      v4 = v11;
      while ( 1 )
      {
        memset(&v14, 0, 0x200u);
        memset(&v16, 0, 0x200u);
        v5 = 0;
        v6 = &v14;
        do
        {
          v7 = fgetwc(v12);
          if ( v7 == 9 || v7 == 10 || v7 == 13 )
          {
            break;
          }
          if ( v7 == -1 )
          {
            goto LABEL_32;
          }
          if ( v7 != 91 && v7 != 93 && v7 != 39 )
          {
            *v6 = v7;
            ++v6;
          }
          ++v5;
        }
        while ( v5 < 512 );
        if ( v7 == -1 )
        {
          break;
        }
        sub_406340(&v14, (int)&v16);
        if ( !wcscmp(&v16, L"skill_begin") )
        {
          memset(&v17, 0, 0x200u);
          v3 = 0;
          v10 = 1;
          v4 = 0;
          memset(&v20, 0, 0x400u);
        }
        else if ( !wcscmp(&v16, L"skill_end") )
        {
          v10 = 0;
          DBConn::Execute((DBConn *)&a1, L"insert into lin2report.dbo.SkillName(skill_id, skill_name, skill_lev, skill_desc) values(%d, '%s', %d,  '%s') ", v3, &v17, v4, &v20);
        }
        else if ( v10 == 1 )
        {
          v8 = wcschr(&v14, 0x3Du);
          if ( v8 )
          {
            *v8 = 0;
            v9 = v8 + 1;
            wcscpy(&v19, &v14);
            wcscpy(&v13, v9);
            sub_406340(&v19, (int)&v15);
            if ( !wcsncmp(&v15, L"skill_id", 8u) )
            {
              v3 = j___wtol(&v13);
            }
            if ( !wcsncmp(&v15, L"skill_level", 0xBu) )
            {
              v4 = j___wtol(&v13);
            }
            else if ( !wcsncmp(&v15, L"name", 4u) )
            {
              wcscpy(&v17, &v13);
            }
            else if ( !wcsncmp(&v15, L"desc", 4u) )
            {
              wcscpy(&v20, &v13);
            }
          }
        }
      }
LABEL_32:
      v1 = v12;
    }
    fclose(v1);
    LOBYTE(v21) = 0;
    DBConn::DestructorDBConn((DBConn *)&a1);
    v21 = -1;
    unguard();
    result = 1;
  }
  else
  {
    LOBYTE(v21) = 0;
    DBConn::DestructorDBConn((DBConn *)&a1);
    v21 = -1;
    unguard();
    result = 0;
  }
  return result;
}

//----- (0040F080) --------------------------------------------------------
CServer *__thiscall CServer::CServer(CServer *this)
{
  CServer *this_; // esi@1
  char v3; // [sp+4h] [bp-14h]@1
  CServer *this2; // [sp+8h] [bp-10h]@1
  int unused; // [sp+14h] [bp-4h]@1

  this_ = this;
  this2 = this;
  CIOServer::CIOServer((CIOServer *)this);
  unused = 0;
  this_->vtable = (CIOServer_Vtable *)&CServer_vtable_427984;
  guard(&v3, L"CServer::CServer()");
  LOBYTE(this_->m_d.field2) = 0;
  InitializeCriticalSectionAndSpinCount(&this_->m_d.m_lock, 4000u);
  unguard();
  return this_;
}
// 427984: using guessed type void *CServer_vtable_427984;

//----- (0040F0F0) --------------------------------------------------------
int __thiscall CServer::Destructor(CServer *this)
{
  CServer *this_; // esi@1
  char v3; // [sp+4h] [bp-14h]@1
  CServer *this_2; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  this_ = this;
  this_2 = this;
  this->vtable = (CIOServer_Vtable *)&CServer_vtable_427984;
  v5 = 0;
  guard(&v3, L"CServer::~CServer()");
  DeleteCriticalSection(&this_->m_d.m_lock);
  CloseHandle(this_->m_d.m_someHandle);
  unguard();
  v5 = -1;
  return CIOServer::Destructor((CIOServer *)this_);
}
// 427984: using guessed type void *CServer_vtable_427984;

//----- (0040F170) --------------------------------------------------------
int __thiscall CServer::Run(CServer *this, int port, CServerSocket *(__cdecl *allocator)(SOCKET s), bool restrict, int reader, int worker)
{
  CServer *this_; // esi@1
  char v8; // [sp+8h] [bp-10h]@1
  int unused; // [sp+14h] [bp-4h]@1

  this_ = this;
  guard(&v8, L"void CServer::Run(int port, CServerSocket* (*anAllocator)(SOCKET s), bool aRestrict, int nReader, int nWorker)");
  this_->m_d.m_restrict = restrict;
  unused = 0;
  this_->m_d.m_allocator = allocator;
  if ( CIOServer::Create((CIOServer *)this_, port) )
  {
    CLog::Add_Ansi(&g_winlog, 0, "server ready on port %d", port);
  }
  this_->m_d.m_socket = this_->m_d.base.m_hSocket;
  unused = -1;
  return unguard();
}

//----- (0040F200) --------------------------------------------------------
int __thiscall CServer::CreateSocket(CServer *this, SOCKET newSocket, sockaddr_in *address)
{
  CServer *this_; // edi@1
  bool restrict; // al@1
  u_char v5; // al@2
  int result; // eax@4
  CServerSocket *serverSocket; // edi@5
  char v8; // [sp+8h] [bp-10h]@1
  int unused; // [sp+14h] [bp-4h]@1

  this_ = this;
  guard(&v8, L"CIOSocket* CServer::CreateSocket(SOCKET newSocket, LPSOCKADDR_IN pAddress)");
  restrict = this_->m_d.m_restrict;
  unused = 0;
  if ( restrict && ((v5 = address->sin_addr.S_un.S_un_b.s_b1, v5 != 10) || address->sin_addr.S_un.S_un_b.s_b2 != 10) )
  {
    CLog::Add_Ansi(&g_winlog, LOG_ERROR, "%d.%d.%d.%d: denied", v5, address->sin_addr.S_un.S_un_b.s_b2, address->sin_addr.S_un.S_un_b.s_b3, address->sin_addr.S_un.S_un_b.s_b4);
    unused = -1;
    unguard();
    result = 0;
  }
  else
  {
    serverSocket = this_->m_d.m_allocator(newSocket);
    ((void (__thiscall *)(CServerSocket *, u_long))serverSocket->vtable->SetAddress)(serverSocket, address->sin_addr.S_un.S_addr);
    CLog::Add_Ansi(&g_winlog, 0, "*new connection from %d.%d.%d.%d", address->sin_addr.S_un.S_un_b.s_b1, address->sin_addr.S_un.S_un_b.s_b2, address->sin_addr.S_un.S_un_b.s_b3, address->sin_addr.S_un.S_un_b.s_b4);
    unused = -1;
    unguard();
    result = (int)serverSocket;
  }
  return result;
}

//----- (0040F300) --------------------------------------------------------
LONG __thiscall CServer::Release(CServer *this, const char *file, int line, int nWorkType, bool flag)
{
  CServer *this_; // esi@1
  LONG refCount; // eax@1
  LONG refCount1; // edi@1
  LONG result; // eax@5

  this_ = this;
  refCount = InterlockedDecrement(&this->m_d.base.base.m_nRefCount);
  refCount1 = refCount;
  if ( refCount > 0 )
  {
    return refCount1;
  }
  if ( refCount )
  {
    if ( refCount > -1 )
    {
      return refCount1;
    }
    CLog::Add_Ansi(&g_winlog, LOG_ERROR, "Invalid Memory (%d) on CServer(%d)", refCount, this_->m_d.base.base.m_identity);
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "           Caller : file[%s], line[%d]", file, line);
    }
    MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
    CallStack::ReportCallStack();
    return refCount1;
  }
  if ( this_->m_d.base.base.m_inTimer )
  {
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![CServer] at file[%s], line[%d]", file, line);
      MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * CServer::s_nAlloc + 0x455E50));
      result = refCount1;
    }
    else
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![CServer]");
      MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * CServer::s_nAlloc + 0x455E50));
      result = refCount1;
    }
  }
  else
  {
    this_->vtable->base.base.DeletingDestructor(this_, 0);
    MMU::deallocate(&g_mmu, this_);
    InterlockedDecrement((volatile LONG *)(4 * CServer::s_nAlloc + 0x455E50));
    result = refCount1;
  }
  return result;
}
// 1BD3B5C: using guessed type int g_mmu;
// 1BD5028: using guessed type int CServer::s_nAlloc;

//----- (0040F430) --------------------------------------------------------
CServer *__thiscall CServer::DeletingDestructor(CServer *this, char a2)
{
  CServer *this_; // esi@1

  this_ = this;
  CServer::Destructor(this);
  if ( !(a2 & 1) )
  {
    return this_;
  }
  CLog::Add(&g_winlog, LOG_ERROR, L"Never Call Oprator Delete!!! CServer at file[%s], line[%d]", L"d:\\work\\l2\\server\\l2logd\\Server.h", 13);
  CallStack::ReportCallStack();
  return this_;
}
// 427CD8: using guessed type wchar_t aDWorkL2Serve_2[34];

//----- (0040F470) --------------------------------------------------------
int CServerSocket::operator_delete()
{
  CLog::Add(&g_winlog, LOG_ERROR, L"Never Call Oprator Delete!!! CServerSocket at file[%s], line[%d]", L"d:\\work\\l2\\server\\l2logd\\serversocket.h", 19);
  return CallStack::ReportCallStack();
}
// 427DD0: using guessed type wchar_t aDWorkL2Serve_3[40];

//----- (0040F490) --------------------------------------------------------
bool __thiscall CServerSocket::CanAppend(CServerSocket *this, int year, int month, int day, int hour, int half)
{
  return this->d.m_fileBuffers[0] != (HANDLE)INVALID_HANDLE_VALUE && half == this->d.m_half && this->d.m_hour == hour && this->d.m_year == year && this->d.m_month == month && this->d.m_day == day;
}

//----- (0040F4E0) --------------------------------------------------------
void __thiscall CServerSocket::LockBuffer(CServerSocket *this, int fileIndex)
{
  EnterCriticalSection(&this->d.m_bufferLocks[fileIndex]);
}

//----- (0040F500) --------------------------------------------------------
void __thiscall CServerSocket::UnlockBuffer(CServerSocket *this, int fileIndex)
{
  LeaveCriticalSection(&this->d.m_bufferLocks[fileIndex]);
}

//----- (0040F520) --------------------------------------------------------
const unsigned __int8 *CServerSocket::ParseLogData(const wchar_t *logMessage, const char *format, ...)
{
  int formatToken; // edx@1
  const wchar_t *logMessageIterator2; // edi@1
  const char **outputIterator; // ebp@2
  wchar_t separatorSymbol; // ax@3
  wchar_t *outputParam; // ebx@3
  size_t paramLength; // esi@3
  const wchar_t *logMessageIterator; // ecx@3
  int newOffset; // eax@10
  char v11; // [sp+4h] [bp-4h]@1

  guard(&v11, L"const unsigned char *ParseLogData(WCHAR* packet, const char* format, ...)");
  formatToken = *format;
  logMessageIterator2 = logMessage;
  if ( *format )
  {
    outputIterator = &format;
    do
    {
      separatorSymbol = *logMessageIterator2;
      ++outputIterator;
      ++format;
      outputParam = (wchar_t *)*outputIterator;
      paramLength = 0;
      logMessageIterator = logMessageIterator2;
      if ( !separatorSymbol )
      {
        goto LABEL_19;
      }
      do
      {
        if ( separatorSymbol == ',' )
        {
          break;
        }
        if ( !separatorSymbol )
        {
          break;
        }
        if ( separatorSymbol == '\r' )
        {
          break;
        }
        if ( separatorSymbol == '\n' )
        {
          break;
        }
        separatorSymbol = logMessageIterator[1];
        ++logMessageIterator;
        ++paramLength;
      }
      while ( separatorSymbol );
      if ( paramLength )
      {
        if ( formatToken == 'd' )
        {
          wcsncpy(outputParam, logMessageIterator2, paramLength);
        }
        else
        {
          wcscpy(outputParam, L"'");
          wcsncat(outputParam, logMessageIterator2, paramLength);
          wcscat(outputParam, L"'");
        }
        newOffset = paramLength + 1;
      }
      else
      {
LABEL_19:
        wcscpy(outputParam, L"NULL");
        newOffset = 1;
      }
      formatToken = *format;
      logMessageIterator2 += newOffset;
    }
    while ( *format );
  }
  unguard();
  return (const unsigned __int8 *)logMessageIterator2;
}

//----- (0040F610) --------------------------------------------------------
bool __cdecl CServerSocket::packet01_SetCheckStatus(CServerSocket *socket, const unsigned __int8 *packet)
{
  int checkStatus; // [sp+0h] [bp-14h]@1
  char v4; // [sp+4h] [bp-10h]@1
  int v5; // [sp+10h] [bp-4h]@1

  guard(&v4, L"static bool SetCheckStatusPacket(CServerSocket* pSocket, const unsigned char* packet)");
  v5 = 0;
  checkStatus = 0;
  PacketUtils::Disassemble(packet, L"d", &checkStatus);
  socket->d.m_checkStatus = checkStatus;
  v5 = -1;
  unguard();
  return 0;
}

//----- (0040F690) --------------------------------------------------------
bool __cdecl CServerSocket::packet04_DummyPacket(CServerSocket *socket, const unsigned __int8 *packet)
{
  int v2; // ecx@0
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  guard(&v4, L"static bool DummyPacket(CServerSocket* pSocket, const unsigned char* packet)");
  unguard();
  return 0;
}

//----- (0040F6B0) --------------------------------------------------------
CServerSocket *__thiscall CServerSocket::CServerSocket(CServerSocket *this, SOCKET socket, size_t buffSize)
{
  CServerSocket *this_; // esi@1
  HANDLE v4; // eax@1
  struct _RTL_CRITICAL_SECTION *locks; // ebx@1
  HANDLE *logFiles; // ebp@1
  char v8; // [sp+10h] [bp-14h]@1
  CServerSocket *this2; // [sp+14h] [bp-10h]@1
  int unused; // [sp+20h] [bp-4h]@1
  SOCKET filesNumber; // [sp+28h] [bp+4h]@1

  this_ = this;
  this2 = this;
  CIOSocket::CIOSocket((CIOSocket *)this, socket);
  unused = 0;
  this_->vtable = (CServerSocket_Vtable *)&CServerSocket::vtable;
  CIOCriticalSection::CIOCriticalSection2(&this_->d.m_lock1, 4000u);
  CIOCriticalSection::CIOCriticalSection(&this_->d.m_socketWriteLock);
  LOBYTE(unused) = 2;
  guard(&v8, L"CServerSocket::CServerSocket(SOCKET hSocket, int nBufSize=8192)");
  LOBYTE(unused) = 3;
  this_->d.m_socket = socket;
  this_->d.m_remoteAddr.S_un.S_addr = 0;
  this_->d.m_buffSize = buffSize;
  this_->d.m_readBuffer = (unsigned __int8 *)operator new(buffSize);
  this_->d.m_writeBuffer = (unsigned __int8 *)operator new(this_->d.m_buffSize);
  this_->d.field_150 = 0;
  this_->d.field_151 = 0;
  this_->d.field_152 = 0;
  this_->d.field_156 = 0;
  this_->d.field_157 = 0;
  v4 = CreateEventW(0u, 1, 0, 0u);
  this_->d.m_event = v4;
  this_->d.field_158 = (unsigned int)v4 | 1;
  this_->d.m_socketStatus = 0;
  this_->d.m_packetSize = 0;
  this_->d.field_178 = 0;
  this_->d.field_183 = 0;
  this_->d.field_184 = 0;
  this_->d.field_181 = 0;
  this_->d.field_182 = 0;
  this_->d.m_checkStatus = 0;
  this_->d.m_packetHandlers = (bool (__cdecl **)(CLogSocket *, const unsigned __int8 *))CServerSocket::s_packetHandlers;
  this_->d.m_createdTime = GetTickCount();
  locks = this_->d.m_bufferLocks;
  logFiles = this_->d.m_fileBuffers;
  filesNumber = 8;
  do
  {
    *logFiles = (HANDLE)INVALID_HANDLE_VALUE;
    InitializeCriticalSection(locks);
    ++logFiles;
    ++locks;
    --filesNumber;
  }
  while ( filesNumber );
  InitializeCriticalSection(&this_->d.m_fileLock);
  this_->d.m_month = 0;
  this_->d.m_day = 0;
  this_->d.m_hour = 0;
  this_->d.m_worldId = 0;
  this_->d.m_half = 0;
  this_->d.m_serverType = -1;
  memset(this_->d.m_yearMonthDay, 0, sizeof(this_->d.m_yearMonthDay));
  memset(this_->d.m_fileNames, 0, sizeof(this_->d.m_fileNames));
  LOBYTE(unused) = 2;
  unguard();
  return this_;
}
// 428098: using guessed type void *CServerSocket::vtable;
// 42D8A8: using guessed type int (__cdecl *CServerSocket::s_packetHandlers[4])(int, char *);

//----- (0040F890) --------------------------------------------------------
int __thiscall CServerSocket::Destructor(CServerSocket *this)
{
  CServerSocket *this_; // esi@1
  struct _RTL_CRITICAL_SECTION *fileLocks; // ebx@1
  HANDLE *buffer; // edi@1
  signed int filesNumber; // [sp+10h] [bp-18h]@1
  char v6; // [sp+14h] [bp-14h]@1
  CServerSocket *this2; // [sp+18h] [bp-10h]@1
  int unused; // [sp+24h] [bp-4h]@1

  this_ = this;
  this2 = this;
  this->vtable = (CServerSocket_Vtable *)&CServerSocket::vtable;
  unused = 2;
  guard(&v6, L"CServerSocket::~CServerSocket()");
  fileLocks = this_->d.m_bufferLocks;
  buffer = this_->d.m_fileBuffers;
  filesNumber = 8;
  do
  {
    if ( *buffer != (HANDLE)INVALID_HANDLE_VALUE )
    {
      FlushFileBuffers(*buffer);
      CloseHandle(*buffer);
      *buffer = (HANDLE)INVALID_HANDLE_VALUE;
    }
    DeleteCriticalSection(fileLocks);
    ++buffer;
    ++fileLocks;
    --filesNumber;
  }
  while ( filesNumber );
  CloseHandle(this_->d.m_event);
  j_j__free(this_->d.m_readBuffer);
  j_j__free(this_->d.m_writeBuffer);
  DeleteCriticalSection(&this_->d.m_fileLock);
  unguard();
  LOBYTE(unused) = 1;
  CIOCriticalSection::Destructor(&this_->d.m_socketWriteLock);
  LOBYTE(unused) = 0;
  CIOCriticalSection::Destructor(&this_->d.m_lock1);
  unused = -1;
  return CIOSocket::Destructor((CIOSocket *)this_);
}
// 428098: using guessed type void *CServerSocket::vtable;

//----- (0040F9A0) --------------------------------------------------------
CServerSocket *__cdecl CServerSocket::Allocate(SOCKET socket)
{
  CServerSocket *memory; // esi@1
  int nAlloc; // eax@1
  CServerSocket *serverSocket; // esi@2
  char v5; // [sp+4h] [bp-14h]@1
  CServerSocket *v6; // [sp+8h] [bp-10h]@1
  int v7; // [sp+14h] [bp-4h]@1

  guard(&v5, L"CServerSocket::Allocate()");
  v7 = 0;
  memory = (CServerSocket *)Allocator::allocate(&g_mmu, sizeof(CServerSocket), 1, L"CServerSocket");// inlined operator_new
  InterlockedIncrement((volatile LONG *)(4 * CServerSocket::s_nAlloc + 0x455E50));
  nAlloc = CServerSocket::s_nAlloc;
  Allocator::g_allocatedObjName[CServerSocket::s_nAlloc] = "CServerSocket";
  Allocator::g_allocatedMemory[nAlloc] = sizeof(CServerSocket);// /inlined operator_new
  v6 = memory;
  LOBYTE(v7) = 1;
  if ( memory )
  {
    serverSocket = CServerSocket::CServerSocket(memory, socket, 0x2000u);
  }
  else
  {
    serverSocket = 0;
  }
  v7 = -1;
  unguard();
  return serverSocket;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (0040FA60) --------------------------------------------------------
int __thiscall CServerSocket::OnCreate(CServerSocket *this)
{
  CServerSocket *this_; // esi@1
  char v3; // [sp+4h] [bp-10h]@1
  int unused; // [sp+10h] [bp-4h]@1

  this_ = this;
  guard(&v3, L"void CServerSocket::OnCreate()");
  unused = 0;
  CIOObject::AddTimer((CIOObject *)this_, Config::s_serverReportInterval, 0);
  this_->vtable->base.OnRead((CIOSocket *)this_);
  unused = -1;
  return unguard();
}

//----- (0040FAD0) --------------------------------------------------------
int __thiscall CServerSocket::OnClose(CServerSocket *this)
{
  CServerSocket *this_; // esi@1
  HANDLE *logFiles; // edi@1
  int error; // eax@7
  signed int filesNumber; // [sp+10h] [bp-1028h]@1
  in_addr addr; // [sp+14h] [bp-1024h]@8
  char v7; // [sp+18h] [bp-1020h]@1
  struct _SYSTEMTIME systemTime; // [sp+1Ch] [bp-101Ch]@6
  wchar_t format[2048]; // [sp+2Ch] [bp-100Ch]@6
  int unused; // [sp+1034h] [bp-4h]@1

  this_ = this;
  guard(&v7, L"CServerSocket::OnClose()");
  unused = 0;
  this_->d.m_socketStatus = SocketStatus_Closed;
  InterlockedExchange((volatile LONG *)&this_->d.m_socket, 0);
  logFiles = this_->d.m_fileBuffers;
  filesNumber = 8;
  do
  {
    if ( *logFiles != (HANDLE)INVALID_HANDLE_VALUE )
    {
      FlushFileBuffers(*logFiles);
      CloseHandle(*logFiles);
      *logFiles = (HANDLE)INVALID_HANDLE_VALUE;
    }
    ++logFiles;
    --filesNumber;
  }
  while ( filesNumber );
  if ( (signed int)this_->d.m_serverType > 0 )
  {
    GetLocalTime(&systemTime);
    wsprintfW(format, L"insert into %slog_realtime_%d(act_time, log_id, etc_num1, etc_num2) values('%d/%d/%d %d:%d:%d.%d',%d, %d, %d)\r\n", this_->d.m_yearMonthDay, this_->d.m_worldId, systemTime.wYear, systemTime.wMonth, systemTime.wDay, systemTime.wHour, systemTime.wMinute, systemTime.wSecond, systemTime.wMilliseconds, 1305, this_->d.m_serverType, this_->d.m_worldId);
    CSQLQueue::PushSQL(&g_sqlPollingQueue, format);
    if ( (signed int)this_->d.m_serverType > 0 )
    {
      error = WSAGetLastError();
      CLog::Add(&g_winlog, LOG_NORMAL, L"CServerSocket::OnClose. servertype(%s), m_nWorld(%d), Disconnected (%x). WSAGetLastError(%d)", CServerSocket::s_logComponents[this_->d.m_serverType], this_->d.m_worldId, this_, error);
    }
  }
  this_->vtable->GetAddress(this_, &addr);
  CLog::Add(&g_winlog, LOG_NORMAL, L"Log connection closed from (%d.%d.%d.%d)", addr.S_un.S_un_b.s_b1, addr.S_un.S_un_b.s_b2, addr.S_un.S_un_b.s_b3, addr.S_un.S_un_b.s_b4);
  unused = -1;
  return unguard();
}

//----- (0040FC90) --------------------------------------------------------
char *__cdecl Utils::UnicodeToMultibyte2(const wchar_t *wideMsg)
{
  const WCHAR *wideMsg1; // ebx@0
  int newLength; // esi@1
  char *multiByte; // edi@1
  char v5; // [sp+Ch] [bp-8h]@1
  BOOL UsedDefaultChar; // [sp+10h] [bp-4h]@1

  guard(&v5, L"UnicodeToMultibyte");
  newLength = WideCharToMultiByte(CP_ACP, 0, wideMsg1, -1, 0, 0, 0, 0);
  GetLastError();
  multiByte = (char *)malloc(newLength + 1);
  WideCharToMultiByte(CP_ACP, 0, wideMsg1, -1, multiByte, newLength, 0, &UsedDefaultChar);
  multiByte[newLength - 1] = 0;
  unguard();
  return multiByte;
}

//----- (0040FD00) --------------------------------------------------------
int __thiscall CServerSocket::WriteLogFile(CServerSocket *this, LogType logType, const wchar_t *msg)
{
  CServerSocket *this_; // esi@1
  char *unicodeLen; // edi@1
  struct _RTL_CRITICAL_SECTION *filesLock; // edi@4
  void *file; // eax@4
  DWORD bufferLen; // [sp-Ch] [bp-8B4h]@4
  DWORD *bytesWritten2; // [sp-8h] [bp-8B0h]@4
  const wchar_t *v10; // [sp+0h] [bp-8A8h]@0
  DWORD bytesWritten; // [sp+10h] [bp-898h]@2
  char guard; // [sp+14h] [bp-894h]@1
  char buffer[2174]; // [sp+18h] [bp-890h]@1
  char unused_1; // [sp+897h] [bp-11h]@1
  int unused; // [sp+8A4h] [bp-4h]@1

  this_ = this;
  ::guard(&guard, L"void CServerSocket::WriteLogFile (LogType nLogType, WCHAR* sMsg)");
  buffer[0] = 0;
  unused = 0;
  memset(&buffer[1], 0, 2172u);
  *(_WORD *)&buffer[2173] = 0;
  unused_1 = 0;
  unicodeLen = Utils::UnicodeToMultibyte2(v10); // msg falls here
  sprintf(buffer, "%s", unicodeLen);
  free(unicodeLen);
  switch ( logType )
  {
    case LOG_IN:
      EnterCriticalSection(&this_->d.m_bufferLocks[FileBuffers_In]);
      WriteFile(this_->d.m_fileBuffers[FileBuffers_In], buffer, strlen(buffer), &bytesWritten, 0);
      LeaveCriticalSection(&this_->d.m_bufferLocks[FileBuffers_In]);
      if ( Config::s_makeOut == true )
      {
        CServerSocket::LockBuffer(this_, FileBuffers_Out);
        WriteFile(this_->d.m_fileBuffers[FileBuffers_Out], buffer, strlen(buffer), &bytesWritten, 0);
        CServerSocket::UnlockBuffer(this_, FileBuffers_Out);
      }
      break;
    case LOG_DB:
      filesLock = &this_->d.m_bufferLocks[FileBuffers_Db];
      EnterCriticalSection(&this_->d.m_bufferLocks[FileBuffers_Db]);
      bytesWritten2 = &bytesWritten;
      bufferLen = strlen(buffer);
      file = this_->d.m_fileBuffers[FileBuffers_Db];
      goto LABEL_10;
    case LOG_AUDIT:
      filesLock = &this_->d.m_bufferLocks[FileBuffers_Audit];
      EnterCriticalSection(&this_->d.m_bufferLocks[FileBuffers_Audit]);
      bytesWritten2 = &bytesWritten;
      bufferLen = strlen(buffer);
      file = this_->d.m_fileBuffers[FileBuffers_Audit];
      goto LABEL_10;
    case LOG_ERROR:
      filesLock = &this_->d.m_bufferLocks[FileBuffers_Error];
      EnterCriticalSection(&this_->d.m_bufferLocks[FileBuffers_Error]);
      bytesWritten2 = &bytesWritten;
      bufferLen = strlen(buffer);
      file = this_->d.m_fileBuffers[FileBuffers_Error];
      goto LABEL_10;
    case LOG_CHAT:
      EnterCriticalSection(&this_->d.m_bufferLocks[FileBuffers_Chat]);
      WriteFile(this_->d.m_fileBuffers[FileBuffers_Chat], buffer, strlen(buffer), &bytesWritten, 0);
      LeaveCriticalSection(&this_->d.m_bufferLocks[FileBuffers_Chat]);
      if ( Config::s_makeOut == true )
      {
        CServerSocket::LockBuffer(this_, FileBuffers_ChatOut);
        WriteFile(this_->d.m_fileBuffers[FileBuffers_ChatOut], buffer, strlen(buffer), &bytesWritten, 0);
        CServerSocket::UnlockBuffer(this_, FileBuffers_ChatOut);
      }
      break;
    default:
      filesLock = this_->d.m_bufferLocks;
      EnterCriticalSection(this_->d.m_bufferLocks);
      bytesWritten2 = &bytesWritten;
      bufferLen = strlen(buffer);
      file = this_->d.m_fileBuffers[FileBuffers_System];
LABEL_10:
      WriteFile(file, buffer, bufferLen, bytesWritten2, (LPOVERLAPPED)FileBuffers_System);
      LeaveCriticalSection(filesLock);
      break;
  }
  unused = -1;
  return unguard();
}

//----- (0040FFC0) --------------------------------------------------------
bool __thiscall CServerSocket::CheckLogTimeTable(CServerSocket *this, int worldId)
{
  CServerSocket *this_; // esi@1
  bool result; // al@2
  wchar_t *yearMonthDay; // esi@3
  char v5; // [sp+8h] [bp-10h]@1
  int unused; // [sp+14h] [bp-4h]@1

  this_ = this;
  guard(&v5, L"bool CServerSocket::CheckLogTimeTable(int nWorld)");
  unused = 0;
  if ( worldId >= 0 )
  {
    yearMonthDay = this_->d.m_yearMonthDay;
    CSQLQueue::PushSQL(&g_sqlPollingQueue, aExecuteLin_checklogtim2[0], yearMonthDay, worldId);
    CLog::Add(&g_winlog, 0, L"CServerSocket::CheckLogTimeTable %s, %d", yearMonthDay, worldId);
    unused = -1;
    unguard();
    result = true;
  }
  else
  {
    unused = -1;
    unguard();
    result = false;
  }
  return result;
}

//----- (00410080) --------------------------------------------------------
int __thiscall CServerSocket::SetAddress(CServerSocket *this, in_addr addr)
{
  CServerSocket *this_; // esi@1
  char v4; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v4, L"void CServerSocket::SetAddress(in_addr addr)");
  this_->d.m_remoteAddr = addr;
  return unguard();
}

//----- (004100B0) --------------------------------------------------------
in_addr __thiscall CServerSocket::GetAddress(CServerSocket *this, in_addr *unused)
{
  CServerSocket *this_; // esi@1
  char v4; // [sp+4h] [bp-4h]@1

  this_ = this;
  guard(&v4, L"in_addr CServerSocket::GetAddress() const");
  *unused = this_->d.m_remoteAddr;
  unguard();
  return (in_addr)unused;
}

//----- (004100E0) --------------------------------------------------------
LONG __thiscall CServerSocket::Release(CServerSocket *this, const char *file, int line, int nWorkType, bool flag)
{
  CServerSocket *this_; // esi@1
  LONG refCount; // eax@1
  LONG refCount_; // edi@1
  LONG result; // eax@5

  this_ = this;
  refCount = InterlockedDecrement(&this->d.base.base.base.m_nRefCount);
  refCount_ = refCount;
  if ( refCount > 0 )
  {
    return refCount_;
  }
  if ( refCount )
  {
    if ( refCount > -1 )
    {
      return refCount_;
    }
    CLog::Add_Ansi(&g_winlog, LOG_ERROR, "Invalid Memory (%d) on CServerSocket(%d)", refCount, this_->d.base.base.base.m_identity);
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "           Caller : file[%s], line[%d]", file, line);
    }
    MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
    CallStack::ReportCallStack();
    return refCount_;
  }
  if ( this_->d.base.base.base.m_inTimer )
  {
    if ( file )
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![CServerSocket] at file[%s], line[%d]", file, line);
      MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * CServerSocket::s_nAlloc + 0x455E50));
      result = refCount_;
    }
    else
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "deleting in-timer-object![CServerSocket]");
      MemoryObject::ReportOrt((MemoryObject *)this_, 0, 0);
      InterlockedDecrement((volatile LONG *)(4 * CServerSocket::s_nAlloc + 0x455E50));
      result = refCount_;
    }
  }
  else
  {
    this_->vtable->base.base.base.DeletingDestructor(this_, 0);
    MMU::deallocate(&g_mmu, this_);
    InterlockedDecrement((volatile LONG *)(4 * CServerSocket::s_nAlloc + 0x455E50));
    result = refCount_;
  }
  return result;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (00410210) --------------------------------------------------------
CServerSocket *__thiscall CServerSocket::DeletingDestructor(CServerSocket *this, char a2)
{
  CServerSocket *v2; // esi@1

  v2 = this;
  CServerSocket::Destructor(this);
  if ( !(a2 & 1) )
  {
    return v2;
  }
  CLog::Add(&g_winlog, LOG_ERROR, L"Never Call Oprator Delete!!! CServerSocket at file[%s], line[%d]", L"d:\\work\\l2\\server\\l2logd\\serversocket.h", 19);
  CallStack::ReportCallStack();
  return v2;
}
// 427DD0: using guessed type wchar_t aDWorkL2Serve_3[40];

//----- (00410250) --------------------------------------------------------
int __thiscall CServerSocket::CreateNewLogFile(CServerSocket *this, int year, int month, int day, int hour, int half)
{
  CServerSocket *this_; // esi@1
  int serverCategory; // eax@1
  int result; // eax@2
  int worldId; // eax@4
  wchar_t **logCategories; // ebx@4
  HANDLE *logFiles; // edi@4
  DWORD fileSize; // eax@6
  HANDLE fileHandle; // ST28_4@6
  FilePath *lpFileName; // [sp+8h] [bp-280h]@4
  struct _RTL_CRITICAL_SECTION *filesLock; // [sp+Ch] [bp-27Ch]@4
  char v16; // [sp+10h] [bp-278h]@1
  DWORD fileSize1; // [sp+14h] [bp-274h]@6
  WCHAR categoryPathName; // [sp+18h] [bp-270h]@8
  FilePath fileName; // [sp+7Ch] [bp-20Ch]@4
  int unused; // [sp+284h] [bp-4h]@1

  this_ = this;
  guard(&v16, L"void CServerSocket::CreateNewLogFile(int nYear, int nMonth, int nDay, int nHour, int nHalf)");
  serverCategory = this_->d.m_serverType;
  unused = 0;
  if ( serverCategory >= 0 )
  {
    if ( !CServerSocket::CanAppend(this_, year, month, day, hour, half) )
    {
      fileName.path[0] = 0;
      memset(&fileName.path[1], 0, 508u);
      fileName.path[255] = 0;
      wsprintfW(this_->d.m_yearMonthDay, L"L%04d_%02d_%02d_", year, month, day);
      worldId = this_->d.m_worldId;
      this_->d.m_hour = hour;
      this_->d.m_year = year;
      this_->d.m_month = month;
      this_->d.m_day = day;
      this_->d.m_half = half;
      CServerSocket::CheckLogTimeTable(this_, worldId);
      logCategories = CServerSocket::s_logCategories;
      filesLock = this_->d.m_bufferLocks;
      logFiles = this_->d.m_fileBuffers;
      lpFileName = this_->d.m_fileNames;
      do
      {
        EnterCriticalSection(filesLock);
        if ( *logFiles != (HANDLE)INVALID_HANDLE_VALUE )
        {
          FlushFileBuffers(*logFiles);
          fileSize = GetFileSize(*logFiles, 0);
          fileHandle = *logFiles;
          fileSize1 = fileSize;
          CloseHandle(fileHandle);
          if ( !fileSize1 )
          {
            DeleteFileW(lpFileName->path);
          }
        }
        swprintf(fileName.path, L"log\\%s\\%04d-%02d-%02d-%02d-%02d-%s-%s%d.log", *logCategories, this_->d.m_year, this_->d.m_month, this_->d.m_day, this_->d.m_hour, this_->d.m_worldId, CServerSocket::s_logComponents[this_->d.m_serverType], *logCategories, this_->d.m_half);
        CreateDirectoryW(L"log", 0);
        wsprintfW(&categoryPathName, L"log\\%s", *logCategories);
        CreateDirectoryW(&categoryPathName, 0);
        *logFiles = CreateFileW(fileName.path, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        wcscpy(lpFileName->path, fileName.path);
        if ( *logFiles != (HANDLE)INVALID_HANDLE_VALUE )
        {
          SetFilePointer(*logFiles, FILE_BEGIN, 0, FILE_END);
        }
        LeaveCriticalSection(filesLock);
        ++logCategories;
        ++logFiles;
        ++lpFileName;
        ++filesLock;
      }
      while ( (signed int)logCategories < (signed int)CServerSocket::s_logComponents );
    }
    unused = -1;
    result = unguard();
  }
  else
  {
    unused = -1;
    result = unguard();
  }
  return result;
}

//----- (004104F0) --------------------------------------------------------
void CServerSocket::Send(CServerSocket *this, const char *format, ...)
{
  CIOBuffer *buffer; // eax@4
  CIOBuffer *buffer2; // esi@4
  int packetLength; // eax@4
  int totalLength; // ebx@6
  char v6; // [sp+4h] [bp-10h]@1
  int unused; // [sp+10h] [bp-4h]@1
  va_list va; // [sp+20h] [bp+Ch]@1

  va_start(va, format);
  guard(&v6, L"void CServerSocket::Send(const char* format, ...)");
  unused = 0;
  if ( format && this && this->d.m_socketStatus != SocketStatus_Closed )
  {
    buffer = CIOBuffer::Alloc();
    buffer2 = buffer;
    packetLength = PacketUtils::VAssemble((char *)&buffer->m_Buffer[2], 8190, format, va);
    if ( packetLength )
    {
      totalLength = packetLength + 2;
      buffer2->m_Buffer[0] = packetLength + 2;
      buffer2->m_Buffer[1] = BYTE1(totalLength);
      CIOCriticalSection::Enter(&this->d.m_socketWriteLock, 0, 0);
      buffer2->m_dwSize = totalLength;
      CIOSocket::Write((CIOSocket *)this, buffer2);
      CIOCriticalSection::Leave(&this->d.m_socketWriteLock, 0, 0);
    }
    else
    {
      CLog::Add_Ansi(&g_winlog, LOG_ERROR, "%d: assemble too large packet. format %s", socket, format);
      CIOBuffer::Release(buffer2);
    }
    unused = -1;
    unguard();
  }
  else
  {
    unused = -1;
    unguard();
  }
}

//----- (00410620) --------------------------------------------------------
bool __cdecl CServerSocket::packet00_SendLog(CServerSocket *socket, const unsigned __int8 *packet)
{
  int worldId; // ebx@1
  SYSTEMTIME systemTime; // [sp+Ch] [bp-35ACh]@2
  LogType logType; // [sp+1Ch] [bp-359Ch]@1
  char v6; // [sp+20h] [bp-3598h]@1
  int serverType; // [sp+24h] [bp-3594h]@1
  char etcNum3[64]; // [sp+28h] [bp-3590h]@2
  char locationZ[64]; // [sp+68h] [bp-3550h]@2
  char targetStr[64]; // [sp+A8h] [bp-3510h]@2
  char locationY[64]; // [sp+E8h] [bp-34D0h]@2
  char actorStr[64]; // [sp+128h] [bp-3490h]@2
  char locationX[64]; // [sp+168h] [bp-3450h]@2
  char etcNum9[64]; // [sp+1A8h] [bp-3410h]@2
  char logId[64]; // [sp+1E8h] [bp-33D0h]@2
  char etcNum7[64]; // [sp+228h] [bp-3390h]@2
  char etcNum1[64]; // [sp+268h] [bp-3350h]@2
  char etcNum5[64]; // [sp+2A8h] [bp-3310h]@2
  char actorAccountStr[64]; // [sp+2E8h] [bp-32D0h]@2
  char targetAccountStr[64]; // [sp+328h] [bp-3290h]@2
  char etcNum10[64]; // [sp+368h] [bp-3250h]@2
  char etcNum4[64]; // [sp+3A8h] [bp-3210h]@2
  char etcNum8[64]; // [sp+3E8h] [bp-31D0h]@2
  char etcNum2[64]; // [sp+428h] [bp-3190h]@2
  char etcNum6[64]; // [sp+468h] [bp-3150h]@2
  char etcStr3[512]; // [sp+4A8h] [bp-3110h]@2
  char actorAccount[512]; // [sp+6A8h] [bp-2F10h]@2
  char etcStr2[512]; // [sp+8A8h] [bp-2D10h]@2
  char actor[512]; // [sp+AA8h] [bp-2B10h]@2
  char targetAccount[512]; // [sp+CA8h] [bp-2910h]@2
  char actTime[512]; // [sp+EA8h] [bp-2710h]@2
  char etcStr1[512]; // [sp+10A8h] [bp-2510h]@2
  char target[512]; // [sp+12A8h] [bp-2310h]@2
  wchar_t sql[2048]; // [sp+14A8h] [bp-2110h]@2
  wchar_t logMessage[2178]; // [sp+24A8h] [bp-1110h]@1
  int v36; // [sp+35B4h] [bp-4h]@1

  guard(&v6, L"static bool LogSendLogPacket(CServerSocket* pSocket, const unsigned char* packet)");
  worldId = socket->d.m_worldId;
  memset(logMessage, 0, 0x1100u);
  v36 = 0;
  PacketUtils::Disassemble(packet, "ddS", &serverType, &logType, 0x1100, logMessage);
  if ( logType == LOG_DB )
  {
    memset(actTime, 0, sizeof(actTime));
    memset(logId, 0, sizeof(logId));
    memset(actor, 0, sizeof(actor));
    memset(actorAccount, 0, sizeof(actorAccount));
    memset(target, 0, sizeof(target));
    memset(targetAccount, 0, sizeof(targetAccount));
    memset(locationX, 0, sizeof(locationX));
    memset(locationY, 0, sizeof(locationY));
    memset(locationZ, 0, sizeof(locationZ));
    memset(etcStr1, 0, sizeof(etcStr1));
    memset(etcStr2, 0, sizeof(etcStr2));
    memset(etcStr3, 0, sizeof(etcStr3));
    memset(etcNum1, 0, sizeof(etcNum1));
    memset(etcNum2, 0, sizeof(etcNum2));
    memset(etcNum3, 0, sizeof(etcNum3));
    memset(etcNum4, 0, sizeof(etcNum4));
    memset(etcNum5, 0, sizeof(etcNum5));
    memset(etcNum6, 0, sizeof(etcNum6));
    memset(etcNum7, 0, sizeof(etcNum7));
    memset(etcNum8, 0, sizeof(etcNum8));
    memset(etcNum9, 0, sizeof(etcNum9));
    memset(etcNum10, 0, sizeof(etcNum10));
    memset(actorStr, 0, sizeof(actorStr));
    memset(actorAccountStr, 0, sizeof(actorAccountStr));
    memset(targetStr, 0, sizeof(targetStr));
    memset(targetAccountStr, 0, sizeof(targetAccountStr));
    CServerSocket::ParseLogData(logMessage, "sddddddddsssddddddddddssss", actTime, logId, actor, actorAccount, target, targetAccount, locationX, locationY, locationZ, etcStr1, etcStr2, etcStr3, etcNum1, etcNum2, etcNum3, etcNum4, etcNum5, etcNum6, etcNum7, etcNum8, etcNum9, etcNum10, actorStr, actorAccountStr, targetStr, targetAccountStr);
    sql[0] = 0;
    memset(&sql[1], 0, 0xFFCu);
    sql[2047] = 0;
    wsprintfW(sql, L"insert into %slog_realtime_%d(act_time, log_id, actor, actor_account, target, target_account, location_x, location_y, location_z, etc_str1, etc_str2, etc_str3, etc_num1, etc_num2, etc_num3, etc_num4, etc_num5, etc_num6, etc_num7, etc_num8, etc_num9, etc_num10, STR_actor, STR_actor_account, STR_target, STR_target_account) values(%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)\r\n", socket->d.m_yearMonthDay, worldId, actTime, logId, actor, actorAccount, target, targetAccount, locationX, locationY, locationZ, etcStr1, etcStr2, etcStr3, etcNum1, etcNum2, etcNum3, etcNum4, etcNum5, etcNum6, etcNum7, etcNum8, etcNum9, etcNum10, actorStr, actorAccountStr, targetStr, targetAccountStr);
    GetLocalTime(&systemTime);
    if ( !CServerSocket::CanAppend(socket, systemTime.wYear, systemTime.wMonth, systemTime.wDay, systemTime.wHour, systemTime.wMinute >= 30u) )
    {
      EnterCriticalSection(&socket->d.m_fileLock);
      CServerSocket::CreateNewLogFile(socket, systemTime.wYear, systemTime.wMonth, systemTime.wDay, systemTime.wHour, systemTime.wMinute >= 30u);
      LeaveCriticalSection(&socket->d.m_fileLock);
    }
    CServerSocket::WriteLogFile(socket, logType, sql);
    CSQLQueue::PushSQL(&g_sqlPollingQueue, sql);
  }
  else if ( logType == LOG_AUDIT )
  {
    memset(etcStr3, 0, sizeof(etcStr3));
    memset(targetAccountStr, 0, sizeof(targetAccountStr));
    memset(etcStr2, 0, sizeof(etcStr2));
    memset(etcStr1, 0, sizeof(etcStr1));
    memset(targetAccount, 0, sizeof(targetAccount));
    memset(target, 0, sizeof(target));
    memset(targetStr, 0, sizeof(targetStr));
    memset(actorAccountStr, 0, sizeof(actorAccountStr));
    memset(actorStr, 0, sizeof(actorStr));
    memset(actorAccount, 0, sizeof(actorAccount));
    memset(actor, 0, sizeof(actor));
    memset(actTime, 0, sizeof(actTime));
    memset(etcNum10, 0, sizeof(etcNum10));
    memset(etcNum9, 0, sizeof(etcNum9));
    memset(etcNum8, 0, sizeof(etcNum8));
    memset(etcNum7, 0, sizeof(etcNum7));
    memset(etcNum6, 0, sizeof(etcNum6));
    memset(etcNum5, 0, sizeof(etcNum5));
    memset(etcNum4, 0, sizeof(etcNum4));
    memset(etcNum3, 0, sizeof(etcNum3));
    memset(etcNum2, 0, sizeof(etcNum2));
    memset(etcNum1, 0, sizeof(etcNum1));
    memset(locationZ, 0, sizeof(locationZ));
    memset(locationY, 0, sizeof(locationY));
    memset(locationX, 0, sizeof(locationX));
    memset(logId, 0, sizeof(logId));
    CServerSocket::ParseLogData(logMessage, "sddddddddsssddddddddddssss", etcStr3, targetAccountStr, etcStr2, etcStr1, targetAccount, target, targetStr, actorAccountStr, actorStr, actorAccount, actor, actTime, etcNum10, etcNum9, etcNum8, etcNum7, etcNum6, etcNum5, etcNum4, etcNum3, etcNum2, etcNum1, locationZ, locationY, locationX, logId);
    sql[0] = 0;
    memset(&sql[1], 0, 0xFFCu);
    sql[2047] = 0;
    wsprintfW(sql, L"insert into %slog_audit_%d(act_time, log_id, actor, actor_account, target, target_account, location_x, location_y, location_z, etc_str1, etc_str2, etc_str3, etc_num1, etc_num2, etc_num3, etc_num4, etc_num5, etc_num6, etc_num7, etc_num8, etc_num9, etc_num10, STR_actor, STR_actor_account, STR_target, STR_target_account) values(%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s, %s,%s,%s,%s)\r\n", socket->d.m_yearMonthDay, worldId, etcStr3, targetAccountStr, etcStr2, etcStr1, targetAccount, target, targetStr, actorAccountStr, actorStr, actorAccount, actor, actTime, etcNum10, etcNum9, etcNum8, etcNum7, etcNum6, etcNum5, etcNum4, etcNum3, etcNum2, etcNum1, locationZ, locationY, locationX, logId);
    GetLocalTime(&systemTime);
    if ( !CServerSocket::CanAppend(socket, systemTime.wYear, systemTime.wMonth, systemTime.wDay, systemTime.wHour, systemTime.wMinute >= 30u) )
    {
      EnterCriticalSection(&socket->d.m_fileLock);
      CServerSocket::CreateNewLogFile(socket, systemTime.wYear, systemTime.wMonth, systemTime.wDay, systemTime.wHour, systemTime.wMinute >= 30u);
      LeaveCriticalSection(&socket->d.m_fileLock);
    }
    CServerSocket::WriteLogFile(socket, logType, sql);
    CSQLQueue::PushSQL(&g_sqlPollingQueue, sql);
  }
  else
  {
    GetLocalTime(&systemTime);
    if ( !CServerSocket::CanAppend(socket, systemTime.wYear, systemTime.wMonth, systemTime.wDay, systemTime.wHour, systemTime.wMinute >= 30u) )
    {
      EnterCriticalSection(&socket->d.m_fileLock);
      CServerSocket::CreateNewLogFile(socket, systemTime.wYear, systemTime.wMonth, systemTime.wDay, systemTime.wHour, systemTime.wMinute >= 30u);
      LeaveCriticalSection(&socket->d.m_fileLock);
    }
    CServerSocket::WriteLogFile(socket, logType, logMessage);
  }
  v36 = -1;
  unguard();
  return 0;
}

//----- (00410F70) --------------------------------------------------------
bool __cdecl CServerSocket::packet02_CheckLogD(CServerSocket *socket, const unsigned __int8 *packet)
{
  int v2; // eax@2
  int v4; // [sp+0h] [bp-14h]@1
  char v5; // [sp+4h] [bp-10h]@1
  int v6; // [sp+10h] [bp-4h]@1

  guard(&v5, L"static bool CheckLogDPacket(CServerSocket* pSocket, const unsigned char* packet)");
  v6 = 0;
  v4 = 0;
  PacketUtils::Disassemble(packet, L"d", &v4);
  if ( !CSQLQueue::s_dbSize || (v2 = 100 * CSQLQueue::s_dbUnusedSize / CSQLQueue::s_dbSize, v2 < 1) )
  {
    v2 = 1;
  }
  CServerSocket::Send(socket, "cd", LogD_CheckLog, v2);
  v6 = -1;
  unguard();
  return 0;
}
// 19D698C: using guessed type int CSQLQueue::s_dbSize;
// 19D6990: using guessed type int CSQLQueue::s_dbUnusedSize;

//----- (00411020) --------------------------------------------------------
bool __cdecl CServerSocket::packet03_ServerStarted(CServerSocket *socket, const unsigned __int8 *packet)
{
  ServerTypes serverType2; // ecx@3
  int unused_half; // edx@3
  int hour; // eax@3
  int half; // ST38_4@3
  int month; // edx@3
  ServerTypes serverType; // [sp+4h] [bp-102Ch]@1
  struct _SYSTEMTIME systemTime; // [sp+8h] [bp-1028h]@2
  int worldId; // [sp+18h] [bp-1018h]@1
  in_addr remoteAddr; // [sp+1Ch] [bp-1014h]@4
  char v12; // [sp+20h] [bp-1010h]@1
  WCHAR format; // [sp+24h] [bp-100Ch]@4
  int v14; // [sp+102Ch] [bp-4h]@1

  guard(&v12, L"static bool ServerStartedPacket(CServerSocket* pSocket, const unsigned char* packet)");
  v14 = 0;
  worldId = 0;
  serverType = 0;
  PacketUtils::Disassemble(packet, "dd", &worldId, &serverType);
  if ( (signed int)serverType > 0 )
  {
    GetLocalTime(&systemTime);
    if ( !CServerSocket::CanAppend(socket, systemTime.wYear, systemTime.wMonth, systemTime.wDay, systemTime.wHour, systemTime.wMinute >= 30u) )
    {
      EnterCriticalSection(&socket->d.m_fileLock);
      serverType2 = serverType;
      unused_half = -(systemTime.wMinute < 30u);
      socket->d.m_worldId = worldId;
      hour = systemTime.wHour;
      half = unused_half + 1;
      month = systemTime.wMonth;
      socket->d.m_serverType = serverType2;
      CServerSocket::CreateNewLogFile(socket, systemTime.wYear, month, systemTime.wDay, hour, half);
      LeaveCriticalSection(&socket->d.m_fileLock);
    }
    wsprintfW(&format, L"insert into %slog_realtime_%d(act_time, log_id, etc_num1, etc_num2) values('%d/%d/%d %d:%d:%d.%d',%d, %d, %d)\r\n", socket->d.m_yearMonthDay, worldId, systemTime.wYear, systemTime.wMonth, systemTime.wDay, systemTime.wHour, systemTime.wMinute, systemTime.wSecond, systemTime.wMilliseconds, 1306, serverType, worldId);
    CSQLQueue::PushSQL(&g_sqlPollingQueue, &format);
    socket->vtable->GetAddress(socket, &remoteAddr);
    CLog::Add(&g_winlog, LOG_NORMAL, L"Log connection from (%d.%d.%d.%d)", remoteAddr.S_un.S_un_b.s_b1, remoteAddr.S_un.S_un_b.s_b2, remoteAddr.S_un.S_un_b.s_b3, remoteAddr.S_un.S_un_b.s_b4);
  }
  v14 = -1;
  unguard();
  return 0;
}

//----- (004111F0) --------------------------------------------------------
int __thiscall CServerSocket::TimerExpired(CServerSocket *this, int timerId)
{
  CServerSocket *this_; // esi@1
  int checkStatus; // eax@1
  char v5; // [sp+4h] [bp-10h]@1
  int unused; // [sp+10h] [bp-4h]@1

  this_ = this;
  guard(&v5, L"void CServerSocket::TimerExpired(int id)");
  checkStatus = this_->d.m_checkStatus;
  unused = 0;
  if ( checkStatus && this_->d.m_socketStatus != SocketStatus_Closed )
  {
    CServerSocket::Send(this_, "cd", LogD_SetCheckStatus, 0);
    CIOObject::AddTimer((CIOObject *)this_, Config::s_serverReportInterval, 0);
  }
  unused = -1;
  return unguard();
}

//----- (00411280) --------------------------------------------------------
int __thiscall CServerSocket::OnRead(CServerSocket *this)
{
  CServerSocket *this_; // esi@1
  CIOBuffer *buffer; // edx@1
  int socketStatus; // eax@1
  int buffSize; // ecx@1
  signed __int32 readBytes; // edi@1
  int socketStatus2; // eax@5
  int payloadLength; // eax@7
  CPacket *packet; // ebp@13
  volatile __int32 nAlloc; // eax@13
  CIOBuffer *buffer3; // ecx@16
  CServerSocket_Vtable *this2; // edx@16
  char v13; // [sp+Ch] [bp-1Ch]@1
  CIOBuffer *buffer4; // [sp+10h] [bp-18h]@1
  int buffSize2; // [sp+14h] [bp-14h]@1
  CPacket *packet2; // [sp+18h] [bp-10h]@13
  int unused; // [sp+24h] [bp-4h]@1

  this_ = this;
  guard(&v13, L"CServerSocket::OnRead()");
  buffer = this_->d.base.m_pReadBuf;
  socketStatus = this_->d.m_socketStatus;
  buffSize = buffer->m_dwSize;
  readBytes = 0;
  unused = 0;
  buffer4 = buffer;
  buffSize2 = buffSize;
  if ( socketStatus == SocketStatus_Closed || this_->d.base.m_nPendingWrite > (signed int)&dword_800000 )
  {
    CIOSocket::Close((CIOSocket *)this_);
    unused = -1;
    return unguard();
  }
  if ( buffSize <= 0 )
  {
LABEL_18:
    CIOSocket::Read((CIOSocket *)this_, 0);
    goto LABEL_22;
  }
  while ( 1 )
  {
    socketStatus2 = this_->d.m_socketStatus;
    if ( socketStatus2 )
    {
      break;
    }
    if ( readBytes + 2 > buffSize )
    {
      goto LABEL_24;
    }
    payloadLength = (buffer->m_Buffer[readBytes + 1] << 8) + buffer->m_Buffer[readBytes] - 2;
    this_->d.m_packetSize = payloadLength;
    if ( payloadLength <= 0 || payloadLength >= 0x2000 )
    {
      CLog::Add(&g_winlog, LOG_ERROR, L"%d: bad packet size %d", socket, payloadLength);
      goto LABEL_20;
    }
    readBytes += 2;
    this_->d.m_socketStatus = SocketStatus_BytesRead;
LABEL_17:
    if ( readBytes >= buffSize )
    {
      goto LABEL_18;
    }
  }
  if ( socketStatus2 != SocketStatus_BytesRead )
  {
    goto LABEL_21;
  }
  if ( readBytes + this_->d.m_packetSize <= buffSize )
  {
    if ( buffer->m_Buffer[readBytes] < 4u )
    {
      packet = (CPacket *)Allocator::allocate(&g_mmu, sizeof(CPacket), 1, L"CPacket");// CPacket operator_new inlined
      InterlockedIncrement((volatile LONG *)(4 * CPacket::s_nAlloc + 0x455E50));
      nAlloc = CPacket::s_nAlloc;
      Allocator::g_allocatedObjName[CPacket::s_nAlloc] = "CPacket";
      Allocator::g_allocatedMemory[nAlloc] = sizeof(CPacket);
      packet2 = packet;
      LOBYTE(unused) = 1;
      if ( packet )
      {
        MemoryObject::MemoryObject((MemoryObject *)packet);
        packet->vtable = (CIOObject_Vtable *)&CLogPacket_vtable_425334;
      }
      else
      {
        packet = 0;
      }
      buffer3 = buffer4;
      packet->d.m_pSocket = (CLogSocket *)this_;
      packet->d.m_pBuf = this_->d.base.m_pReadBuf;
      packet->d.m_pFunc = this_->d.m_packetHandlers[buffer3->m_Buffer[readBytes]];
      this2 = this_->vtable;
      LOBYTE(unused) = 0;
      this2->base.base.base.AddRef((MemoryObject *)this_, "serversocket.cpp", 638, ORT_IO_RETAIN);
      InterlockedIncrement(&this_->d.base.m_pReadBuf->m_nRefCount);
      InterlockedIncrement(&CPacket::g_nPendingPacket);
      packet->vtable->PostObject((CIOObject *)packet, readBytes);
      buffer = buffer4;
      buffSize = buffSize2;
      readBytes += this_->d.m_packetSize;
      this_->d.m_socketStatus = SocketStatus_Init;
      goto LABEL_17;
    }
    CLog::Add(&g_winlog, LOG_ERROR, L"unknown protocol %d", buffer->m_Buffer[readBytes]);
LABEL_20:
    this_->d.m_socketStatus = SocketStatus_Closed;
LABEL_21:
    CIOSocket::Close((CIOSocket *)this_);
    goto LABEL_22;
  }
LABEL_24:
  CIOSocket::Read((CIOSocket *)this_, buffSize - readBytes);
LABEL_22:
  unused = -1;
  return unguard();
}
// 425334: using guessed type void *CLogPacket_vtable_425334;
// 800000: using guessed type int dword_800000;
// 1BD3B5C: using guessed type int g_mmu;

//----- (004114E0) --------------------------------------------------------
int __thiscall CSQLQueue::SpaceUsed(CSQLQueue *this, int force)
{
  CSQLQueue *this_; // esi@1
  __int32 unusedSizeInt; // eax@5
  int freeSpace; // eax@6
  char v6; // [sp+Ch] [bp-A24h]@1
  wchar_t dbSize[255]; // [sp+10h] [bp-A20h]@4
  wchar_t unusedSize[255]; // [sp+210h] [bp-820h]@4
  wchar_t objname[255]; // [sp+410h] [bp-620h]@4
  DBConn sql; // [sp+610h] [bp-420h]@4
  int unused; // [sp+A2Ch] [bp-4h]@1

  this_ = this;
  guard(&v6, L"void CSQLQueue::SpaceUsed(int nForce)");
  unused = 0;
  EnterCriticalSection(&this_->m_lock);
  if ( force == true || time(0) - CSQLQueue::s_lastSpaceCheck > 21600 )// 6 hours
  {
    CSQLQueue::s_lastSpaceCheck = time(0);
    LeaveCriticalSection(&this_->m_lock);
    DBConn::DBConn(&sql);
    objname[0] = 0;
    memset(&objname[1], 0, 508u);
    dbSize[0] = 0;
    memset(&dbSize[1], 0, 508u);
    unusedSize[0] = 0;
    memset(&unusedSize[1], 0, 508u);
    LOBYTE(unused) = 1;
    DBConn::Bind(&sql, objname, 510);
    DBConn::Bind(&sql, dbSize, 510);
    DBConn::Bind(&sql, unusedSize, 510);
    if ( DBConn::Execute(&sql, aExecSp_spaceused) )
    {
      DBConn::Fetch(&sql);
      CSQLQueue::s_dbSize = Utils::GetIntFromString(dbSize);
      unusedSizeInt = Utils::GetIntFromString(unusedSize);
      CSQLQueue::s_dbUnusedSize = unusedSizeInt;
      if ( CSQLQueue::s_dbSize )
      {
        freeSpace = 100 * unusedSizeInt / CSQLQueue::s_dbSize;
      }
      else
      {
        freeSpace = 0;
      }
      CLog::Add(&g_winlog, 0, L"name(%s), size(%s), unused(%s) free space(%d %%)", objname, dbSize, unusedSize, freeSpace);
    }
    LOBYTE(unused) = 0;
    DBConn::DestructorDBConn(&sql);
  }
  else
  {
    LeaveCriticalSection(&this_->m_lock);
  }
  unused = -1;
  return unguard();
}
// 19D6988: using guessed type int CSQLQueue::s_lastSpaceCheck;
// 19D698C: using guessed type int CSQLQueue::s_dbSize;
// 19D6990: using guessed type int CSQLQueue::s_dbUnusedSize;

//----- (004116C0) --------------------------------------------------------
_DWORD *__cdecl sub_4116C0(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax@1
  char *v4; // ecx@2

  result = a2;
  if ( !a2 )
  {
    return result;
  }
  v4 = (char *)a2;
  result = a1;
  do
  {
    if ( result )
    {
      *result = *a3;
    }
    ++result;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (004116F0) --------------------------------------------------------
std::wstring *__cdecl MMU::Allocator::construct(std::wstring *a1, std::wstring *_Right)
{
  std::wstring *result; // eax@1

  result = 0;
  if ( !a1 )
  {
    return result;
  }
  a1->_Mysize = 0;
  a1->_Myres = 139;
  a1->m_buffer[0] = 0;
  result = std::string::assign(a1, _Right, 0, 0xFFFFFFFF);
  return result;
}

//----- (00411750) --------------------------------------------------------
void __thiscall std::dequeue_string::Destructor(std::dequeue_string *this)
{
  std::dequeue_string *this_; // esi@1
  int size; // eax@2
  unsigned int _Newoff; // eax@3
  unsigned int _Mapsize; // ecx@3
  bool v5; // zf@5
  unsigned int _Count; // edi@8
  std::wstring *v7; // ecx@9

  this_ = this;
  while ( this_->_Mysize )                      // _Tidy
  {
    size = this_->_Mysize;
    if ( size )                                 // pop_back
    {
      _Newoff = size + this_->_Myoff - 1;
      _Mapsize = this_->_Mapsize;
      if ( _Mapsize <= _Newoff )
      {
        _Newoff -= _Mapsize;
      }
      MMU::Allocator::destroy(this_->_Map[_Newoff]);
      v5 = this_->_Mysize-- == 1;
      if ( v5 )
      {
        this_->_Myoff = 0;
      }
    }                                           // /pop_back
  }
  _Count = this_->_Mapsize;
  while ( _Count > 0 )
  {
    v7 = this_->_Map[_Count-- - 1];
    j__free(v7);
  }
  j__free(this_->_Map);
  this_->_Mapsize = 0;
  this_->_Map = 0;
}

//----- (004117D0) --------------------------------------------------------
void __noreturn sub_4117D0()
{
  char v0; // [sp+0h] [bp-50h]@1
  char v1; // [sp+4h] [bp-4Ch]@1
  int v2; // [sp+14h] [bp-3Ch]@1
  int v3; // [sp+18h] [bp-38h]@1
  int (__thiscall **v4)(void *, char); // [sp+1Ch] [bp-34h]@1
  int v5; // [sp+4Ch] [bp-4h]@1

  v3 = 15;
  v2 = 0;
  v1 = 0;
  sub_405710((int)&v0, "deque<T> too long", strlen("deque<T> too long"));
  v5 = 0;
  sub_4057B0(&v4, (int)&v0);
  v4 = &std::length_error::`vftable';
  _CxxThrowException(&v4, &unk_42AC38);
}
// 413348: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 4293B4: using guessed type int (__thiscall *std::length_error::`vftable')(void *, char);

//----- (00411850) --------------------------------------------------------
char __thiscall CSQLQueue::ExecSQL(CSQLQueue *this)
{
  CSQLQueue *this_; // esi@1
  int sqlQueueSize; // ST0C_4@1
  unsigned int _Block; // eax@2
  unsigned int _Mapsize; // ecx@2
  std::wstring *taken_str_ref; // ST04_4@4
  const wchar_t *c_str; // eax@4
  std::wstring *deleted_str; // edi@7
  unsigned int _Myres; // eax@7
  int res_plus_one; // ST0C_4@8
  wchar_t *_Ptr; // eax@8
  unsigned int last2; // ecx@9
  unsigned int v12; // eax@9
  bool empty; // zf@11
  char v15; // [sp+14h] [bp-454Ch]@1
  std::wstring str_copy; // [sp+18h] [bp-4548h]@4
  DBConn sql; // [sp+140h] [bp-4420h]@1
  wchar_t format[8192]; // [sp+550h] [bp-4010h]@1
  wchar_t *unused; // [sp+455Ch] [bp-4h]@1

  this_ = this;
  guard(&v15, L"bool CSQLQueue::ExecSQL()");
  unused = 0;
  CSQLQueue::SpaceUsed(this_, 0);
  format[0] = 0;
  memset(&format[1], 0, 0x3FFCu);
  format[0x1FFF] = 0;
  DBConn::DBConn(&sql);
  sqlQueueSize = this_->m_queue._Mysize;
  LOBYTE(unused) = 1;
  CLog::Add(&g_winlog, 0, L"sql queue(%d)", sqlQueueSize);
  if ( this_->m_queue._Mysize )
  {
    do
    {
      EnterCriticalSection(&this_->m_lock);
      memset(format, 0, sizeof(format));
      _Block = this_->m_queue._Myoff;
      _Mapsize = this_->m_queue._Mapsize;
      if ( _Mapsize <= _Block )
      {
        _Block -= _Mapsize;
      }
      taken_str_ref = this_->m_queue._Map[_Block];
      str_copy._Myres = 139;                    // std::string constructor
      str_copy._Mysize = 0;
      str_copy.m_buffer[0] = 0;                 // /std::string constructor
      std::string::assign(&str_copy, taken_str_ref, 0u, 0xFFFFFFFF);
      c_str = *(const wchar_t **)&str_copy.m_buffer[0];
      LOBYTE(unused) = 2;
      if ( str_copy._Myres < 140u )
      {
        c_str = str_copy.m_buffer;
      }
      wcscpy(format, c_str);
      if ( this_->m_queue._Mysize )
      {
        deleted_str = this_->m_queue._Map[this_->m_queue._Myoff];
        _Myres = deleted_str->_Myres;           // _Tidy 
        if ( _Myres >= 140 )
        {
          res_plus_one = _Myres + 1;
          _Ptr = sub_406470(deleted_str);
          Mybase::_Alval_deallocate((int)_Ptr, res_plus_one);
        }
        deleted_str->_Myres = 139;              // _BUF_SIZE -1
        Traits::assign(deleted_str, 0);         // /_Tidy 
        last2 = this_->m_queue._Mapsize;
        v12 = this_->m_queue._Myoff + 1;
        this_->m_queue._Myoff = v12;
        if ( last2 <= v12 )
        {
          this_->m_queue._Myoff = 0;
        }
        empty = this_->m_queue._Mysize-- == 1;
        if ( empty )
        {
          this_->m_queue._Myoff = 0;
        }
      }
      LeaveCriticalSection(&this_->m_lock);
      DBConn::Execute(&sql, format);
      DBConn::ResetHtmt(&sql);
      LOBYTE(unused) = 1;
      if ( str_copy._Myres >= 140u && *(_DWORD *)&str_copy.m_buffer[0] )// std::string destructor
      {
        MMU::deallocate(&g_mmu, *(void **)&str_copy.m_buffer[0]);
      }
      empty = this_->m_queue._Mysize == 0;
      str_copy._Myres = 139;
      str_copy._Mysize = 0;
      str_copy.m_buffer[0] = 0;
    }
    while ( !empty );
  }
  LOBYTE(unused) = 0;
  DBConn::DestructorDBConn(&sql);
  unused = (wchar_t *)-1;
  unguard();
  return 1;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (00411A70) --------------------------------------------------------
std::vector_string::iterator *__thiscall std::dequeue_string::_Growmap(std::dequeue_string *this, unsigned int a2)
{
  unsigned int v2; // ebx@1
  std::dequeue_string *v3; // esi@1
  unsigned int v4; // ecx@3
  unsigned int v5; // eax@3
  _DWORD *v6; // edi@8
  std::wstring **v7; // ebp@8
  _DWORD *v8; // eax@8
  std::wstring **v9; // ecx@8
  _DWORD *v10; // eax@9
  std::wstring **v11; // eax@10
  _DWORD *v12; // eax@10
  std::vector_string::iterator *result; // eax@11

  v2 = a2;
  v3 = this;
  if ( (unsigned int)&stru_E07038 - this->_Mapsize < a2 )
  {
    sub_4117D0();
  }
  v4 = this->_Mapsize;
  v5 = (unsigned int)v3->_Mapsize >> 1;
  if ( v5 < 8 )
  {
    v5 = 8;
  }
  if ( a2 < v5 && v4 <= (unsigned int)&stru_E07038 - v5 )
  {
    v2 = v5;
  }
  v6 = (_DWORD *)v3->_Myoff;
  v7 = (std::wstring **)operator new(4 * (v4 + v2));
  v8 = sub_409C40(&v3->_Map[(_DWORD)v6], &v3->_Map[v3->_Mapsize], &v7[(_DWORD)v6]);
  v9 = v3->_Map;
  if ( (unsigned int)v6 > v2 )
  {
    sub_409C40(v9, &v9[v2], v8);
    v11 = v3->_Map;
    a2 = 0;
    v12 = sub_409C40(&v11[v2], &v11[(_DWORD)v6], v7);
    sub_4116C0(v12, (_DWORD *)v2, &a2);
  }
  else
  {
    a2 = 0;
    v10 = sub_409C40(v9, &v9[(_DWORD)v6], v8);
    sub_4116C0(v10, (_DWORD *)(v2 - (_DWORD)v6), &a2);
    a2 = 0;
    sub_4116C0(v7, v6, &a2);
  }
  j__free(v3->_Map);
  result = (std::vector_string::iterator *)(v2 + v3->_Mapsize);
  v3->_Map = v7;
  v3->_Mapsize = (int)result;
  return result;
}

//----- (00411C20) --------------------------------------------------------
int __thiscall std::dequeue_string::push(std::dequeue_string *this, std::wstring *str)
{
  std::dequeue_string *this_; // esi@1
  unsigned int v3; // eax@3
  unsigned int _Block; // edi@3
  int result; // eax@7

  this_ = this;
  if ( this->_Mapsize <= (unsigned int)(this->_Mysize + 1) )
  {
    std::dequeue_string::_Growmap(this, 1u);
  }
  v3 = this_->_Mapsize;
  _Block = this_->_Mysize + this_->_Myoff;
  if ( v3 <= _Block )
  {
    _Block -= v3;
  }
  if ( !this_->_Map[_Block] )
  {
    this_->_Map[_Block] = (std::wstring *)operator new(292u);// this->_Alval.allocate 1 element
  }
  MMU::Allocator::construct(this_->_Map[_Block], str);
  result = this_->_Mysize + 1;
  this_->_Mysize = result;
  return result;
}

//----- (00411C90) --------------------------------------------------------
CSQLQueue *__thiscall CSQLQueue::CSQLQueue(CSQLQueue *this)
{
  CSQLQueue *this_; // esi@1
  char v3; // [sp+4h] [bp-14h]@1
  CSQLQueue *v4; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  this_ = this;
  v4 = this;
  this->m_queue._Map = 0;                       // ctor
  this->m_queue._Mapsize = 0;
  this->m_queue._Myoff = 0;
  this->m_queue._Mysize = 0;                    // ctor
  v5 = 0;
  guard(&v3, L"CSQLQueue::CSQLQueue()");
  InitializeCriticalSection(&this_->m_lock);
  unguard();
  return this_;
}

//----- (00411D00) --------------------------------------------------------
char CSQLQueue::PushSQL(CSQLQueue *this, const wchar_t *format, ...)
{
  int strLen; // eax@1
  char v4; // [sp+10h] [bp-4138h]@1
  std::wstring str; // [sp+14h] [bp-4134h]@1
  wchar_t sqlQuery[8192]; // [sp+138h] [bp-4010h]@1
  int v7; // [sp+4144h] [bp-4h]@1
  va_list va; // [sp+4158h] [bp+10h]@1

  va_start(va, format);
  guard(&v4, L"bool CSQLQueue::PushSQL(const WCHAR *format, ...)");
  v7 = 0;
  EnterCriticalSection(&this->m_lock);
  sqlQuery[0] = 0;
  memset(&sqlQuery[1], 0, 0x3FFCu);
  sqlQuery[8191] = 0;
  vswprintf(sqlQuery, format, va);
  str._Myres = 139;                             // ctor
  str._Mysize = 0;
  str.m_buffer[0] = 0;                          // /ctor
  strLen = wcslen(sqlQuery);
  std::string::assign_c_str(&str, sqlQuery, strLen);
  LOBYTE(v7) = 1;
  std::dequeue_string::push(&this->m_queue, &str);
  LOBYTE(v7) = 0;
  if ( str._Myres >= 140u && *(_DWORD *)&str.m_buffer[0] )// destructor
  {
    MMU::deallocate(&g_mmu, *(void **)&str.m_buffer[0]);
  }
  str._Myres = 139;
  str._Mysize = 0;
  str.m_buffer[0] = 0;                          // /destructor
  LeaveCriticalSection(&this->m_lock);
  v7 = -1;
  unguard();
  return 1;
}
// 1BD3B5C: using guessed type int g_mmu;

//----- (00411F67) --------------------------------------------------------
void __thiscall sub_411F67(int this)
{
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  exception::~exception(this);
}
// 4293F4: using guessed type int (__thiscall *std::bad_alloc::`vftable')(void *, char);

//----- (00411F72) --------------------------------------------------------
void *__thiscall sub_411F72(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_411F67((int)this);
  if ( a2 & 1 )
  {
    j__free(v2);
  }
  return v2;
}

//----- (004121D5) --------------------------------------------------------
int __cdecl sub_4121D5(int a1, int a2)
{
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(_getptd() + 132);
  *(_DWORD *)(_getptd() + 132) = a1;
  return a1;
}

//----- (0041221E) --------------------------------------------------------
int __cdecl sub_41221E(int a1)
{
  int result; // eax@2

  if ( a1 == *(_DWORD *)(_getptd() + 132) )
  {
    result = _getptd();
    *(_DWORD *)(result + 132) = *(_DWORD *)(a1 + 4);
  }
  else
  {
    for ( result = *(_DWORD *)(_getptd() + 132); ; result = *(_DWORD *)(result + 4) )
    {
      if ( !*(_DWORD *)(result + 4) )
      {
        _inconsistency();
      }
      if ( a1 == *(_DWORD *)(result + 4) )
      {
        break;
      }
    }
    *(_DWORD *)(result + 4) = *(_DWORD *)(a1 + 4);
  }
  return result;
}
// 41538F: using guessed type void __cdecl _inconsistency();

//----- (0041313B) --------------------------------------------------------
void __stdcall Static_Init_For_Arrays(std::vector_CritSection *this_, unsigned int a2, int size, int initFunc, void (__thiscall *a5)(void *))
{
  int i; // [sp+Ch] [bp-20h]@1

  for ( i = 0; i < size; ++i )
  {
    ((void (__thiscall *)(std::vector_CritSection *))initFunc)(this_);
    this_ = (std::vector_CritSection *)((char *)this_ + a2);
  }
}

//----- (0041325B) --------------------------------------------------------
LPVOID __cdecl calloc_crt(int a1, int a2)
{
  unsigned int v2; // esi@1
  LPVOID v3; // edi@3
  LPVOID result; // eax@12
  void *v5; // [sp+Ch] [bp-20h]@6
  unsigned int v6; // [sp+10h] [bp-1Ch]@1

  v2 = a2 * a1;
  v6 = a2 * a1;
  if ( !(a2 * a1) )
  {
    ++v2;
  }
  while ( 1 )
  {
    v3 = 0;
    if ( v2 <= 0xFFFFFFE0 )
    {
      if ( dword_1BD6D00 == 3 )
      {
        v2 = (v2 + 15) & 0xFFFFFFF0;
        if ( v6 <= dword_1BD6CEC )
        {
          _lock(4);
          v5 = (void *)__sbh_alloc_block(v6);
          _unlock(4);
          v3 = v5;
          if ( !v5 )
          {
LABEL_9:
            v3 = HeapAlloc(hHeap, 8u, v2);
            goto LABEL_10;
          }
          memset(v5, 0, v6);
        }
      }
      if ( v3 )
      {
        return v3;
      }
      goto LABEL_9;
    }
LABEL_10:
    if ( v3 )
    {
      return v3;
    }
    if ( !dword_1BD5728 )
    {
      return v3;
    }
    result = (LPVOID)_callnewh(v2);
    if ( !result )
    {
      return result;
    }
  }
}
// 4146DF: using guessed type _DWORD __cdecl _callnewh(_DWORD);
// 4177C6: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 41785A: using guessed type _DWORD __cdecl _lock(_DWORD);
// 4180B2: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 1BD6CEC: using guessed type int dword_1BD6CEC;
// 1BD6D00: using guessed type int dword_1BD6D00;

//----- (0041343D) --------------------------------------------------------
exception *__thiscall sub_41343D(exception *this, char *a2)
{
  exception *v2; // esi@1

  v2 = this;
  exception::exception(this, (const char *const *)&a2);
  *(_DWORD *)v2 = &bad_typeid::`vftable';
  return v2;
}
// 4294E8: using guessed type int (__thiscall *bad_typeid::`vftable')(void *, char);

//----- (00413456) --------------------------------------------------------
_DWORD *__thiscall sub_413456(_DWORD *this, int a2)
{
  _DWORD *v2; // esi@1

  v2 = this;
  exception::exception(a2);
  *v2 = &bad_typeid::`vftable';
  return v2;
}
// 4133D0: using guessed type _DWORD __stdcall exception::exception(_DWORD);
// 4294E8: using guessed type int (__thiscall *bad_typeid::`vftable')(void *, char);

//----- (0041346E) --------------------------------------------------------
exception *__thiscall sub_41346E(exception *this, char *a2)
{
  exception *v2; // esi@1

  v2 = this;
  sub_41343D(this, a2);
  *(_DWORD *)v2 = &__non_rtti_object::`vftable';
  return v2;
}
// 4294F4: using guessed type int (__thiscall *__non_rtti_object::`vftable')(void *, char);

//----- (0041349E) --------------------------------------------------------
void __thiscall sub_41349E(void *this)
{
  *(_DWORD *)this = &bad_typeid::`vftable';
  exception::~exception((int)this);
}
// 4294E8: using guessed type int (__thiscall *bad_typeid::`vftable')(void *, char);

//----- (004134A9) --------------------------------------------------------
void *__thiscall sub_4134A9(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  exception::~exception((int)this);
  if ( a2 & 1 )
  {
    j__free(v2);
  }
  return v2;
}

//----- (004134C5) --------------------------------------------------------
void *__thiscall sub_4134C5(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_41349E(this);
  if ( a2 & 1 )
  {
    j__free(v2);
  }
  return v2;
}

//----- (0041350A) --------------------------------------------------------
void *__thiscall sub_41350A(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  type_info::~type_info((#97 *)this);
  if ( a2 & 1 )
  {
    j__free(v2);
  }
  return v2;
}
// 4134E1: using guessed type _DWORD __thiscall type_info::~type_info(#97 *__hidden this);

//----- (00413C15) --------------------------------------------------------
wchar_t *__cdecl Utils::ToWString(int number, wchar_t *outStr, int maxSize)
{
  char buffer[20]; // [sp+0h] [bp-18h]@1
  unsigned int v5; // [sp+14h] [bp-4h]@1
  unsigned int retaddr; // [sp+1Ch] [bp+4h]@1

  v5 = retaddr ^ dword_42DDB4;
  _itoa(number, buffer, maxSize);
  mbstowcs(outStr, buffer, 20u);
  return outStr;
}
// 42DDB4: using guessed type int dword_42DDB4;

//----- (00413D9D) --------------------------------------------------------
wchar_t *__cdecl Utils::TimeToStr(time_t *a1)
{
  struct tm *localTime; // eax@1
  wchar_t *result; // eax@2

  localTime = localtime(a1);
  if ( localTime )
  {
    result = _wasctime(localTime);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00413FDD) --------------------------------------------------------
int __cdecl typeid(CIOSocket *this_, int a)
{
  void (__thiscall *v2)(CIOSocket *); // esi@4
  int result; // eax@5
  char v4; // [sp+18h] [bp-34h]@6
  void (__thiscall *v5)(CIOSocket *); // [sp+24h] [bp-28h]@4
  char v6; // [sp+28h] [bp-24h]@2
  CPPEH_RECORD ms_exc; // [sp+34h] [bp-18h]@4

  if ( !this_ )
  {
    sub_41343D((exception *)&v6, "Attempted a typeid of NULL pointer!");
    _CxxThrowException(&v6, &unk_42BC98);
  }
  ms_exc.registration.TryLevel = 0;
  v2 = this_->vtable[-1].OnRead;
  v5 = v2;
  if ( IsBadReadPtr(*((const void **)v2 + 3), 8u) )
  {
    sub_41346E((exception *)&v4, "Bad read pointer - no RTTI data!");
    _CxxThrowException(&v4, &unk_42BC88);
  }
  result = *((_DWORD *)v2 + 3);
  ms_exc.registration.TryLevel = -1;
  return result;
}
// 413348: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (0041450D) --------------------------------------------------------
int start()
{
  void *v0; // esp@1
  HMODULE v1; // eax@3
  int v2; // ecx@4
  int v3; // eax@5
  int v4; // eax@9
  bool v5; // zf@9
  int v6; // eax@23
  signed int v7; // eax@26
  int v8; // ST0C_4@28
  char *v9; // ST08_4@28
  HMODULE v10; // eax@28
  int v11; // eax@28
  int v12; // edi@28
  signed int v14; // [sp-94h] [bp-110h]@1
  int v15; // [sp-90h] [bp-10Ch]@1
  int v16; // [sp-8Ch] [bp-108h]@1
  __int16 v17; // [sp-88h] [bp-104h]@1
  int v18; // [sp-84h] [bp-100h]@1
  int v19; // [sp+10h] [bp-6Ch]@28
  char *lpCmdLine; // [sp+14h] [bp-68h]@25
  struct _STARTUPINFOA StartupInfo; // [sp+18h] [bp-64h]@25
  int v22; // [sp+5Ch] [bp-20h]@23
  int v23; // [sp+60h] [bp-1Ch]@7
  CPPEH_RECORD ms_exc; // [sp+64h] [bp-18h]@1

  v0 = alloca(148);
  ms_exc.old_esp = (DWORD)&v14;
  v14 = 148;
  GetVersionExA((LPOSVERSIONINFOA)&v14);
  dword_1BD5498 = v18;
  dword_1BD54A4 = v15;
  dword_1BD54A8 = v16;
  dword_1BD549C = v17 & 0x7FFF;
  if ( v18 != 2 )
  {
    dword_1BD549C = v17 & 0x7FFF | 0x8000;
  }
  dword_1BD54A0 = v16 + (v15 << 8);
  v1 = GetModuleHandleA(0);
  if ( *(_WORD *)v1 != 23117 )
  {
    goto LABEL_7;
  }
  v2 = (int)v1 + *((_DWORD *)v1 + 15);
  if ( *(_DWORD *)v2 != 17744 )
  {
    goto LABEL_7;
  }
  v3 = *(_WORD *)(v2 + 24);
  if ( v3 == 267 )
  {
    if ( *(_DWORD *)(v2 + 116) > 0xEu )
    {
      v4 = 0;
      v5 = *(_DWORD *)(v2 + 232) == 0;
      goto LABEL_12;
    }
LABEL_7:
    v23 = 0;
    goto LABEL_13;
  }
  if ( v3 != 523 || *(_DWORD *)(v2 + 132) <= 0xEu )
  {
    goto LABEL_7;
  }
  v4 = 0;
  v5 = *(_DWORD *)(v2 + 248) == 0;
LABEL_12:
  LOBYTE(v4) = !v5;
  v23 = v4;
LABEL_13:
  if ( !_heap_init(1) )
  {
    fast_error_exit(0x1Cu);
  }
  if ( !winApi::initTls() )
  {
    fast_error_exit(0x10u);
  }
  sub_41B40C();
  ms_exc.registration.TryLevel = 0;
  if ( _ioinit() < 0 )
  {
    _amsg_exit(0x1Bu);
  }
  dword_1BD6D14 = (int)GetCommandLineA();
  dword_1BD5484 = (char *)__crtGetEnvironmentStringsA();
  if ( sub_41B248() < 0 )
  {
    _amsg_exit(8u);
  }
  if ( _setenvp() < 0 )
  {
    _amsg_exit(9u);
  }
  v6 = Static_Objects_initialization();
  v22 = v6;
  if ( v6 )
  {
    _amsg_exit(v6);
  }
  StartupInfo.dwFlags = 0;
  GetStartupInfoA(&StartupInfo);
  lpCmdLine = sub_41AFAC();
  if ( StartupInfo.dwFlags & 1 )
  {
    v7 = StartupInfo.wShowWindow;
  }
  else
  {
    v7 = 10;
  }
  v8 = v7;
  v9 = lpCmdLine;
  v10 = GetModuleHandleA(0);
  v11 = WinMain(v10, 0, v9, v8);
  v12 = v11;
  v19 = v11;
  if ( !v23 )
  {
    exit(v11);
  }
  _cexit();
  return v12;
}
// 4176D7: using guessed type _DWORD __cdecl _heap_init(_DWORD);
// 418727: using guessed type int _ioinit(void);
// 41B015: using guessed type int _setenvp(void);
// 41B2EA: using guessed type int __crtGetEnvironmentStringsA(void);
// 1BD5498: using guessed type int dword_1BD5498;
// 1BD549C: using guessed type int dword_1BD549C;
// 1BD54A0: using guessed type int dword_1BD54A0;
// 1BD54A4: using guessed type int dword_1BD54A4;
// 1BD54A8: using guessed type int dword_1BD54A8;
// 1BD6D14: using guessed type int dword_1BD6D14;

//----- (00414B5C) --------------------------------------------------------
int __cdecl sub_414B5C(int a1, int a2, int a3, int a4)
{
  signed int v4; // esi@1
  int v5; // eax@1
  int v6; // eax@6
  int v7; // ecx@6
  int result; // eax@9

  v4 = *(_DWORD *)(a1 + 8);
  v5 = _getptd();
  ++*(_DWORD *)(v5 + 128);
  while ( v4 != a4 )
  {
    if ( v4 <= -1 || v4 >= *(_DWORD *)(a3 + 4) )
    {
      _inconsistency();
    }
    v6 = 8 * v4;
    v7 = 8 * v4 + *(_DWORD *)(a3 + 8);
    v4 = *(_DWORD *)v7;
    if ( *(_DWORD *)(v7 + 4) )
    {
      *(_DWORD *)(a1 + 8) = v4;
      _CallSettingFrame(*(_DWORD *)(*(_DWORD *)(a3 + 8) + v6 + 4), a1, 259);
    }
  }
  result = _getptd();
  if ( *(_DWORD *)(result + 128) > 0 )
  {
    result = _getptd() + 128;
    --*(_DWORD *)result;
  }
  if ( v4 != a4 )
  {
    _inconsistency();
  }
  *(_DWORD *)(a1 + 8) = v4;
  return result;
}
// 41538F: using guessed type void __cdecl _inconsistency();
// 415640: using guessed type _DWORD __stdcall _CallSettingFrame(_DWORD, _DWORD, _DWORD);

//----- (00414C8C) --------------------------------------------------------
void *__cdecl sub_414C8C(int a1, struct EHRegistrationNode *a2, int a3, struct _s_FuncInfo *a4, int a5, unsigned __int32 a6)
{
  void *v6; // ecx@0
  void *v7; // ebx@1
  int v8; // ST40_4@1
  int v9; // ST3C_4@1
  int v10; // ST38_4@1
  char v12; // al@7
  char v13; // [sp+30h] [bp-2Ch]@1
  int v14; // [sp+38h] [bp-24h]@1
  int v15; // [sp+3Ch] [bp-20h]@1
  void *v16; // [sp+40h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+44h] [bp-18h]@1

  v7 = v6;
  v16 = v6;
  v15 = 0;
  v14 = *((_DWORD *)a2 - 1);
  v8 = sub_4121D5((int)&v13, *(_DWORD *)(a1 + 24));
  v9 = *(_DWORD *)(_getptd() + 120);
  v10 = *(_DWORD *)(_getptd() + 124);
  *(_DWORD *)(_getptd() + 120) = a1;
  *(_DWORD *)(_getptd() + 124) = a3;
  ms_exc.registration.TryLevel = 1;
  v16 = _CallCatchBlock2(a2, a4, v7, a5, a6);
  ms_exc.registration.TryLevel = -1;
  *((_DWORD *)a2 - 1) = v14;
  sub_41221E(v8);
  *(_DWORD *)(_getptd() + 120) = v9;
  *(_DWORD *)(_getptd() + 124) = v10;
  if ( *(_DWORD *)a1 != -529697949 || *(_DWORD *)(a1 + 16) != 3 || *(_DWORD *)(a1 + 20) != 429065504 || v15 || !v16 || !IsExceptionObjectToBeDestroyed(*(void **)(a1 + 24)) )
  {
    return v16;
  }
  v12 = _abnormal_termination();
  __DestructExceptionObject(a1, v12);
  return v16;
}
// 414C2A: using guessed type _DWORD __cdecl __DestructExceptionObject(_DWORD, char);

//----- (00415016) --------------------------------------------------------
void __usercall sub_415016(unsigned __int8 a1@<cl>, const struct _s_TryBlockMapEntry *a2@<ebx>, int a3@<edi>, struct EHExceptionRecord *a4, struct EHRegistrationNode *a5, struct EHRegistrationNode *a6, struct _CONTEXT *a7, struct _s_FuncInfo *a8, int a9, struct _s_FuncInfo *a10, struct EHRegistrationNode *a11)
{
  int v11; // esi@4
  const struct _s_TryBlockMapEntry *v12; // edi@4
  int v13; // ecx@8
  const struct _s_TryBlockMapEntry *v14; // [sp-8h] [bp-14h]@5
  int v15; // [sp-4h] [bp-10h]@4
  struct EHRegistrationNode *v16; // [sp+0h] [bp-Ch]@0
  unsigned int v17; // [sp+4h] [bp-8h]@4
  unsigned int v18; // [sp+8h] [bp-4h]@4

  if ( *(_DWORD *)a4 != -2147483645 && (!*(_DWORD *)(_getptd() + 116) || !_CallSETranslator(a4, a5, (void *)a6, a7, a8, (int)a10, a11)) )
  {
    v11 = a9;
    v15 = a3;
    v12 = _GetRangeOfTrysToCheck(a8, (int)a10, a9, &v18, &v17);
    if ( v18 < v17 )
    {
      v14 = a2;
      do
      {
        if ( v11 >= *(_DWORD *)v12 && v11 <= *((_DWORD *)v12 + 1) )
        {
          v13 = *(_DWORD *)(*((_DWORD *)v12 + 4) + 16 * *((_DWORD *)v12 + 3) - 12);
          if ( !v13 || !*(_BYTE *)(v13 + 8) )
          {
            CatchIt(a4, a6, a7, (void *)a8, a10, a11, (const struct _s_CatchableType *)1, v14, v15, v16, v17);
            v11 = a9;
          }
        }
        ++v18;
        v12 = (const struct _s_TryBlockMapEntry *)((char *)v12 + 20);
      }
      while ( v18 < v17 );
    }
  }
}
// 415016: could not find valid save-restore pair for ebx
// 415016: could not find valid save-restore pair for edi

//----- (004150D6) --------------------------------------------------------
void __usercall sub_4150D6(struct EHRegistrationNode *a1@<ebx>, int a2@<edi>, const struct _s_ThrowInfo *a3@<esi>, struct EHExceptionRecord *a4, struct EHRegistrationNode *a5, struct EHRegistrationNode *a6, struct _CONTEXT *a7, struct _s_FuncInfo *a8, char a9, struct _s_FuncInfo *a10, struct EHRegistrationNode *a11)
{
  int v11; // eax@1
  unsigned __int8 v12; // cl@2
  struct EHExceptionRecord *v13; // ebx@4
  int v14; // eax@9
  const void *v15; // esi@9
  int v16; // eax@9
  unsigned __int8 v17; // ST1C_1@9
  int v18; // esi@20
  const struct _s_TryBlockMapEntry *v19; // eax@20
  int v20; // esi@25
  _DWORD *v21; // ecx@26
  int *v22; // edx@26
  int v23; // ecx@26
  int v24; // edi@32
  const struct _s_CatchableType *v25; // [sp-Ch] [bp-30h]@4
  const struct _s_ThrowInfo *v26; // [sp-8h] [bp-2Ch]@4
  struct EHRegistrationNode *v27; // [sp-4h] [bp-28h]@4
  int v28; // [sp+0h] [bp-24h]@27
  unsigned int v29; // [sp+4h] [bp-20h]@20
  struct _s_CatchableType *v30; // [sp+8h] [bp-1Ch]@1
  int v31; // [sp+Ch] [bp-18h]@1
  int v32; // [sp+10h] [bp-14h]@25
  int v33; // [sp+14h] [bp-10h]@26
  int *v34; // [sp+18h] [bp-Ch]@26
  unsigned int v35; // [sp+1Ch] [bp-8h]@20
  const struct _s_TryBlockMapEntry *v36; // [sp+20h] [bp-4h]@20

  v11 = *((_DWORD *)a5 + 2);
  LOBYTE(v30) = 0;
  v31 = v11;
  if ( v11 < -1 || (v12 = (unsigned __int8)a8, v11 >= *((_DWORD *)a8 + 1)) )
  {
    _inconsistency();
  }
  v27 = a1;
  v13 = a4;
  v26 = a3;
  v25 = (const struct _s_CatchableType *)a2;
  if ( *(_DWORD *)a4 != -529697949 )
  {
    goto LABEL_38;
  }
  a2 = 429065504;
  if ( *((_DWORD *)a4 + 4) == 3 && *((_DWORD *)a4 + 5) == 429065504 && !*((_DWORD *)a4 + 7) )
  {
    if ( !*(_DWORD *)(_getptd() + 120) )
    {
      return;
    }
    v14 = _getptd();
    v15 = *(const void **)(v14 + 120);
    a4 = *(struct EHExceptionRecord **)(v14 + 120);
    a6 = *(struct EHRegistrationNode **)(_getptd() + 124);
    LOBYTE(v30) = 1;
    v16 = _ValidateRead(v15, 1u);
    v12 = v17;
    if ( !v16 )
    {
      _inconsistency();
    }
    if ( *(_DWORD *)v15 != -529697949 )
    {
      v13 = a4;
LABEL_38:
      if ( a9 )
      {
        terminate();
      }
      sub_415016(v12, v13, a2, v13, a5, a6, a7, a8, v31, a10, a11);
      return;
    }
    if ( *((_DWORD *)a4 + 4) == 3 && *((_DWORD *)a4 + 5) == 429065504 && !*((_DWORD *)a4 + 7) )
    {
      _inconsistency();
    }
    v13 = a4;
  }
  if ( *(_DWORD *)v13 != -529697949 || *((_DWORD *)v13 + 4) != 3 || *((_DWORD *)v13 + 5) != 429065504 )
  {
    goto LABEL_38;
  }
  v18 = v31;
  v19 = _GetRangeOfTrysToCheck(a8, (int)a10, v31, &v35, &v29);
  v36 = v19;
  if ( v35 < v29 )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)v19 <= v18 && v18 <= *((_DWORD *)v19 + 1) )
      {
        v20 = *((_DWORD *)v19 + 4);
        v32 = *((_DWORD *)v19 + 3);
        if ( v32 > 0 )
        {
          while ( 1 )
          {
            v21 = *(_DWORD **)(*((_DWORD *)v13 + 7) + 12);
            v22 = v21 + 1;
            v23 = *v21;
            v34 = v22;
            v33 = v23;
            if ( v23 > 0 )
            {
              break;
            }
LABEL_30:
            --v32;
            v20 += 16;
            if ( v32 <= 0 )
            {
              goto LABEL_33;
            }
          }
          while ( 1 )
          {
            v28 = *v34;
            if ( TypeMatch(*((const struct _s_HandlerType **)v13 + 7), v25, v26) )
            {
              break;
            }
            --v33;
            ++v34;
            if ( v33 <= 0 )
            {
              v19 = v36;
              goto LABEL_30;
            }
          }
          v24 = (int)v36;
          CatchIt(v13, a6, a7, (void *)a8, a10, a11, v30, v25, (int)v26, v27, v28);
          v13 = a4;
          v19 = (const struct _s_TryBlockMapEntry *)v24;
        }
      }
LABEL_33:
      ++v35;
      v19 = (const struct _s_TryBlockMapEntry *)((char *)v19 + 20);
      v36 = v19;
      if ( v35 >= v29 )
      {
        break;
      }
      v18 = v31;
    }
  }
  if ( a9 )
  {
    __DestructExceptionObject(v13, 1);
  }
}
// 4150D6: could not find valid save-restore pair for ebx
// 4150D6: could not find valid save-restore pair for esi
// 414C2A: using guessed type _DWORD __cdecl __DestructExceptionObject(_DWORD, char);
// 41538F: using guessed type void __cdecl _inconsistency();

//----- (004155C9) --------------------------------------------------------
signed int winApi::initTls()
{
  signed int result; // eax@3
  DWORD *v1; // eax@4
  DWORD *v2; // esi@4
  DWORD v3; // eax@6

  if ( _mtinitlocks() && (dwTlsIndex = TlsAlloc(), dwTlsIndex != TLS_OUT_OF_INDEXES) )
  {
    v1 = (DWORD *)calloc_crt(1, 136);
    v2 = v1;
    if ( v1 && TlsSetValue(dwTlsIndex, v1) )
    {
      v2[21] = (DWORD)&unk_42DA78;
      v2[5] = 1;
      v3 = GetCurrentThreadId();
      v2[1] = -1;
      *v2 = v3;
      result = 1;
    }
    else
    {
      _mtterm();
      result = 0;
    }
  }
  else
  {
    _mtterm();
    result = 0;
  }
  return result;
}
// 4153BC: using guessed type int _mtterm(void);

//----- (0041582C) --------------------------------------------------------
int __cdecl sub_41582C(int a1, int a2, int a3)
{
  unsigned __int16 v3; // bx@1
  int v4; // ecx@1
  bool v5; // zf@1
  int v6; // eax@7
  unsigned __int16 v7; // ax@37
  signed int v8; // edx@61
  int v9; // eax@63
  char *j; // eax@66
  wchar_t *v11; // esi@73
  unsigned int v12; // eax@77
  __int64 v13; // rax@86
  int v14; // eax@89
  char *v15; // ecx@90
  signed int v16; // eax@91
  void *v17; // eax@101
  int v18; // ecx@104
  char *v19; // eax@115
  _WORD *v20; // eax@126
  unsigned int v21; // ebx@140
  unsigned int v22; // edi@140
  char *i; // esi@148
  int v24; // eax@149
  unsigned __int64 v25; // ST04_8@151
  unsigned __int64 v26; // rcx@151
  signed int v27; // ecx@151
  char *v28; // eax@154
  char *v29; // esi@154
  int v30; // ebx@168
  char *v31; // edi@175
  wchar_t v33; // [sp+4h] [bp-458h]@73
  char v34[513]; // [sp+203h] [bp-259h]@148
  int v35; // [sp+404h] [bp-58h]@104
  int v36; // [sp+408h] [bp-54h]@104
  int v37; // [sp+410h] [bp-4Ch]@151
  wchar_t v38[2]; // [sp+414h] [bp-48h]@77
  int v39; // [sp+418h] [bp-44h]@10
  int v40; // [sp+41Ch] [bp-40h]@3
  int v41; // [sp+420h] [bp-3Ch]@175
  int v42; // [sp+424h] [bp-38h]@10
  int v43; // [sp+428h] [bp-34h]@112
  void *v44; // [sp+42Ch] [bp-30h]@1
  char v45; // [sp+430h] [bp-2Ch]@78
  char v46; // [sp+431h] [bp-2Bh]@78
  __int16 v47; // [sp+434h] [bp-28h]@123
  __int16 v48; // [sp+436h] [bp-26h]@123
  int v49; // [sp+438h] [bp-24h]@10
  int v50; // [sp+43Ch] [bp-20h]@10
  int v51; // [sp+440h] [bp-1Ch]@10
  int v52; // [sp+444h] [bp-18h]@1
  int v53; // [sp+448h] [bp-14h]@1
  char *v54; // [sp+44Ch] [bp-10h]@63
  int v55; // [sp+450h] [bp-Ch]@10
  int v56; // [sp+454h] [bp-8h]@10
  unsigned int v57; // [sp+458h] [bp-4h]@1
  unsigned int retaddr; // [sp+460h] [bp+4h]@1

  v57 = retaddr ^ dword_42DDB4;
  v3 = *(_WORD *)a2;
  v4 = 0;
  v5 = *(_WORD *)a2 == 0;
  v53 = 0;
  v52 = 0;
  v44 = 0;
  if ( !v5 )
  {
    while ( 1 )
    {
      a2 += 2;
      if ( v52 < 0 )
      {
        return v52;
      }
      if ( v3 < 0x20u || v3 > 0x78u )
      {
        v6 = 0;
      }
      else
      {
        v6 = byte_4296A0[v3] & 0xF;
      }
      v40 = *(&byte_4296C0[8 * v6] + v4) >> 4;
      switch ( v40 )
      {
        case 1:
          v55 = -1;
          v39 = 0;
          v42 = 0;
          v49 = 0;
          v51 = 0;
          v56 = 0;
          v50 = 0;
          goto LABEL_184;
        case 2:
          switch ( v3 )
          {
            case 0x20u:
              v56 |= 2u;
              break;
            case 0x23u:
              LOBYTE(v56) = v56 | 0x80;
              break;
            case 0x2Bu:
              v56 |= 1u;
              break;
            case 0x2Du:
              v56 |= 4u;
              break;
            case 0x30u:
              v56 |= 8u;
              break;
          }
          goto LABEL_184;
        case 3:
          if ( v3 == 42 )
          {
            a3 += 4;
            v49 = *(_DWORD *)(a3 - 4);
            if ( v49 < 0 )
            {
              v56 |= 4u;
              v49 = -v49;
            }
          }
          else
          {
            v49 = v3 + 10 * v49 - 48;
          }
          goto LABEL_184;
        case 4:
          v55 = 0;
          goto LABEL_184;
        case 5:
          if ( v3 == 42 )
          {
            a3 += 4;
            v55 = *(_DWORD *)(a3 - 4);
            if ( v55 < 0 )
            {
              v55 = -1;
            }
          }
          else
          {
            v55 = v3 + 10 * v55 - 48;
          }
          goto LABEL_184;
        case 6:
          switch ( v3 )
          {
            case 0x49u:
              v7 = *(_WORD *)a2;
              if ( *(_WORD *)a2 != 54 || *(_WORD *)(a2 + 2) != 52 )
              {
                if ( v7 != 51 || *(_WORD *)(a2 + 2) != 50 )
                {
                  if ( v7 != 100 && v7 != 105 && v7 != 111 && v7 != 117 && v7 != 120 && v7 != 88 )
                  {
                    v40 = 0;
LABEL_50:
                    v50 = 1;
                    write_char(v3);
                  }
                }
                else
                {
                  a2 += 4;
                  BYTE1(v56) &= 0x7Fu;
                }
              }
              else
              {
                a2 += 4;
                BYTE1(v56) |= 0x80u;
              }
              break;
            case 0x68u:
              v56 |= 0x20u;
              break;
            case 0x6Cu:
              v56 |= 0x10u;
              break;
            case 0x77u:
              BYTE1(v56) |= 8u;
              break;
          }
          goto LABEL_184;
        case 0:
          goto LABEL_50;
        case 7:
          if ( (signed int)v3 > 103 )
          {
            if ( v3 == 105 )
            {
              goto LABEL_83;
            }
            if ( v3 == 110 )
            {
              a3 += 4;
              v20 = *(_WORD **)(a3 - 4);
              if ( v56 & 0x20 )
              {
                *v20 = v52;
              }
              else
              {
                *(_DWORD *)v20 = v52;
              }
              v42 = 1;
              goto LABEL_182;
            }
            if ( v3 == 111 )
            {
              v53 = 8;
              if ( v56 & 0x80 )
              {
                BYTE1(v56) |= 2u;
              }
            }
            else
            {
              if ( v3 == 112 )
              {
                v55 = 8;
LABEL_121:
                v43 = 7;
              }
              else
              {
                if ( v3 == 115 )
                {
                  goto LABEL_61;
                }
                if ( v3 == 117 )
                {
                  goto LABEL_84;
                }
                if ( v3 != 120 )
                {
                  goto LABEL_159;
                }
                v43 = 39;
              }
              v53 = 16;
              if ( v56 & 0x80 )
              {
                v47 = 48;
                v48 = v43 + 81;
                v51 = 2;
              }
            }
LABEL_85:
            if ( v56 & 0x8000 )
            {
              v13 = *(_QWORD *)a3;
              a3 += 8;
            }
            else
            {
              a3 += 4;
              if ( v56 & 0x20 )
              {
                if ( v56 & 0x40 )
                {
                  LODWORD(v13) = *(_WORD *)(a3 - 4);
                }
                else
                {
                  LODWORD(v13) = *(_WORD *)(a3 - 4);
                }
              }
              else
              {
                LODWORD(v13) = *(_DWORD *)(a3 - 4);
                if ( !(v56 & 0x40) )
                {
                  HIDWORD(v13) = 0;
                  goto LABEL_137;
                }
              }
              v13 = (signed int)v13;
            }
LABEL_137:
            if ( v56 & 0x40 && v13 < 0 )
            {
              v13 = -v13;
              BYTE1(v56) |= 1u;
            }
            v22 = HIDWORD(v13);
            v21 = v13;
            if ( !(v56 & 0x8000) )
            {
              v22 = 0;
            }
            if ( v55 >= 0 )
            {
              v56 &= 0xFFFFFFF7;
              if ( v55 > 512 )
              {
                v55 = 512;
              }
            }
            else
            {
              v55 = 1;
            }
            if ( !(v22 | (unsigned int)v13) )
            {
              v51 = 0;
            }
            for ( i = v34; ; --i )
            {
              v24 = v55--;
              if ( v24 <= 0 && !(v22 | v21) )
              {
                break;
              }
              v25 = __PAIR__(v22, v21);
              v26 = __PAIR__(v22, v21) % v53;
              v27 = v26 + 48;
              v37 = HIDWORD(v26);
              v22 = v25 / v53 >> 32;
              v21 = v25 / v53;
              if ( v27 > 57 )
              {
                LOBYTE(v27) = v43 + v27;
              }
              *i = v27;
            }
            v28 = (char *)(v34 - i);
            v29 = i + 1;
            v53 = (int)v28;
            v54 = v29;
            if ( BYTE1(v56) & 2 && (*v29 != 48 || !v28) )
            {
              *--v54 = 48;
              v16 = (signed int)(v28 + 1);
LABEL_158:
              v53 = v16;
              goto LABEL_159;
            }
            goto LABEL_159;
          }
          if ( (signed int)v3 >= 101 )
          {
            goto LABEL_73;
          }
          if ( (signed int)v3 > 88 )
          {
            if ( v3 == 90 )
            {
              a3 += 4;
              v14 = *(_DWORD *)(a3 - 4);
              if ( v14 && (v15 = *(char **)(v14 + 4)) != 0 )
              {
                v16 = *(_WORD *)v14;
                v54 = v15;
                if ( BYTE1(v56) & 8 )
                {
                  v16 /= 2;
                  v50 = 1;
                }
                else
                {
                  v50 = 0;
                }
              }
              else
              {
                v54 = off_42D9C0;
                v16 = strlen(off_42D9C0);
              }
              goto LABEL_158;
            }
            if ( v3 == 99 )
            {
              goto LABEL_77;
            }
            if ( v3 != 100 )
            {
              goto LABEL_159;
            }
LABEL_83:
            v56 |= 0x40u;
LABEL_84:
            v53 = 10;
            goto LABEL_85;
          }
          if ( v3 == 88 )
          {
            goto LABEL_121;
          }
          if ( v3 == 67 )
          {
            if ( !(v56 & 0x830) )
            {
              v56 |= 0x20u;
            }
LABEL_77:
            a3 += 4;
            v12 = *(_WORD *)(a3 - 4);
            v50 = 1;
            *(_DWORD *)v38 = v12;
            if ( v56 & 0x20 )
            {
              v46 = 0;
              v45 = v12;
              if ( mbtowc(&v33, &v45, cbMultiByte) < 0 )
              {
                v42 = 1;
              }
            }
            else
            {
              v33 = v12;
            }
            v54 = (char *)&v33;
            v53 = 1;
            goto LABEL_159;
          }
          if ( v3 == 69 || v3 == 71 )
          {
            v39 = 1;
            v3 += 32;
LABEL_73:
            v56 |= 0x40u;
            v11 = &v33;
            v54 = (char *)&v33;
            if ( v55 >= 0 )
            {
              if ( v55 )
              {
                if ( v55 > 512 )
                {
                  v55 = 512;
                }
                if ( v55 > 163 )
                {
                  v17 = malloc(v55 + 349);
                  v44 = v17;
                  if ( v17 )
                  {
                    v54 = (char *)v17;
                    v11 = (wchar_t *)v17;
                  }
                  else
                  {
                    v55 = 163;
                  }
                }
              }
              else if ( v3 == 103 )
              {
                v55 = 1;
              }
            }
            else
            {
              v55 = 6;
            }
            v18 = *(_DWORD *)a3;
            v36 = *(_DWORD *)(a3 + 4);
            v35 = v18;
            off_42E040(&v35, v11, (char)v3, v55, v39);
          }
          if ( v3 == 83 )
          {
            if ( !(v56 & 0x830) )
            {
              v56 |= 0x20u;
            }
LABEL_61:
            v8 = v55;
            if ( v55 == -1 )
            {
              v8 = 0x7FFFFFFF;
            }
            a3 += 4;
            v9 = *(_DWORD *)(a3 - 4);
            v54 = *(char **)(a3 - 4);
            if ( !(v56 & 0x20) )
            {
              if ( !v9 )
              {
                v54 = (char *)off_42D9C4;
              }
              v19 = v54;
              v50 = 1;
              while ( v8 )
              {
                --v8;
                if ( !*(_WORD *)v19 )
                {
                  break;
                }
                v19 += 2;
              }
              v16 = (v19 - v54) >> 1;
              goto LABEL_158;
            }
            if ( !v9 )
            {
              v54 = off_42D9C0;
            }
            v53 = 0;
            for ( j = v54; v53 < v8; ++v53 )
            {
              if ( !*j )
              {
                break;
              }
              if ( *((_BYTE *)off_42E058 + 2 * (unsigned __int8)*j + 1) & 0x80 )
              {
                ++j;
              }
              ++j;
            }
          }
LABEL_159:
          if ( v42 )
          {
            goto LABEL_182;
          }
          if ( !(v56 & 0x40) )
          {
            goto LABEL_168;
          }
          if ( BYTE1(v56) & 1 )
          {
            v47 = 45;
LABEL_167:
            v51 = 1;
            goto LABEL_168;
          }
          if ( v56 & 1 )
          {
            v47 = 43;
            goto LABEL_167;
          }
          if ( v56 & 2 )
          {
            v47 = 32;
            goto LABEL_167;
          }
LABEL_168:
          v30 = v49 - v51 - v53;
          if ( !(v56 & 0xC) )
          {
            write_multi_char(32, v49 - v51 - v53, a1);
          }
          write_string(v51);
          if ( v56 & 8 && !(v56 & 4) )
          {
            write_multi_char(48, v30, a1);
          }
          if ( v50 || v53 <= 0 )
          {
            write_string(v53);
          }
          else
          {
            v31 = v54;
            v41 = v53;
            do
            {
              --v41;
              v37 = mbtowc(v38, v31, cbMultiByte);
              if ( v37 <= 0 )
              {
                break;
              }
              write_char(v38[0]);
              v31 += v37;
            }
            while ( v41 > 0 );
          }
          if ( v56 & 4 )
          {
            write_multi_char(32, v30, a1);
          }
LABEL_182:
          if ( v44 )
          {
            free(v44);
            v44 = 0;
          }
LABEL_184:
          v3 = *(_WORD *)a2;
          if ( !*(_WORD *)a2 )
          {
            return v52;
          }
          v4 = v40;
          break;
        default:
          goto LABEL_184;
      }
    }
  }
  return v52;
}
// 4157A5: using guessed type int __cdecl write_char(_DWORD);
// 4157CA: using guessed type _DWORD __cdecl write_multi_char(_DWORD, _DWORD, _DWORD);
// 4157EF: using guessed type _DWORD __cdecl write_string(_DWORD);
// 42D9C4: using guessed type wchar_t *off_42D9C4;
// 42DDB4: using guessed type int dword_42DDB4;
// 42E040: using guessed type int (__cdecl *off_42E040)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 42E058: using guessed type void *off_42E058;
// 41582C: using guessed type char var_259[513];

//----- (004161EB) --------------------------------------------------------
int Static_Objects_initialization()
{
  int result; // eax@3
  int (**v1)(void); // esi@3
  void (**v2)(void); // esi@9

  if ( off_42D990 )
  {
    off_42D990();
  }
  result = 0;
  v1 = (int (**)(void))&byte_42D084;
  if ( &byte_42D084 >= (char *)&dword_42D095 + 3 )
  {
LABEL_9:
    atexit(sub_41B450);
    v2 = (void (**)(void))&static_initialization_begin;
    if ( &static_initialization_begin < &static_initialization_end )
    {
      do
      {
        if ( *v2 )
        {
          (*v2)();
        }
        ++v2;
      }
      while ( v2 < (void (**)(void))&static_initialization_end );
    }
    result = 0;
  }
  else
  {
    while ( !result )
    {
      if ( *v1 )
      {
        result = (*v1)();
      }
      ++v1;
      if ( v1 >= (int (**)(void))((char *)&dword_42D095 + 3) )
      {
        if ( result )
        {
          return result;
        }
        goto LABEL_9;
      }
    }
  }
  return result;
}
// 42D084: using guessed type char byte_42D084;
// 42D990: using guessed type int (*off_42D990)(void);

//----- (00416636) --------------------------------------------------------
int __cdecl sub_416636(FILE *a1, int a2, int a3)
{
  unsigned __int8 v3; // bl@1
  int v4; // ecx@1
  int v5; // edi@2
  int v6; // edi@4
  int v7; // eax@7
  char v8; // al@37
  char v9; // bl@51
  signed int v10; // ecx@63
  int v11; // eax@65
  char *v12; // eax@68
  char *v13; // esi@70
  __int64 v14; // rax@83
  int v15; // eax@86
  char *v16; // ecx@87
  signed int v17; // eax@88
  void *v18; // eax@98
  int v19; // ecx@101
  char *j; // eax@116
  _WORD *v21; // eax@127
  unsigned int v22; // ebx@141
  unsigned int v23; // edi@141
  char *i; // esi@149
  int v25; // eax@150
  unsigned __int64 v26; // ST04_8@152
  unsigned __int64 v27; // rcx@152
  signed int v28; // ecx@152
  char *v29; // eax@155
  char *v30; // esi@155
  char v31; // bl@161
  int v32; // esi@169
  wchar_t *v33; // ebx@176
  int v34; // eax@177
  char v36; // [sp+4h] [bp-254h]@70
  char v37; // [sp+203h] [bp-55h]@149
  char v38; // [sp+204h] [bp-54h]@177
  int v39; // [sp+20Ch] [bp-4Ch]@101
  int v40; // [sp+210h] [bp-48h]@101
  int v41; // [sp+218h] [bp-40h]@152
  int v42; // [sp+21Ch] [bp-3Ch]@10
  int v43; // [sp+220h] [bp-38h]@3
  int v44; // [sp+224h] [bp-34h]@10
  int v45; // [sp+228h] [bp-30h]@109
  void *v46; // [sp+22Ch] [bp-2Ch]@1
  int v47; // [sp+230h] [bp-28h]@10
  int v48; // [sp+234h] [bp-24h]@10
  int v49; // [sp+238h] [bp-20h]@10
  char v50; // [sp+23Ch] [bp-1Ch]@124
  char v51; // [sp+23Dh] [bp-1Bh]@124
  int v52; // [sp+240h] [bp-18h]@1
  int v53; // [sp+244h] [bp-14h]@1
  char *v54; // [sp+248h] [bp-10h]@65
  int v55; // [sp+24Ch] [bp-Ch]@10
  int v56; // [sp+250h] [bp-8h]@10
  unsigned int v57; // [sp+254h] [bp-4h]@1
  unsigned int retaddr; // [sp+25Ch] [bp+4h]@1
  char *v59; // [sp+264h] [bp+Ch]@4

  v57 = retaddr ^ dword_42DDB4;
  v53 = 0;
  v52 = 0;
  v46 = 0;
  v3 = *(_BYTE *)a2;
  v4 = 0;
  if ( !*(_BYTE *)a2 )
  {
    return v52;
  }
  v5 = a2;
  while ( 1 )
  {
    v6 = v5 + 1;
    v59 = (char *)v6;
    if ( v52 < 0 )
    {
      return v52;
    }
    if ( (char)v3 < 32 || (char)v3 > 120 )
    {
      v7 = 0;
    }
    else
    {
      v7 = byte_4296A0[(char)v3] & 0xF;
    }
    v43 = *(&byte_4296C0[8 * v7] + v4) >> 4;
    switch ( v43 )
    {
      case 1:
        v55 = -1;
        v42 = 0;
        v44 = 0;
        v48 = 0;
        v49 = 0;
        v56 = 0;
        v47 = 0;
        goto LABEL_185;
      case 2:
        switch ( v3 )
        {
          case 0x20u:
            v56 |= 2u;
            break;
          case 0x23u:
            LOBYTE(v56) = v56 | 0x80;
            break;
          case 0x2Bu:
            v56 |= 1u;
            break;
          case 0x2Du:
            v56 |= 4u;
            break;
          case 0x30u:
            v56 |= 8u;
            break;
        }
        goto LABEL_185;
      case 3:
        if ( v3 == 42 )
        {
          a3 += 4;
          v48 = *(_DWORD *)(a3 - 4);
          if ( v48 < 0 )
          {
            v56 |= 4u;
            v48 = -v48;
          }
        }
        else
        {
          v48 = (char)v3 + 10 * v48 - 48;
        }
        goto LABEL_185;
      case 4:
        v55 = 0;
        goto LABEL_185;
      case 5:
        if ( v3 == 42 )
        {
          a3 += 4;
          v55 = *(_DWORD *)(a3 - 4);
          if ( v55 < 0 )
          {
            v55 = -1;
          }
        }
        else
        {
          v55 = (char)v3 + 10 * v55 - 48;
        }
        goto LABEL_185;
      case 6:
        switch ( v3 )
        {
          case 0x49u:
            v8 = *(_BYTE *)v6;
            if ( *(_BYTE *)v6 != 54 || *(_BYTE *)(v6 + 1) != 52 )
            {
              if ( v8 != 51 || *(_BYTE *)(v6 + 1) != 50 )
              {
                if ( v8 != 100 && v8 != 105 && v8 != 111 && v8 != 117 && v8 != 120 && v8 != 88 )
                {
                  v43 = 0;
LABEL_50:
                  v47 = 0;
                  if ( *((_BYTE *)off_42E058 + 2 * v3 + 1) & 0x80 )
                  {
                    write_char_0(a1);
                    v9 = *(_BYTE *)v6;
                    v59 = (char *)(v6 + 1);
                  }
                  write_char_0(a1);
                }
              }
              else
              {
                BYTE1(v56) &= 0x7Fu;
                v59 = (char *)(v6 + 2);
              }
            }
            else
            {
              BYTE1(v56) |= 0x80u;
              v59 = (char *)(v6 + 2);
            }
            break;
          case 0x68u:
            v56 |= 0x20u;
            break;
          case 0x6Cu:
            v56 |= 0x10u;
            break;
          case 0x77u:
            BYTE1(v56) |= 8u;
            break;
        }
        goto LABEL_185;
      case 0:
        goto LABEL_50;
      case 7:
        if ( (char)v3 > 103 )
        {
          if ( v3 == 105 )
          {
            goto LABEL_80;
          }
          if ( v3 == 110 )
          {
            a3 += 4;
            v21 = *(_WORD **)(a3 - 4);
            if ( v56 & 0x20 )
            {
              *v21 = v52;
            }
            else
            {
              *(_DWORD *)v21 = v52;
            }
            v44 = 1;
            goto LABEL_183;
          }
          if ( v3 == 111 )
          {
            v53 = 8;
            if ( v56 & 0x80 )
            {
              BYTE1(v56) |= 2u;
            }
          }
          else
          {
            if ( v3 == 112 )
            {
              v55 = 8;
LABEL_122:
              v45 = 7;
            }
            else
            {
              if ( v3 == 115 )
              {
                goto LABEL_63;
              }
              if ( v3 == 117 )
              {
                goto LABEL_81;
              }
              if ( v3 != 120 )
              {
                goto LABEL_160;
              }
              v45 = 39;
            }
            v53 = 16;
            if ( v56 & 0x80 )
            {
              v50 = 48;
              v51 = v45 + 81;
              v49 = 2;
            }
          }
LABEL_82:
          if ( v56 & 0x8000 )
          {
            v14 = *(_QWORD *)a3;
            a3 += 8;
          }
          else
          {
            a3 += 4;
            if ( v56 & 0x20 )
            {
              if ( v56 & 0x40 )
              {
                LODWORD(v14) = *(_WORD *)(a3 - 4);
              }
              else
              {
                LODWORD(v14) = *(_WORD *)(a3 - 4);
              }
            }
            else
            {
              LODWORD(v14) = *(_DWORD *)(a3 - 4);
              if ( !(v56 & 0x40) )
              {
                HIDWORD(v14) = 0;
                goto LABEL_138;
              }
            }
            v14 = (signed int)v14;
          }
LABEL_138:
          if ( v56 & 0x40 && v14 < 0 )
          {
            v14 = -v14;
            BYTE1(v56) |= 1u;
          }
          v23 = HIDWORD(v14);
          v22 = v14;
          if ( !(v56 & 0x8000) )
          {
            v23 = 0;
          }
          if ( v55 >= 0 )
          {
            v56 &= 0xFFFFFFF7;
            if ( v55 > 512 )
            {
              v55 = 512;
            }
          }
          else
          {
            v55 = 1;
          }
          if ( !(v23 | (unsigned int)v14) )
          {
            v49 = 0;
          }
          for ( i = &v37; ; --i )
          {
            v25 = v55--;
            if ( v25 <= 0 && !(v23 | v22) )
            {
              break;
            }
            v26 = __PAIR__(v23, v22);
            v27 = __PAIR__(v23, v22) % v53;
            v28 = v27 + 48;
            v41 = HIDWORD(v27);
            v23 = v26 / v53 >> 32;
            v22 = v26 / v53;
            if ( v28 > 57 )
            {
              LOBYTE(v28) = v45 + v28;
            }
            *i = v28;
          }
          v29 = (char *)(&v37 - i);
          v30 = i + 1;
          v53 = (int)v29;
          v54 = v30;
          if ( BYTE1(v56) & 2 && (*v30 != 48 || !v29) )
          {
            *--v54 = 48;
            v17 = (signed int)(v29 + 1);
            goto LABEL_159;
          }
          goto LABEL_160;
        }
        if ( (char)v3 >= 101 )
        {
          goto LABEL_70;
        }
        if ( (char)v3 > 88 )
        {
          if ( v3 == 90 )
          {
            a3 += 4;
            v15 = *(_DWORD *)(a3 - 4);
            if ( v15 && (v16 = *(char **)(v15 + 4)) != 0 )
            {
              v17 = *(_WORD *)v15;
              v54 = v16;
              if ( BYTE1(v56) & 8 )
              {
                v17 /= 2;
                v47 = 1;
              }
              else
              {
                v47 = 0;
              }
            }
            else
            {
              v54 = off_42D9C0;
              v17 = strlen(off_42D9C0);
            }
            goto LABEL_159;
          }
          if ( v3 == 99 )
          {
            goto LABEL_74;
          }
          if ( v3 != 100 )
          {
            goto LABEL_160;
          }
LABEL_80:
          v56 |= 0x40u;
LABEL_81:
          v53 = 10;
          goto LABEL_82;
        }
        if ( v3 == 88 )
        {
          goto LABEL_122;
        }
        if ( v3 == 67 )
        {
          if ( !(v56 & 0x830) )
          {
            BYTE1(v56) |= 8u;
          }
LABEL_74:
          a3 += 4;
          if ( v56 & 0x810 )
          {
            v53 = wctomb(&v36, *(_WORD *)(a3 - 4));
            if ( v53 < 0 )
            {
              v44 = 1;
            }
          }
          else
          {
            v36 = *(_BYTE *)(a3 - 4);
            v53 = 1;
          }
          v54 = &v36;
          goto LABEL_160;
        }
        if ( v3 == 69 || v3 == 71 )
        {
          v42 = 1;
          v3 += 32;
LABEL_70:
          v56 |= 0x40u;
          v13 = &v36;
          v54 = &v36;
          if ( v55 >= 0 )
          {
            if ( v55 )
            {
              if ( v55 > 512 )
              {
                v55 = 512;
              }
              if ( v55 > 163 )
              {
                v18 = malloc(v55 + 349);
                v46 = v18;
                if ( v18 )
                {
                  v54 = (char *)v18;
                  v13 = (char *)v18;
                }
                else
                {
                  v55 = 163;
                }
              }
            }
            else if ( v3 == 103 )
            {
              v55 = 1;
            }
          }
          else
          {
            v55 = 6;
          }
          v19 = *(_DWORD *)a3;
          v40 = *(_DWORD *)(a3 + 4);
          v39 = v19;
          off_42E040(&v39, v13, (char)v3, v55, v42);
        }
        if ( v3 == 83 )
        {
          if ( !(v56 & 0x830) )
          {
            BYTE1(v56) |= 8u;
          }
LABEL_63:
          v10 = v55;
          if ( v55 == -1 )
          {
            v10 = 0x7FFFFFFF;
          }
          a3 += 4;
          v11 = *(_DWORD *)(a3 - 4);
          v54 = *(char **)(a3 - 4);
          if ( v56 & 0x810 )
          {
            if ( !v11 )
            {
              v54 = (char *)off_42D9C4;
            }
            v12 = v54;
            v47 = 1;
            while ( v10 )
            {
              --v10;
              if ( !*(_WORD *)v12 )
              {
                break;
              }
              v12 += 2;
            }
            v17 = (v12 - v54) >> 1;
          }
          else
          {
            if ( !v11 )
            {
              v54 = off_42D9C0;
            }
            for ( j = v54; v10; ++j )
            {
              --v10;
              if ( !*j )
              {
                break;
              }
            }
            v17 = j - v54;
          }
LABEL_159:
          v53 = v17;
        }
LABEL_160:
        if ( v44 )
        {
          goto LABEL_183;
        }
        v31 = v56;
        if ( !(v56 & 0x40) )
        {
          goto LABEL_169;
        }
        if ( BYTE1(v56) & 1 )
        {
          v50 = 45;
LABEL_168:
          v49 = 1;
          goto LABEL_169;
        }
        if ( v56 & 1 )
        {
          v50 = 43;
          goto LABEL_168;
        }
        if ( v56 & 2 )
        {
          v50 = 32;
          goto LABEL_168;
        }
LABEL_169:
        v32 = v48 - v49 - v53;
        if ( !(v56 & 0xC) )
        {
          write_multi_char_0(32, v48 - v49 - v53, a1);
        }
        write_string_0(v49);
        if ( v31 & 8 && !(v31 & 4) )
        {
          write_multi_char_0(48, v32, a1);
        }
        if ( v47 && v53 > 0 )
        {
          v33 = (wchar_t *)v54;
          v41 = v53;
          do
          {
            --v41;
            v34 = wctomb(&v38, *v33);
            ++v33;
            if ( v34 <= 0 )
            {
              break;
            }
            write_string_0(v34);
          }
          while ( v41 );
        }
        else
        {
          write_string_0(v53);
        }
        if ( v56 & 4 )
        {
          write_multi_char_0(32, v32, a1);
        }
LABEL_183:
        if ( v46 )
        {
          free(v46);
          v46 = 0;
        }
LABEL_185:
        v5 = (int)v59;
        v3 = *v59;
        if ( !*v59 )
        {
          return v52;
        }
        v4 = v43;
        break;
      default:
        goto LABEL_185;
    }
  }
  return v52;
}
// 4165FF: using guessed type int __cdecl write_string_0(_DWORD);
// 42D9C4: using guessed type wchar_t *off_42D9C4;
// 42DDB4: using guessed type int dword_42DDB4;
// 42E040: using guessed type int (__cdecl *off_42E040)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 42E058: using guessed type void *off_42E058;

//----- (004177DB) --------------------------------------------------------
signed int __cdecl sub_4177DB(int a1)
{
  void *v2; // edi@3

  if ( *(&lpCriticalSection + 2 * a1) )
  {
    return 1;
  }
  v2 = malloc(0x18u);
  if ( !v2 )
  {
    goto LABEL_4;
  }
  _lock(10);
  if ( *(&lpCriticalSection + 2 * a1) )
  {
    free(v2);
  }
  else
  {
    if ( !__crtInitCritSecAndSpinCount(v2, 4000) )
    {
      free(v2);
      _unlock(10);
LABEL_4:
      *_errno() = 12;
      return 0;
    }
    *(&lpCriticalSection + 2 * a1) = (LPCRITICAL_SECTION)v2;
  }
  _unlock(10);
  return 1;
}
// 4177C6: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 41785A: using guessed type _DWORD __cdecl _lock(_DWORD);
// 41C1F5: using guessed type _DWORD __cdecl __crtInitCritSecAndSpinCount(_DWORD, _DWORD);

//----- (00418469) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_418469()
{
  return SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)lpTopLevelExceptionFilter);
}

//----- (00418A61) --------------------------------------------------------
signed int __cdecl sub_418A61(signed int a1)
{
  int v1; // edi@1
  int v2; // esi@1

  v1 = 36 * (a1 & 0x1F);
  v2 = v1 + dword_1BD6BE0[a1 >> 5];
  if ( !*(_DWORD *)(v2 + 8) )
  {
    _lock(10);
    if ( !*(_DWORD *)(v2 + 8) )
    {
      if ( !__crtInitCritSecAndSpinCount(v2 + 12, 4000) )
      {
        _unlock(10);
        return 0;
      }
      ++*(_DWORD *)(v2 + 8);
    }
    _unlock(10);
  }
  EnterCriticalSection((LPCRITICAL_SECTION)(dword_1BD6BE0[a1 >> 5] + v1 + 12));
  return 1;
}
// 4177C6: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 41785A: using guessed type _DWORD __cdecl _lock(_DWORD);
// 41C1F5: using guessed type _DWORD __cdecl __crtInitCritSecAndSpinCount(_DWORD, _DWORD);
// 1BD6BE0: using guessed type int dword_1BD6BE0[];

//----- (00418AF6) --------------------------------------------------------
int sub_418AF6()
{
  int v0; // ebp@1
  int v1; // ebx@2
  int *v2; // edi@2
  unsigned int v3; // esi@3
  unsigned int i; // eax@4
  void *v5; // eax@21
  unsigned int j; // edx@22
  int v8; // [sp+4h] [bp-8h]@2
  int v9; // [sp+8h] [bp-4h]@2

  v0 = -1;
  if ( !sub_4177DB(11) )
  {
    return v0;
  }
  _lock(11);
  v1 = 0;
  v8 = 0;
  v9 = 0;
  v2 = dword_1BD6BE0;
  while ( 2 )
  {
    v3 = *v2;
    if ( *v2 )
    {
      for ( i = v3 + 1152; v3 < i; i = *v2 + 1152 )
      {
        if ( !(*(_BYTE *)(v3 + 4) & 1) )
        {
          if ( !*(_DWORD *)(v3 + 8) )
          {
            _lock(10);
            if ( !*(_DWORD *)(v3 + 8) )
            {
              if ( !__crtInitCritSecAndSpinCount(v3 + 12, 4000) )
              {
                _unlock(10);
                goto LABEL_26;
              }
              ++*(_DWORD *)(v3 + 8);
            }
            _unlock(10);
          }
          EnterCriticalSection((LPCRITICAL_SECTION)(v3 + 12));
          if ( !(*(_BYTE *)(v3 + 4) & 1) )
          {
            *(_DWORD *)v3 = -1;
            v0 = v9 + (signed int)(v3 - *v2) / 36;
            if ( v0 != -1 )
            {
              goto LABEL_27;
            }
            v1 = v8;
            break;
          }
          LeaveCriticalSection((LPCRITICAL_SECTION)(v3 + 12));
          v1 = v8;
        }
        v3 += 36;
      }
      v9 += 32;
      ++v1;
      ++v2;
      v8 = v1;
      if ( (signed int)v2 < (signed int)&dword_1BD6CE0 )
      {
        continue;
      }
    }
    else
    {
      v5 = malloc(0x480u);
      if ( v5 )
      {
        uNumber += 32;
        dword_1BD6BE0[v1] = (int)v5;
        for ( j = (unsigned int)v5 + 1152; (unsigned int)v5 < j; j = dword_1BD6BE0[v1] + 1152 )
        {
          *((_BYTE *)v5 + 4) = 0;
          *(_DWORD *)v5 = -1;
          *((_DWORD *)v5 + 2) = 0;
          *((_BYTE *)v5 + 5) = 10;
          v5 = (char *)v5 + 36;
        }
        v0 = 32 * v1;
        if ( !sub_418A61(32 * v1) )
        {
LABEL_26:
          v0 = -1;
        }
      }
    }
    break;
  }
LABEL_27:
  _unlock(11);
  return v0;
}
// 4177C6: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 41785A: using guessed type _DWORD __cdecl _lock(_DWORD);
// 41C1F5: using guessed type _DWORD __cdecl __crtInitCritSecAndSpinCount(_DWORD, _DWORD);
// 1BD6BE0: using guessed type int dword_1BD6BE0[];

//----- (00418D82) --------------------------------------------------------
void __thiscall sub_418D82(void *this)
{
  if ( this != (void *)dword_42DDB4 )
  {
    report_failure();
  }
}
// 418D51: using guessed type int report_failure(void);
// 42DDB4: using guessed type int dword_42DDB4;

//----- (00418D90) --------------------------------------------------------
int __cdecl sub_418D90(int a1, LONG lDistanceToMove)
{
  int v2; // esi@1
  int v3; // eax@2
  LONG v4; // edi@3
  DWORD v5; // eax@5
  int v6; // eax@7
  void *v7; // eax@15
  unsigned __int32 *v8; // edi@16
  int result; // eax@17
  char Buffer; // [sp+8h] [bp-100Ch]@4
  int v11; // [sp+1008h] [bp-Ch]@4
  LONG v12; // [sp+100Ch] [bp-8h]@1
  unsigned int v13; // [sp+1010h] [bp-4h]@1
  unsigned int retaddr; // [sp+1018h] [bp+4h]@1

  v2 = 0;
  v13 = retaddr ^ dword_42DDB4;
  v12 = _lseek_lk(a1, 0, 1u);
  if ( v12 == -1 || (v3 = _lseek_lk(a1, 0, 2u), v3 == -1) )
  {
    result = -1;
  }
  else
  {
    v4 = lDistanceToMove - v3;
    if ( lDistanceToMove - v3 <= 0 )
    {
      if ( lDistanceToMove - v3 < 0 )
      {
        _lseek_lk(a1, lDistanceToMove, 0);
        v7 = (void *)_get_osfhandle(a1);
        v2 = (SetEndOfFile(v7) != 0) - 1;
        if ( v2 == -1 )
        {
          *_errno() = 13;
          v8 = __doserrno();
          *v8 = GetLastError();
        }
      }
    }
    else
    {
      memset(&Buffer, 0, 0x1000u);
      v11 = _setmode_lk(a1, 0x8000);
      while ( 1 )
      {
        v5 = 4096;
        if ( v4 < 4096 )
        {
          v5 = v4;
        }
        v6 = sub_41BC20(a1, &Buffer, v5);
        if ( v6 == -1 )
        {
          break;
        }
        v4 -= v6;
        if ( v4 <= 0 )
        {
          goto LABEL_13;
        }
      }
      if ( *__doserrno() == 5 )
      {
        *_errno() = 13;
      }
      v2 = -1;
LABEL_13:
      _setmode_lk(a1, v11);
    }
    _lseek_lk(a1, v12, 0);
    result = v2;
  }
  return result;
}
// 41C679: using guessed type _DWORD __cdecl _setmode_lk(_DWORD, _DWORD);
// 42DDB4: using guessed type int dword_42DDB4;

//----- (00419AD8) --------------------------------------------------------
int __cdecl sub_419AD8(int a1, int a2, int a3)
{
  int v3; // ebx@1
  __int16 v4; // ax@4
  int v5; // edi@7
  signed int v6; // esi@9
  __int16 v7; // cx@19
  char *v8; // edi@41
  int v9; // esi@48
  int v10; // eax@51
  int v11; // eax@64
  WCHAR *v12; // esi@69
  int v13; // eax@78
  int v14; // eax@82
  int v15; // eax@85
  int v16; // eax@91
  int v17; // eax@92
  int v18; // eax@95
  int v19; // eax@98
  int v20; // esi@104
  CHAR *v21; // edi@104
  char *v22; // esi@111
  int v23; // eax@113
  int v24; // eax@114
  _WORD *v25; // edi@135
  void *v26; // esp@138
  _BYTE *v27; // esi@139
  char *v28; // eax@142
  int v29; // ecx@145
  unsigned int v30; // esi@150
  int v31; // edx@150
  char v32; // cl@154
  int v33; // eax@164
  int v34; // eax@176
  int result; // eax@257
  int v36; // [sp-2000h] [bp-2338h]@138
  int v37; // [sp-18h] [bp-350h]@106
  __int64 v38; // [sp-10h] [bp-348h]@203
  signed __int64 v39; // [sp-8h] [bp-340h]@203
  int v40; // [sp-4h] [bp-33Ch]@4
  _WORD *v41; // [sp+Ch] [bp-32Ch]@135
  wchar_t v42; // [sp+10h] [bp-328h]@81
  WCHAR WideCharStr; // [sp+14h] [bp-324h]@69
  char v44; // [sp+16h] [bp-322h]@70
  int v45; // [sp+2D0h] [bp-68h]@48
  char *v46; // [sp+2D4h] [bp-64h]@41
  int v47; // [sp+2D8h] [bp-60h]@41
  __int64 v48; // [sp+2DCh] [bp-5Ch]@21
  int v49; // [sp+2E4h] [bp-54h]@8
  char v50; // [sp+2E9h] [bp-4Fh]@8
  char v51[10]; // [sp+2EAh] [bp-4Eh]@8
  signed int v52; // [sp+2F4h] [bp-44h]@8
  int v53; // [sp+2F8h] [bp-40h]@8
  char *v54; // [sp+2FCh] [bp-3Ch]@8
  int v55; // [sp+300h] [bp-38h]@8
  int v56; // [sp+304h] [bp-34h]@1
  int v57; // [sp+308h] [bp-30h]@1
  char v58[9]; // [sp+30Fh] [bp-29h]@1
  void *v59; // [sp+318h] [bp-20h]@1
  unsigned int v60; // [sp+31Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+320h] [bp-18h]@138
  unsigned int retaddr; // [sp+33Ch] [bp+4h]@1
  _WORD *v63; // [sp+344h] [bp+Ch]@40

  v60 = retaddr ^ dword_42DDB4;
  v3 = 0;
  v59 = 0;
  *(_DWORD *)&v58[5] = 0;
  *(_DWORD *)&v58[1] = 0;
  *(_DWORD *)v58 = 0;
  v57 = 0;
  v56 = 0;
  do
  {
    while ( 1 )
    {
      if ( !*(_WORD *)a2 )
      {
        goto LABEL_255;
      }
      if ( !iswctype(*(_WORD *)a2, 8u) )
      {
        break;
      }
      --v57;
      v40 = a1;
      v4 = _whiteout(a1);
      _un_inc(v4);
      do
      {
        a2 += 2;
      }
      while ( iswspace(*(_WORD *)a2) );
    }
    v5 = a2;
    if ( *(_WORD *)a2 != 37 )
    {
      ++v57;
      v3 = _getwc_lk(a1);
      *(_DWORD *)&v58[1] = v3;
      a2 += 2;
      if ( *(_WORD *)v5 == (_WORD)v3 )
      {
        continue;
      }
      goto LABEL_263;
    }
    v55 = 0;
    v54 = 0;
    v53 = 0;
    v52 = 0;
    *(_DWORD *)&v51[6] = 0;
    *(_DWORD *)&v51[5] = 0;
    *(_DWORD *)&v51[4] = 0;
    *(_DWORD *)&v51[3] = 0;
    *(_DWORD *)&v51[2] = 0;
    *(_DWORD *)&v51[1] = 0;
    *(_DWORD *)v51 = 0;
    v50 = 1;
    v49 = 0;
    do
    {
      v5 += 2;
      v6 = *(_WORD *)v5;
      if ( !(v6 & 0xFF00) && isdigit((unsigned __int8)v6) )
      {
        ++v52;
        *(_DWORD *)&v51[6] = v6 + 10 * *(_DWORD *)&v51[6] - 48;
        continue;
      }
      if ( v6 > 78 )
      {
        if ( v6 == 104 )
        {
          --v50;
          --v51[0];
        }
        else
        {
          if ( v6 == 108 )
          {
            ++v50;
          }
          else if ( v6 != 119 )
          {
            goto LABEL_35;
          }
          ++v51[0];
        }
      }
      else
      {
        if ( v6 == 78 )
        {
          continue;
        }
        if ( v6 == 42 )
        {
          ++v51[3];
          continue;
        }
        if ( v6 == 70 )
        {
          continue;
        }
        if ( v6 != 73 )
        {
          if ( v6 == 76 )
          {
            ++v50;
            continue;
          }
LABEL_35:
          ++v51[2];
          continue;
        }
        v7 = *(_WORD *)(v5 + 2);
        if ( v7 == 54 && *(_WORD *)(v5 + 4) == 52 )
        {
          v5 += 4;
          ++v49;
          v48 = 0i64;
          continue;
        }
        if ( v7 == 51 && *(_WORD *)(v5 + 4) == 50 )
        {
          v5 += 4;
          continue;
        }
        if ( v7 != 100 && v7 != 105 && v7 != 111 && v7 != 120 && v7 != 88 )
        {
          goto LABEL_35;
        }
      }
    }
    while ( !v51[2] );
    v63 = (_WORD *)v5;
    if ( v51[3] )
    {
      v8 = v46;
    }
    else
    {
      v47 = a3;
      a3 += 4;
      v8 = *(char **)(a3 - 4);
      v46 = *(char **)(a3 - 4);
    }
    v51[2] = 0;
    if ( !v51[0] )
    {
      if ( *v63 == 83 || *v63 == 67 )
      {
        v51[0] = -1;
      }
      else
      {
        v51[0] = 1;
      }
    }
    v9 = *v63 | 0x20;
    v45 = v9;
    if ( v9 != 110 )
    {
      if ( v9 == 99 || v9 == 123 )
      {
        ++v57;
        v10 = _getwc_lk(a1);
      }
      else
      {
        v10 = _whiteout(a1);
        v9 = v45;
      }
      v3 = v10;
      *(_DWORD *)&v58[1] = v10;
    }
    if ( v52 && !*(_DWORD *)&v51[6] )
    {
      goto LABEL_263;
    }
    if ( v9 > 111 )
    {
      if ( v9 == 112 )
      {
        v50 = 1;
      }
      else
      {
        if ( v9 == 115 )
        {
LABEL_109:
          if ( v51[0] > 0 )
          {
            v51[1] = 1;
          }
LABEL_111:
          v22 = v46;
          --v57;
          v40 = a1;
          _un_inc(v3);
          while ( 1 )
          {
            if ( v52 )
            {
              v23 = (*(_DWORD *)&v51[6])--;
              if ( !v23 )
              {
                break;
              }
            }
            ++v57;
            v24 = _getwc_lk(a1);
            v3 = v24;
            *(_DWORD *)&v58[1] = v24;
            if ( (_WORD)v24 == -1 || v45 != 99 && (v45 != 115 || (unsigned __int16)v24 >= 9u && (unsigned __int16)v24 <= 0xDu || (_WORD)v24 == 32) && (v45 != 123 || !((1 << (v24 & 7)) & (v51[5] ^ *((_BYTE *)v59 + ((unsigned int)(unsigned __int16)v24 >> 3))))) )
            {
              --v57;
              v40 = a1;
              _un_inc(v24);
              break;
            }
            if ( v51[3] )
            {
              v22 += 2;
            }
            else if ( v51[1] )
            {
              *(_WORD *)v46 = v24;
              v46 += 2;
            }
            else
            {
              v34 = wctomb(v46, v24);
              v46 += v34;
            }
          }
          if ( v22 != v46 )
          {
            if ( !v51[3] )
            {
              ++v56;
              if ( v45 != 99 )
              {
                if ( v51[1] )
                {
                  *(_WORD *)v46 = 0;
                }
                else
                {
                  *v46 = 0;
                }
              }
            }
            goto LABEL_251;
          }
          break;
        }
        if ( v9 != 117 )
        {
          if ( v9 != 120 )
          {
            if ( v9 == 123 )
            {
              if ( v51[0] > 0 )
              {
                v51[1] = 1;
              }
              v25 = v63 + 1;
              v63 = v25;
              v41 = v25;
              if ( *v25 == 94 )
              {
                ++v25;
                v41 = v25;
                v51[5] = -1;
              }
              if ( !v59 )
              {
                v26 = alloca(0x2000);
                ms_exc.old_esp = (DWORD)&v36;
                v59 = &v36;
                ms_exc.registration.TryLevel = -1;
              }
              v27 = v59;
              memset(v59, 0, 0x2000u);
              if ( v45 == 123 && *v25 == 93 )
              {
                v54 = (char *)93;
                ++v25;
                v27[11] = 32;
              }
              HIWORD(v28) = 0;
              while ( 1 )
              {
                LOWORD(v28) = *v25;
                if ( *v25 == 93 )
                {
                  break;
                }
                ++v25;
                if ( (_WORD)v28 == 45 && (_WORD)v54 && (v29 = *v25, *v25 != 93) )
                {
                  ++v25;
                  if ( (unsigned __int16)v54 >= (unsigned __int16)v29 )
                  {
                    v28 = v54;
                    v54 = (char *)v29;
                  }
                  else
                  {
                    v28 = (char *)v29;
                  }
                  if ( (unsigned __int16)v54 <= (unsigned __int16)v28 )
                  {
                    v30 = (unsigned __int16)v54;
                    v31 = (unsigned __int16)((_WORD)v28 - (_WORD)v54 + 1);
                    do
                    {
                      v28 = (char *)v59 + (v30 >> 3);
                      *v28 |= 1 << (v30++ & 7);
                      --v31;
                    }
                    while ( v31 );
                    v3 = *(_DWORD *)&v58[1];
                  }
                  v54 = 0;
                }
                else
                {
                  v54 = v28;
                  v32 = (char)v28;
                  v28 = (char *)v59 + ((unsigned int)(unsigned __int16)v28 >> 3);
                  *v28 |= 1 << (v32 & 7);
                }
              }
              if ( v45 == 123 )
              {
                v63 = v25;
              }
              goto LABEL_111;
            }
LABEL_130:
            if ( *v63 == (_WORD)v3 )
            {
              --v58[0];
              if ( !v51[3] )
              {
                a3 = v47;
              }
              goto LABEL_251;
            }
LABEL_263:
            v40 = a1;
            _un_inc(v3);
            break;
          }
LABEL_67:
          if ( (_WORD)v3 == 45 )
          {
            v51[4] = 1;
          }
          else if ( (_WORD)v3 != 43 )
          {
            goto LABEL_163;
          }
          if ( --*(_DWORD *)&v51[6] || !v52 )
          {
            ++v57;
            v3 = _getwc_lk(a1);
            *(_DWORD *)&v58[1] = v3;
          }
          else
          {
            v51[2] = 1;
          }
LABEL_163:
          if ( (_WORD)v3 == 48 )
          {
            ++v57;
            v33 = _getwc_lk(a1);
            v3 = v33;
            *(_DWORD *)&v58[1] = v33;
            if ( (_WORD)v33 == 120 || (_WORD)v33 == 88 )
            {
              ++v57;
              v3 = _getwc_lk(a1);
              *(_DWORD *)&v58[1] = v3;
              if ( v52 )
              {
                *(_DWORD *)&v51[6] -= 2;
                if ( *(_DWORD *)&v51[6] < 1 )
                {
                  ++v51[2];
                }
              }
              v45 = 120;
              goto LABEL_194;
            }
            v53 = 1;
            if ( v9 != 120 )
            {
              if ( v52 )
              {
                if ( !--*(_DWORD *)&v51[6] )
                {
                  ++v51[2];
                }
              }
              v45 = 111;
              goto LABEL_194;
            }
            --v57;
            v40 = a1;
            _un_inc(v33);
            v3 = 48;
            goto LABEL_193;
          }
          goto LABEL_194;
        }
      }
LABEL_186:
      if ( (_WORD)v3 == 45 )
      {
        v51[4] = 1;
      }
      else if ( (_WORD)v3 != 43 )
      {
        goto LABEL_194;
      }
      if ( --*(_DWORD *)&v51[6] || !v52 )
      {
        ++v57;
        v3 = _getwc_lk(a1);
LABEL_193:
        *(_DWORD *)&v58[1] = v3;
        goto LABEL_194;
      }
      v51[2] = 1;
LABEL_194:
      if ( v49 )
      {
        if ( !v51[2] )
        {
          while ( 1 )
          {
            if ( v45 == 120 || v45 == 112 )
            {
              if ( BYTE1(v3) || !isxdigit((unsigned __int8)v3) )
              {
LABEL_207:
                ++v51[2];
                goto LABEL_208;
              }
              v48 *= 16i64;
              v3 = _hextodec();
            }
            else
            {
              if ( BYTE1(v3) || !isdigit((unsigned __int8)v3) )
              {
                goto LABEL_207;
              }
              if ( v45 == 111 )
              {
                if ( (unsigned __int16)v3 >= 0x38u )
                {
                  goto LABEL_207;
                }
                v48 *= 8i64;
              }
              else
              {
                v39 = 10i64;
                v38 = v48;
                v48 *= 10i64;
              }
            }
LABEL_208:
            if ( v51[2] )
            {
              --v57;
              v40 = a1;
              _un_inc(v3);
            }
            else
            {
              ++v53;
              v48 += (unsigned __int16)v3 - 48;
              if ( !v52 || (--*(_DWORD *)&v51[6], *(_DWORD *)&v51[6]) )
              {
                ++v57;
                v3 = _getwc_lk(a1);
              }
              else
              {
                v51[2] = 1;
              }
            }
            if ( v51[2] )
            {
              *(_DWORD *)&v58[1] = v3;
              break;
            }
          }
        }
        if ( v51[4] )
        {
          v48 = -v48;
        }
LABEL_241:
        if ( v45 == 70 )
        {
          v53 = 0;
        }
        if ( v53 )
        {
          if ( v51[3] )
          {
            goto LABEL_251;
          }
          ++v56;
          v8 = v46;
          v11 = v55;
          goto LABEL_246;
        }
        break;
      }
      if ( v51[2] )
      {
LABEL_239:
        if ( v51[4] )
        {
          v55 = -v55;
        }
        goto LABEL_241;
      }
      while ( 1 )
      {
        if ( v45 == 120 || v45 == 112 )
        {
          if ( BYTE1(v3) || !isxdigit((unsigned __int8)v3) )
          {
LABEL_230:
            ++v51[2];
            goto LABEL_231;
          }
          v55 *= 16;
          v3 = _hextodec();
        }
        else
        {
          if ( BYTE1(v3) || !isdigit((unsigned __int8)v3) )
          {
            goto LABEL_230;
          }
          if ( v45 == 111 )
          {
            if ( (unsigned __int16)v3 >= 0x38u )
            {
              goto LABEL_230;
            }
            v55 *= 8;
          }
          else
          {
            v55 *= 10;
          }
        }
LABEL_231:
        if ( v51[2] )
        {
          --v57;
          v40 = a1;
          _un_inc(v3);
        }
        else
        {
          ++v53;
          v55 = v55 + (unsigned __int16)v3 - 48;
          if ( !v52 || (--*(_DWORD *)&v51[6], *(_DWORD *)&v51[6]) )
          {
            ++v57;
            v3 = _getwc_lk(a1);
          }
          else
          {
            v51[2] = 1;
          }
        }
        if ( v51[2] )
        {
          *(_DWORD *)&v58[1] = v3;
          goto LABEL_239;
        }
      }
    }
    if ( v9 == 111 )
    {
      goto LABEL_186;
    }
    if ( v9 == 99 )
    {
      if ( !v52 )
      {
        v52 = 1;
        ++*(_DWORD *)&v51[6];
      }
      goto LABEL_109;
    }
    if ( v9 == 100 )
    {
      goto LABEL_186;
    }
    if ( v9 <= 100 )
    {
      goto LABEL_130;
    }
    if ( v9 <= 103 )
    {
      v12 = &WideCharStr;
      if ( (_WORD)v3 == 45 )
      {
        WideCharStr = 45;
        v12 = (WCHAR *)&v44;
        goto LABEL_72;
      }
      if ( (_WORD)v3 == 43 )
      {
LABEL_72:
        --*(_DWORD *)&v51[6];
        ++v57;
        v3 = _getwc_lk(a1);
        *(_DWORD *)&v58[1] = v3;
      }
      if ( !v52 || *(_DWORD *)&v51[6] > 349 )
      {
        *(_DWORD *)&v51[6] = 349;
      }
      while ( !(v3 & 0xFF00) )
      {
        if ( !isdigit((unsigned __int8)v3) )
        {
          break;
        }
        v13 = (*(_DWORD *)&v51[6])--;
        if ( !v13 )
        {
          break;
        }
        ++v53;
        *v12 = v3;
        ++v12;
        ++v57;
        v3 = _getwc_lk(a1);
        *(_DWORD *)&v58[1] = v3;
      }
      mbtowc(&v42, &byte_42E384, cbMultiByte);
      if ( v42 == (_WORD)v3 )
      {
        v14 = (*(_DWORD *)&v51[6])--;
        if ( v14 )
        {
          ++v57;
          v3 = _getwc_lk(a1);
          *v12 = v42;
          ++v12;
          while ( 1 )
          {
            *(_DWORD *)&v58[1] = v3;
            if ( v3 & 0xFF00 )
            {
              break;
            }
            if ( !isdigit((unsigned __int8)v3) )
            {
              break;
            }
            v15 = (*(_DWORD *)&v51[6])--;
            if ( !v15 )
            {
              break;
            }
            ++v53;
            *v12 = v3;
            ++v12;
            ++v57;
            v3 = _getwc_lk(a1);
          }
        }
      }
      if ( v53 && ((_WORD)v3 == 101 || (_WORD)v3 == 69) )
      {
        v16 = (*(_DWORD *)&v51[6])--;
        if ( v16 )
        {
          *v12 = 101;
          ++v12;
          ++v57;
          v17 = _getwc_lk(a1);
          v3 = v17;
          *(_DWORD *)&v58[1] = v17;
          if ( (_WORD)v17 == 45 )
          {
            *v12 = v17;
            ++v12;
            goto LABEL_95;
          }
          if ( (_WORD)v17 == 43 )
          {
LABEL_95:
            v18 = (*(_DWORD *)&v51[6])--;
            if ( !v18 )
            {
              *(_DWORD *)&v51[6] = 0;
              goto LABEL_101;
            }
            goto LABEL_100;
          }
LABEL_101:
          while ( !(v3 & 0xFF00) )
          {
            if ( !isdigit((unsigned __int8)v3) )
            {
              break;
            }
            v19 = (*(_DWORD *)&v51[6])--;
            if ( !v19 )
            {
              break;
            }
            ++v53;
            *v12 = v3;
            ++v12;
LABEL_100:
            ++v57;
            v3 = _getwc_lk(a1);
            *(_DWORD *)&v58[1] = v3;
          }
        }
      }
      --v57;
      v40 = a1;
      _un_inc(v3);
      if ( v53 )
      {
        if ( v51[3] )
        {
          goto LABEL_251;
        }
        ++v56;
        *v12 = 0;
        v20 = 2 * (v12 - &WideCharStr) + 2;
        v21 = (CHAR *)malloc(v20);
        if ( v21 )
        {
          sub_41D56B(v21, &WideCharStr, v20);
          v37 = v50 - 1;
          off_42E048(v37, v46, v21);
        }
      }
      break;
    }
    if ( v9 == 105 )
    {
      v9 = 100;
      v45 = 100;
      goto LABEL_67;
    }
    if ( v9 != 110 )
    {
      goto LABEL_130;
    }
    v11 = v57;
    if ( v51[3] )
    {
      goto LABEL_251;
    }
LABEL_246:
    if ( v49 )
    {
      *(_QWORD *)v8 = v48;
    }
    else if ( v50 )
    {
      *(_DWORD *)v8 = v11;
    }
    else
    {
      *(_WORD *)v8 = v11;
    }
LABEL_251:
    ++v58[0];
    a2 = (int)(v63 + 1);
  }
  while ( (unsigned __int16)v3 != -1 || *(_WORD *)a2 == 37 && *(_WORD *)(a2 + 2) == 110 );
LABEL_255:
  if ( *(_DWORD *)&v58[5] == 1 )
  {
    free(v59);
  }
  result = v56;
  if ( (unsigned __int16)v3 == -1 && !v56 && !v58[0] )
  {
    result = -1;
  }
  return result;
}
// 419A78: using guessed type int _hextodec(void);
// 419AAA: using guessed type _DWORD __cdecl _un_inc(__int16);
// 42DDB4: using guessed type int dword_42DDB4;
// 42E048: using guessed type int (__cdecl *off_42E048)(_DWORD, _DWORD, _DWORD);

//----- (0041AFAC) --------------------------------------------------------
_BYTE *sub_41AFAC()
{
  _BYTE *v0; // esi@3
  unsigned __int8 v1; // al@6

  if ( !dword_1BD6D10 )
  {
    __initmbctable();
  }
  v0 = (_BYTE *)dword_1BD6D14;
  if ( dword_1BD6D14 )
  {
    if ( *(_BYTE *)dword_1BD6D14 != 34 )
    {
      if ( *(_BYTE *)dword_1BD6D14 > 0x20u )
      {
        do
        {
          ++v0;
        }
        while ( *v0 > 0x20u );
      }
      goto LABEL_18;
    }
    v0 = (_BYTE *)(dword_1BD6D14 + 1);
    v1 = *(_BYTE *)(dword_1BD6D14 + 1);
    if ( *(_BYTE *)(dword_1BD6D14 + 1) != 34 )
    {
      do
      {
        if ( !v1 )
        {
          break;
        }
        if ( _ismbblead(v1) )
        {
          ++v0;
        }
        v1 = *++v0;
      }
      while ( *v0 != 34 );
      if ( *v0 != 34 )
      {
        goto LABEL_18;
      }
    }
    do
    {
      ++v0;
LABEL_18:
      ;
    }
    while ( *v0 && *v0 <= 0x20u );
  }
  else
  {
    v0 = &unk_422EA4;
  }
  return v0;
}
// 41BC02: using guessed type int __initmbctable(void);
// 1BD6D10: using guessed type int dword_1BD6D10;
// 1BD6D14: using guessed type int dword_1BD6D14;

//----- (0041B248) --------------------------------------------------------
signed int sub_41B248()
{
  void *v0; // eax@5
  int v1; // edi@5
  signed int result; // eax@6
  int v3; // [sp+Ch] [bp-8h]@0
  int v4; // [sp+10h] [bp-4h]@5

  if ( !dword_1BD6D10 )
  {
    __initmbctable();
  }
  byte_1BD5874 = 0;
  GetModuleFileNameA(0, Filename, 0x104u);
  dword_1BD54C8 = (int)Filename;
  if ( dword_1BD6D14 )
  {
    *(_BYTE *)dword_1BD6D14;
  }
  parse_cmdline(0, &v4);
  v0 = malloc(4 * v4 + v3);
  v1 = (int)v0;
  if ( v0 )
  {
    parse_cmdline(v0, &v4);
    dword_1BD54AC = v4 - 1;
    dword_1BD54B0 = v1;
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 41B0DC: using guessed type _DWORD __cdecl parse_cmdline(_DWORD, _DWORD);
// 41BC02: using guessed type int __initmbctable(void);
// 1BD54AC: using guessed type int dword_1BD54AC;
// 1BD54B0: using guessed type int dword_1BD54B0;
// 1BD54C8: using guessed type int dword_1BD54C8;
// 1BD5874: using guessed type char byte_1BD5874;
// 1BD6D10: using guessed type int dword_1BD6D10;
// 1BD6D14: using guessed type int dword_1BD6D14;

//----- (0041B40C) --------------------------------------------------------
void sub_41B40C()
{
  void (**i)(void); // [sp+Ch] [bp-1Ch]@1

  for ( i = (void (**)(void))&unk_42A840; i < (void (**)(void))&unk_42A840; ++i )
  {
    if ( *i )
    {
      (*i)();
    }
  }
}

//----- (0041B450) --------------------------------------------------------
void __cdecl sub_41B450()
{
  void (**i)(void); // [sp+Ch] [bp-1Ch]@1

  for ( i = (void (**)(void))&unk_42A848; i < (void (**)(void))&unk_42A848; ++i )
  {
    if ( *i )
    {
      (*i)();
    }
  }
}

//----- (0041B8AD) --------------------------------------------------------
void *sub_41B8AD()
{
  int v0; // edi@1
  void *v1; // esi@1
  bool v2; // zf@3

  _lock(13);
  v0 = _getptd();
  v1 = *(void **)(v0 + 96);
  if ( v1 != dword_1BD5968 )
  {
    if ( v1 )
    {
      v2 = (*(_DWORD *)v1)-- == 1;
      if ( v2 )
      {
        free(v1);
      }
    }
    *(_DWORD *)(v0 + 96) = dword_1BD5968;
    v1 = dword_1BD5968;
    ++*(_DWORD *)dword_1BD5968;
  }
  _unlock(13);
  return v1;
}
// 4177C6: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 41785A: using guessed type _DWORD __cdecl _lock(_DWORD);

//----- (0041B91C) --------------------------------------------------------
int __cdecl sub_41B91C(UINT CodePage)
{
  int v1; // edx@2
  unsigned int v2; // eax@2
  bool v3; // cf@6
  bool v4; // zf@6
  char *v5; // ecx@8
  unsigned int v6; // edx@9
  unsigned int v7; // eax@10
  char *v8; // ebx@11
  unsigned int v9; // eax@12
  char *i; // esi@12
  char v11; // dl@13
  unsigned int v12; // edi@14
  char v13; // dl@15
  int v14; // eax@20
  int v15; // ecx@20
  char *v16; // ecx@20
  unsigned int v17; // eax@24
  int v18; // ecx@26
  int result; // eax@31
  struct _cpinfo CPInfo; // [sp+Ch] [bp-1Ch]@5
  unsigned int v21; // [sp+20h] [bp-8h]@11
  unsigned int v22; // [sp+24h] [bp-4h]@1
  unsigned int retaddr; // [sp+2Ch] [bp+4h]@1

  v22 = retaddr ^ dword_42DDB4;
  if ( CodePage )
  {
    v1 = 0;
    v2 = 0;
    do
    {
      if ( dword_42E290[v2] == CodePage )
      {
        memset(&byte_1BD5980, 0, 0x100u);
        v21 = 0;
        *(&byte_1BD5980 + 256) = 0;
        v8 = &aJ[48 * v1];
        do
        {
          LOBYTE(v9) = *v8;
          for ( i = v8; (_BYTE)v9; LOBYTE(v9) = *i )
          {
            v11 = i[1];
            if ( !v11 )
            {
              break;
            }
            v9 = (unsigned __int8)v9;
            v12 = (unsigned __int8)v11;
            if ( (unsigned __int8)v9 <= (unsigned int)(unsigned __int8)v11 )
            {
              v13 = byte_42E288[v21];
              do
              {
                byte_1BD5981[v9] |= v13;
                ++v9;
              }
              while ( v9 <= v12 );
            }
            i += 2;
          }
          ++v21;
          v8 += 8;
        }
        while ( v21 < 4 );
        dword_1BD5A84 = CodePage;
        dword_1BD596C = 1;
        v14 = CPtoLCID();
        v16 = &aVyv[v15];
        *(_DWORD *)&word_1BD5A90 = *(_DWORD *)v16;
        *((_DWORD *)&word_1BD5A90 + 1) = *((_DWORD *)v16 + 1);
        Locale = v14;
        *((_DWORD *)&word_1BD5A90 + 2) = *((_DWORD *)v16 + 2);
        goto LABEL_31;
      }
      v2 += 12;
      ++v1;
    }
    while ( v2 < 60 );
    if ( GetCPInfo(CodePage, &CPInfo) == 1 )
    {
      v3 = CPInfo.MaxCharSize < 1;
      v4 = CPInfo.MaxCharSize == 1;
      memset(&byte_1BD5980, 0, 0x100u);
      *(&byte_1BD5980 + 256) = 0;
      dword_1BD5A84 = CodePage;
      Locale = 0;
      if ( v3 || v4 )
      {
        dword_1BD596C = 0;
      }
      else
      {
        if ( CPInfo.LeadByte[0] )
        {
          v5 = (char *)&CPInfo.LeadByte[1];
          do
          {
            LOBYTE(v6) = *v5;
            if ( !*v5 )
            {
              break;
            }
            v7 = (unsigned __int8)*(v5 - 1);
            v6 = (unsigned __int8)v6;
            while ( v7 <= v6 )
            {
              byte_1BD5981[v7] |= 4u;
              ++v7;
            }
            v5 += 2;
          }
          while ( *(v5 - 1) );
        }
        v17 = 1;
        do
        {
          byte_1BD5981[v17] |= 8u;
          ++v17;
        }
        while ( v17 < 0xFF );
        Locale = CPtoLCID();
        dword_1BD596C = v18;
      }
      *(_DWORD *)&word_1BD5A90 = 0;
      *((_DWORD *)&word_1BD5A90 + 1) = 0;
      *((_DWORD *)&word_1BD5A90 + 2) = 0;
      goto LABEL_31;
    }
    if ( dword_1BD5888 )
    {
      goto LABEL_30;
    }
    result = -1;
  }
  else
  {
LABEL_30:
    setSBCS();
LABEL_31:
    setSBUpLow();
    result = 0;
  }
  return result;
}
// 41B6C3: using guessed type int CPtoLCID(void);
// 41B6F2: using guessed type int setSBCS(void);
// 41B71B: using guessed type int setSBUpLow(void);
// 42DDB4: using guessed type int dword_42DDB4;
// 42E290: using guessed type int dword_42E290[];
// 1BD5888: using guessed type int dword_1BD5888;
// 1BD596C: using guessed type int dword_1BD596C;
// 1BD5980: using guessed type char byte_1BD5980;
// 1BD5A90: using guessed type __int16 word_1BD5A90;

//----- (0041BC20) --------------------------------------------------------
int __cdecl sub_41BC20(int a1, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite)
{
  int v4; // esi@3
  int v5; // eax@5
  DWORD v6; // ecx@7
  char *v7; // eax@7
  char *v8; // edx@9
  char v9; // dl@9
  int v10; // edi@12
  char Buffer; // [sp+4h] [bp-420h]@7
  DWORD NumberOfBytesWritten; // [sp+408h] [bp-1Ch]@12
  int v13; // [sp+40Ch] [bp-18h]@1
  int v14; // [sp+410h] [bp-14h]@1
  LPCVOID v15; // [sp+414h] [bp-10h]@6
  int v16; // [sp+418h] [bp-Ch]@7
  DWORD v17; // [sp+41Ch] [bp-8h]@6
  unsigned int v18; // [sp+420h] [bp-4h]@1
  unsigned int retaddr; // [sp+428h] [bp+4h]@1

  v18 = retaddr ^ dword_42DDB4;
  v14 = 0;
  v13 = 0;
  if ( !nNumberOfBytesToWrite )
  {
    return 0;
  }
  v4 = 36 * (a1 & 0x1F);
  if ( *(_BYTE *)(dword_1BD6BE0[a1 >> 5] + v4 + 4) & 0x20 )
  {
    _lseeki64_lk(a1, 0, 0, 2u);
  }
  v5 = v4 + dword_1BD6BE0[a1 >> 5];
  if ( *(_BYTE *)(v5 + 4) & 0x80 )
  {
    v15 = lpBuffer;
    v17 = 0;
    if ( nNumberOfBytesToWrite <= 0 )
    {
      goto LABEL_26;
    }
    while ( 1 )
    {
      v6 = (_BYTE *)v15 - (_BYTE *)lpBuffer;
      v7 = &Buffer;
      v16 = 0;
      do
      {
        if ( v6 >= nNumberOfBytesToWrite )
        {
          break;
        }
        v8 = (char *)v15;
        v15 = (char *)v15 + 1;
        v9 = *v8;
        ++v6;
        if ( v9 == 10 )
        {
          ++v13;
          *v7++ = 13;
          ++v16;
        }
        *v7++ = v9;
        ++v16;
      }
      while ( v16 < 1024 );
      v10 = v7 - &Buffer;
      if ( !WriteFile(*(HANDLE *)(dword_1BD6BE0[a1 >> 5] + v4), &Buffer, v7 - &Buffer, &NumberOfBytesWritten, 0) )
      {
        break;
      }
      v14 += NumberOfBytesWritten;
      if ( (signed int)NumberOfBytesWritten < v10 || (_BYTE *)v15 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
      {
        goto LABEL_17;
      }
    }
    v17 = GetLastError();
  }
  else if ( WriteFile(*(HANDLE *)v5, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0) )
  {
    v17 = 0;
    v14 = NumberOfBytesWritten;
  }
  else
  {
    v17 = GetLastError();
  }
LABEL_17:
  if ( v14 )
  {
    return v14 - v13;
  }
  if ( v17 )
  {
    if ( v17 == 5 )
    {
      *_errno() = 9;
      *__doserrno() = 5;
    }
    else
    {
      _dosmaperr(v17);
    }
    return -1;
  }
LABEL_26:
  if ( *(_BYTE *)(dword_1BD6BE0[a1 >> 5] + v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
  {
    return 0;
  }
  *_errno() = 28;
  *__doserrno() = 0;
  return -1;
}
// 41764A: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 42DDB4: using guessed type int dword_42DDB4;
// 1BD6BE0: using guessed type int dword_1BD6BE0[];

//----- (0041BDC5) --------------------------------------------------------
int __cdecl sub_41BDC5(int a1, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite)
{
  int v3; // esi@2
  int result; // eax@6
  int v5; // [sp+Ch] [bp-1Ch]@4

  if ( a1 < uNumber && (v3 = 36 * (a1 & 0x1F), *(_BYTE *)(dword_1BD6BE0[a1 >> 5] + v3 + 4) & 1) )
  {
    sub_418A61(a1);
    if ( *(_BYTE *)(dword_1BD6BE0[a1 >> 5] + v3 + 4) & 1 )
    {
      v5 = sub_41BC20(a1, lpBuffer, nNumberOfBytesToWrite);
    }
    else
    {
      *_errno() = 9;
      *__doserrno() = 0;
      v5 = -1;
    }
    _unlock_fhandle(a1);
    result = v5;
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    result = -1;
  }
  return result;
}
// 418AD4: using guessed type _DWORD __cdecl _unlock_fhandle(_DWORD);
// 1BD6BE0: using guessed type int dword_1BD6BE0[];

//----- (0041BEDE) --------------------------------------------------------
wchar_t __cdecl sub_41BEDE(wchar_t a1, FILE *a2)
{
  bool v2; // zf@1
  int v3; // eax@2
  _BYTE *v4; // eax@3
  int v5; // eax@6
  int v6; // ebx@6
  wchar_t result; // ax@8
  int v8; // edi@9
  bool v9; // sf@10
  int v10; // eax@11
  char v11[8]; // [sp+Ch] [bp-Ch]@6
  unsigned int v12; // [sp+14h] [bp-4h]@1
  unsigned int retaddr; // [sp+1Ch] [bp+4h]@1

  v2 = (a2->_flag & 0x40) == 0;
  v12 = retaddr ^ dword_42DDB4;
  if ( v2 && ((v3 = a2->_file, v3 == -1) ? (v4 = &unk_42DD90) : (v4 = (_BYTE *)(dword_1BD6BE0[a2->_file >> 5] + 36 * (a2->_file & 0x1F))), v4[4] & 0x80) )
  {
    v5 = wctomb(v11, a1);
    v6 = v5;
    if ( v5 == -1 )
    {
      *_errno() = 42;
      return -1;
    }
    v8 = 0;
    if ( v5 > 0 )
    {
      do
      {
        v9 = a2->_cnt-- - 1 < 0;
        if ( v9 )
        {
          v10 = _flsbuf(v11[v8], a2);
        }
        else
        {
          *a2->_ptr = v11[v8];
          v10 = *a2->_ptr++;
        }
        if ( v10 == -1 )
        {
          return -1;
        }
      }
      while ( ++v8 < v6 );
    }
    result = a1;
  }
  else
  {
    v9 = a2->_cnt - 2 < 0;
    a2->_cnt -= 2;
    if ( v9 )
    {
      result = _flswbuf(a1, (int)a2);
    }
    else
    {
      result = a1;
      *(_WORD *)a2->_ptr = a1;
      a2->_ptr += 2;
    }
  }
  return result;
}
// 42DDB4: using guessed type int dword_42DDB4;
// 1BD6BE0: using guessed type int dword_1BD6BE0[];
// 41BEDE: using guessed type char var_C[8];

//----- (0041C52F) --------------------------------------------------------
void __cdecl __noreturn sub_41C52F(int a1, int a2)
{
  const char *v2; // edi@4
  signed int v3; // esi@4
  char *v4; // ebx@8
  void *v5; // esp@10
  char v6; // [sp-25h] [bp-159h]@9
  int *v7; // [sp-20h] [bp-154h]@10
  char *v8; // [sp-1Ch] [bp-150h]@10
  int *v9; // [sp-8h] [bp-13Ch]@10
  const char *v10; // [sp-4h] [bp-138h]@10
  int v11; // [sp+0h] [bp-134h]@10
  CHAR Filename; // [sp+Ch] [bp-128h]@6
  char v13; // [sp+110h] [bp-24h]@6
  char *v14; // [sp+114h] [bp-20h]@4
  unsigned int v15; // [sp+118h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+11Ch] [bp-18h]@2
  unsigned int retaddr; // [sp+138h] [bp+4h]@1

  v15 = retaddr ^ dword_42DDB4;
  if ( dword_1BD58B4 )
  {
    dword_1BD58B4(a1, a2);
    ms_exc.registration.TryLevel = -1;
  }
  else
  {
    if ( a1 == 1 )
    {
      v2 = "Buffer overrun detected!";
      v14 = "A buffer overrun has been detected which has corrupted the program's\ninternal state.  The program cannot safely continue execution and must\nnow be terminated.\n";
      v3 = 185;
    }
    else
    {
      v2 = "Unknown security failure detected!";
      v14 = "A security error of unknown cause has been detected which has\ncorrupted the program's internal state.  The program cannot safely\ncontinue execution and must now be terminated.\n";
      v3 = 212;
    }
    v13 = 0;
    if ( !GetModuleFileNameA(0, &Filename, 0x104u) )
    {
      strcpy(&Filename, "<program name unknown>");
    }
    v4 = &Filename;
    if ( strlen(&Filename) + 11 > 0x3C )
    {
      v4 = &v6 + strlen(&Filename);
      strncpy(v4, "...", 3u);
    }
    v5 = alloca(strlen(v4) + v3 + 12);
    ms_exc.old_esp = (DWORD)&v11;
    v10 = v2;
    v9 = &v11;
    strcpy((char *)&v11, v2);
    strcat((char *)&v11, "\n\n");
    strcat((char *)&v11, "Program: ");
    v8 = v4;
    v7 = &v11;
    strcat((char *)&v11, v4);
    strcat((char *)&v11, "\n\n");
    strcat((char *)&v11, v14);
    __crtMessageBoxA(&v11, "Microsoft Visual C++ Runtime Library", 8208);
  }
  _exit(3);
}
// 41D652: using guessed type _DWORD __cdecl __crtMessageBoxA(_DWORD, _DWORD, __int16);
// 42DDB4: using guessed type int dword_42DDB4;
// 1BD58B4: using guessed type int (__cdecl *dword_1BD58B4)(_DWORD, _DWORD);

//----- (0041CDF6) --------------------------------------------------------
int __cdecl sub_41CDF6(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_42E3FC);
}
// 41CC9E: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (0041CE0C) --------------------------------------------------------
int __cdecl sub_41CE0C(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_42E414);
}
// 41CC9E: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (0041CE22) --------------------------------------------------------
int __cdecl sub_41CE22(int a1, int a2)
{
  char v3; // [sp+0h] [bp-14h]@1
  char v4; // [sp+Ch] [bp-8h]@1
  unsigned int v5; // [sp+10h] [bp-4h]@1
  unsigned int retaddr; // [sp+18h] [bp+4h]@1

  v5 = retaddr ^ dword_42DDB4;
  __strgtold12(&v3, &v4, a2, 0, 0, 0, 0);
  return sub_41CDF6((int)&v3, a1);
}
// 41E9BD: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 42DDB4: using guessed type int dword_42DDB4;

//----- (0041CE65) --------------------------------------------------------
int __cdecl sub_41CE65(int a1, int a2)
{
  char v3; // [sp+0h] [bp-14h]@1
  char v4; // [sp+Ch] [bp-8h]@1
  unsigned int v5; // [sp+10h] [bp-4h]@1
  unsigned int retaddr; // [sp+18h] [bp+4h]@1

  v5 = retaddr ^ dword_42DDB4;
  __strgtold12(&v3, &v4, a2, 0, 0, 0, 0);
  return sub_41CE0C((int)&v3, a1);
}
// 41E9BD: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 42DDB4: using guessed type int dword_42DDB4;

//----- (0041CFD9) --------------------------------------------------------
int __cdecl sub_41CFD9(char a1, int a2, int a3, char *a4)
{
  signed int v4; // eax@1
  int v5; // esi@1
  char *v6; // edi@1
  __int16 v8; // [sp+8h] [bp-2Ch]@1
  char v9; // [sp+Ah] [bp-2Ah]@1
  char v10; // [sp+Ch] [bp-28h]@1
  __int64 v11; // [sp+24h] [bp-10h]@1
  __int16 v12; // [sp+2Ch] [bp-8h]@1
  unsigned int v13; // [sp+30h] [bp-4h]@1
  unsigned int retaddr; // [sp+38h] [bp+4h]@1

  v13 = retaddr ^ dword_42DDB4;
  __dtold(&v11, &a1);
  v4 = sub_41EDF7(v11, v12, 17, 0, (int)&v8);
  v5 = a3;
  v6 = a4;
  *(_DWORD *)(a3 + 8) = v4;
  *(_DWORD *)v5 = v9;
  *(_DWORD *)(v5 + 4) = v8;
  strcpy(v6, &v10);
  *(_DWORD *)(v5 + 12) = v6;
  return v5;
}
// 41CF1F: using guessed type _DWORD __cdecl __dtold(_DWORD, _DWORD);
// 42DDB4: using guessed type int dword_42DDB4;

//----- (0041D1BC) --------------------------------------------------------
wchar_t __cdecl sub_41D1BC(wchar_t a1, int a2)
{
  int v2; // eax@2
  int v3; // ecx@7
  int v4; // eax@8
  _BYTE *v5; // eax@9
  int v6; // eax@12
  unsigned int v8; // ecx@16
  int i; // ecx@20
  unsigned int v10; // eax@23
  wchar_t *v11; // eax@27
  char v12; // [sp+Ch] [bp-Ch]@12
  char v13[7]; // [sp+Dh] [bp-Bh]@21
  unsigned int v14; // [sp+14h] [bp-4h]@1
  unsigned int retaddr; // [sp+1Ch] [bp+4h]@1

  v14 = retaddr ^ dword_42DDB4;
  if ( a1 == -1 )
  {
    return -1;
  }
  v2 = *(_DWORD *)(a2 + 12);
  if ( !(v2 & 1) && ((char)v2 >= 0 || v2 & 2) )
  {
    return -1;
  }
  if ( !*(_DWORD *)(a2 + 8) )
  {
    _getbuf(a2);
  }
  v3 = *(_DWORD *)(a2 + 12) & 0x40;
  if ( v3 || ((v4 = *(_DWORD *)(a2 + 16), v4 == -1) ? (v5 = &unk_42DD90) : (v5 = (_BYTE *)(dword_1BD6BE0[*(_DWORD *)(a2 + 16) >> 5] + 36 * (*(_DWORD *)(a2 + 16) & 0x1F))), !(v5[4] & 0x80)) )
  {
    v10 = *(_DWORD *)(a2 + 8) + 2;
    if ( *(_DWORD *)a2 < v10 )
    {
      if ( *(_DWORD *)(a2 + 4) || *(_DWORD *)(a2 + 24) < 2u )
      {
        return -1;
      }
      *(_DWORD *)a2 = v10;
    }
    *(_DWORD *)a2 -= 2;
    v11 = *(wchar_t **)a2;
    if ( v3 )
    {
      if ( *v11 != a1 )
      {
        *(_DWORD *)a2 = v11 + 1;
        return -1;
      }
    }
    else
    {
      *v11 = a1;
    }
    *(_DWORD *)(a2 + 4) += 2;
  }
  else
  {
    v6 = wctomb(&v12, a1);
    if ( v6 == -1 )
    {
      *_errno() = 42;
      return -1;
    }
    v8 = v6 + *(_DWORD *)(a2 + 8);
    if ( *(_DWORD *)a2 < v8 )
    {
      if ( *(_DWORD *)(a2 + 4) || v6 > *(_DWORD *)(a2 + 24) )
      {
        return -1;
      }
      *(_DWORD *)a2 = v8;
    }
    for ( i = v6 - 1; i >= 0; **(_BYTE **)a2 = v13[i] )
    {
      --*(_DWORD *)a2;
      --i;
    }
    *(_DWORD *)(a2 + 4) += v6;
  }
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a2 + 12) & 0xFFFFFFEF | 1;
  return a1;
}
// 41BE70: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 42DDB4: using guessed type int dword_42DDB4;
// 1BD6BE0: using guessed type int dword_1BD6BE0[];
// 41D1BC: using guessed type char var_B[7];

//----- (0041D2E3) --------------------------------------------------------
signed int sub_41D2E3()
{
  void *v0; // esp@1
  char *v1; // edi@2
  char *v2; // esi@2
  int v3; // eax@2
  char *v4; // ebx@4
  PVOID v5; // ebx@7
  int v7; // [sp-4h] [bp-58h]@1
  struct _SYSTEM_INFO SystemInfo; // [sp+Ch] [bp-48h]@2
  struct _MEMORY_BASIC_INFORMATION Buffer; // [sp+30h] [bp-24h]@1
  DWORD flOldProtect; // [sp+4Ch] [bp-8h]@13
  SIZE_T dwSize; // [sp+50h] [bp-4h]@2

  v0 = alloca(4);
  if ( !VirtualQuery(&v7, &Buffer, 0x1Cu) )
  {
    return 0;
  }
  v1 = (char *)Buffer.AllocationBase;
  GetSystemInfo(&SystemInfo);
  v2 = (char *)(((unsigned int)&v7 & ~(SystemInfo.dwPageSize - 1)) - SystemInfo.dwPageSize);
  dwSize = SystemInfo.dwPageSize;
  v3 = dword_1BD5498;
  if ( v2 < &v1[dword_1BD5498 != 1 ? 0x2000 : 69632] )
  {
    return 0;
  }
  if ( dword_1BD5498 != 1 )
  {
    v4 = v1;
    while ( VirtualQuery(v4, &Buffer, 0x1Cu) )
    {
      v4 += Buffer.RegionSize;
      if ( Buffer.State & 0x1000 )
      {
        v5 = Buffer.BaseAddress;
        if ( BYTE1(Buffer.Protect) & 1 )
        {
          return 1;
        }
        if ( v2 < Buffer.BaseAddress )
        {
          return 0;
        }
        VirtualAlloc(Buffer.BaseAddress, dwSize, 0x1000u, 4u);
        v3 = dword_1BD5498;
        return VirtualProtect(v5, dwSize, v3 != 1 ? 260 : 1, &flOldProtect);
      }
    }
    return 0;
  }
  v5 = (PVOID)(((unsigned int)&v7 & ~(SystemInfo.dwPageSize - 1)) - SystemInfo.dwPageSize);
  return VirtualProtect(v5, dwSize, v3 != 1 ? 260 : 1, &flOldProtect);
}
// 1BD5498: using guessed type int dword_1BD5498;

//----- (0041D3B4) --------------------------------------------------------
int __cdecl sub_41D3B4(int a1, LPSTR lpMultiByteStr, LPCWSTR lpWideCharStr, int cchWideChar)
{
  unsigned int v4; // esi@1
  int v5; // edx@2
  int result; // eax@3
  LPCWSTR v7; // ecx@6
  WCHAR v8; // ax@8
  LPCWSTR v9; // eax@13
  int v10; // esi@13
  int v11; // eax@23
  int v12; // eax@30
  int v13; // edx@33
  char v14; // cl@34
  char MultiByteStr[8]; // [sp+Ch] [bp-14h]@30
  int v16; // [sp+14h] [bp-Ch]@30
  BOOL UsedDefaultChar; // [sp+18h] [bp-8h]@1
  unsigned int v18; // [sp+1Ch] [bp-4h]@1
  unsigned int retaddr; // [sp+24h] [bp+4h]@1

  v4 = 0;
  v18 = retaddr ^ dword_42DDB4;
  UsedDefaultChar = 0;
  if ( lpMultiByteStr )
  {
    v5 = cchWideChar;
    if ( !cchWideChar )
    {
      return 0;
    }
    if ( !*(_DWORD *)(a1 + 20) )
    {
      if ( (unsigned int)cchWideChar <= 0 )
      {
        return v4;
      }
      v7 = lpWideCharStr;
      while ( *v7 <= 0xFFu )
      {
        lpMultiByteStr[v4] = *(_BYTE *)v7;
        v8 = *v7;
        ++v7;
        if ( !v8 )
        {
          return v4;
        }
        if ( ++v4 < cchWideChar )
        {
          continue;
        }
        return v4;
      }
      goto LABEL_28;
    }
    if ( cbMultiByte == 1 )
    {
      if ( (unsigned int)cchWideChar > 0 )
      {
        v9 = lpWideCharStr;
        v10 = cchWideChar;
        do
        {
          if ( !*v9 )
          {
            break;
          }
          ++v9;
          --v10;
        }
        while ( v10 );
        if ( v10 && !*v9 )
        {
          v5 = v9 - lpWideCharStr + 1;
        }
      }
      result = WideCharToMultiByte(*(_DWORD *)(a1 + 4), 0, lpWideCharStr, v5, lpMultiByteStr, v5, 0, &UsedDefaultChar);
      if ( result && !UsedDefaultChar )
      {
        if ( lpMultiByteStr[result - 1] )
        {
          return result;
        }
        goto LABEL_43;
      }
    }
    else
    {
      v11 = WideCharToMultiByte(*(_DWORD *)(a1 + 4), 0, lpWideCharStr, -1, lpMultiByteStr, cchWideChar, 0, &UsedDefaultChar);
      v4 = v11;
      if ( v11 )
      {
        if ( !UsedDefaultChar )
        {
          return v11 - 1;
        }
        goto LABEL_28;
      }
      if ( !UsedDefaultChar && GetLastError() == 122 )
      {
        while ( v4 < cchWideChar )
        {
          v12 = WideCharToMultiByte(*(_DWORD *)(a1 + 4), 0, lpWideCharStr, 1, MultiByteStr, cbMultiByte, 0, &UsedDefaultChar);
          v16 = v12;
          if ( !v12 || UsedDefaultChar )
          {
            goto LABEL_28;
          }
          if ( v12 + v4 > cchWideChar )
          {
            return v4;
          }
          v13 = 0;
          if ( v12 > 0 )
          {
            do
            {
              v14 = MultiByteStr[v13];
              lpMultiByteStr[v4] = v14;
              if ( !v14 )
              {
                return v4;
              }
              ++v13;
              ++v4;
            }
            while ( v13 < v16 );
          }
          ++lpWideCharStr;
        }
        return v4;
      }
    }
LABEL_28:
    *_errno() = 42;
    return -1;
  }
  if ( !*(_DWORD *)(a1 + 20) )
  {
    return wcslen(lpWideCharStr);
  }
  result = WideCharToMultiByte(*(_DWORD *)(a1 + 4), 0, lpWideCharStr, -1, 0, 0, 0, &UsedDefaultChar);
  if ( !result || UsedDefaultChar )
  {
    goto LABEL_28;
  }
LABEL_43:
  --result;
  return result;
}
// 42DDB4: using guessed type int dword_42DDB4;
// 41D3B4: using guessed type CHAR MultiByteStr[8];

//----- (0041D56B) --------------------------------------------------------
int __cdecl sub_41D56B(LPSTR lpMultiByteStr, LPCWSTR lpWideCharStr, int cchWideChar)
{
  void *v3; // eax@1

  v3 = *(void **)(_getptd() + 100);
  if ( v3 != off_42E14C )
  {
    v3 = (void *)__updatetlocinfo();
  }
  return sub_41D3B4((int)v3, lpMultiByteStr, lpWideCharStr, cchWideChar);
}
// 41B688: using guessed type int __updatetlocinfo(void);
// 42E14C: using guessed type void *off_42E14C;

//----- (0041E5E7) --------------------------------------------------------
__int32 __cdecl sub_41E5E7(LCID Locale)
{
  __int32 result; // eax@2
  CHAR LCData; // [sp+0h] [bp-Ch]@1
  char v3; // [sp+6h] [bp-6h]@1
  unsigned int v4; // [sp+8h] [bp-4h]@1
  unsigned int retaddr; // [sp+10h] [bp+4h]@1

  v3 = 0;
  v4 = retaddr ^ dword_42DDB4;
  if ( GetLocaleInfoA(Locale, 0x1004u, &LCData, 6) )
  {
    result = atol(&LCData);
  }
  else
  {
    result = -1;
  }
  return result;
}
// 42DDB4: using guessed type int dword_42DDB4;

//----- (0041E630) --------------------------------------------------------
void *__cdecl sub_41E630(UINT CodePage, UINT a2, LPCSTR lpMultiByteStr, int a4, LPSTR a5, int a6)
{
  int v6; // ebx@1
  size_t v7; // esi@9
  void *v8; // esp@15
  const WCHAR *v9; // ebx@15
  void *v11; // eax@25
  int v12; // eax@26
  int v13; // [sp+0h] [bp-54h]@15
  const WCHAR *v14; // [sp+Ch] [bp-48h]@15
  size_t v15; // [sp+10h] [bp-44h]@11
  struct _cpinfo CPInfo; // [sp+14h] [bp-40h]@2
  int v17; // [sp+28h] [bp-2Ch]@1
  int cbMultiByte; // [sp+2Ch] [bp-28h]@1
  int v19; // [sp+30h] [bp-24h]@1
  void *v20; // [sp+34h] [bp-20h]@1
  unsigned int v21; // [sp+38h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+3Ch] [bp-18h]@15
  unsigned int retaddr; // [sp+58h] [bp+4h]@1

  v21 = retaddr ^ dword_42DDB4;
  v20 = 0;
  v19 = 0;
  v6 = *(_DWORD *)a4;
  cbMultiByte = *(_DWORD *)a4;
  v17 = 0;
  if ( CodePage == a2 )
  {
    v9 = v14;
  }
  else
  {
    if ( GetCPInfo(CodePage, &CPInfo) && CPInfo.MaxCharSize == 1 && GetCPInfo(a2, &CPInfo) && CPInfo.MaxCharSize == 1 )
    {
      v17 = 1;
    }
    if ( v17 )
    {
      if ( v6 == -1 )
      {
        v7 = strlen(lpMultiByteStr) + 1;
      }
      else
      {
        v7 = v6;
      }
      v15 = v7;
    }
    else
    {
      v7 = v15;
    }
    if ( !v17 )
    {
      v7 = MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, v6, 0, 0);
      v15 = v7;
      if ( !v7 )
      {
        return 0;
      }
    }
    v8 = alloca(2 * v7);
    ms_exc.old_esp = (DWORD)&v13;
    v9 = (const WCHAR *)&v13;
    v14 = (const WCHAR *)&v13;
    memset(&v13, 0, 2 * v7);
    ms_exc.registration.TryLevel = -1;
    if ( !&v13 )
    {
      v9 = (const WCHAR *)calloc_crt(2, v7);
      if ( !v9 )
      {
        return 0;
      }
      v19 = 1;
    }
    if ( MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cbMultiByte, (LPWSTR)v9, v7) )
    {
      if ( a5 )
      {
        if ( WideCharToMultiByte(a2, 0, v9, v7, a5, a6, 0, 0) )
        {
          v20 = a5;
        }
      }
      else if ( v17 || (v7 = WideCharToMultiByte(a2, 0, v9, v7, 0, 0, 0, 0)) != 0 )
      {
        v11 = calloc_crt(1, v7);
        v20 = v11;
        if ( v11 )
        {
          v12 = WideCharToMultiByte(a2, 0, v9, v7, (LPSTR)v11, v7, 0, 0);
          if ( v12 )
          {
            if ( cbMultiByte != -1 )
            {
              *(_DWORD *)a4 = v12;
            }
          }
          else
          {
            free(v20);
            v20 = 0;
          }
        }
      }
    }
  }
  if ( v19 )
  {
    free((void *)v9);
  }
  return v20;
}
// 42DDB4: using guessed type int dword_42DDB4;

//----- (0041E8D9) --------------------------------------------------------
__int16 __cdecl sub_41E8D9(_BYTE *a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // eax@3
  int v5; // edi@5
  unsigned int v6; // ecx@6
  unsigned __int64 v7; // kr08_8@6
  int v8; // eax@6
  __int16 result; // ax@11
  int v10; // [sp+Ch] [bp-14h]@3
  int v11; // [sp+10h] [bp-10h]@3
  int v12; // [sp+14h] [bp-Ch]@3
  int v13; // [sp+18h] [bp-8h]@1
  unsigned int v14; // [sp+1Ch] [bp-4h]@1
  unsigned int retaddr; // [sp+24h] [bp+4h]@1
  int v16; // [sp+30h] [bp+10h]@2

  v3 = a3;
  v14 = retaddr ^ dword_42DDB4;
  v13 = 16462;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  if ( a2 )
  {
    v16 = a2;
    do
    {
      v10 = *(_DWORD *)v3;
      v11 = *(_DWORD *)(v3 + 4);
      v12 = *(_DWORD *)(v3 + 8);
      __shl_12(v3);
      __shl_12(v3);
      __add_12(v3, &v10);
      __shl_12(v3);
      v4 = *a1;
      v11 = 0;
      v12 = 0;
      v10 = v4;
      __add_12(v3, &v10);
      ++a1;
      --v16;
    }
    while ( v16 );
  }
  if ( !*(_DWORD *)(v3 + 8) )
  {
    v5 = *(_DWORD *)(v3 + 8);
    do
    {
      v6 = *(_DWORD *)(v3 + 4);
      v13 += 65520;
      v7 = (unsigned __int64)v6 << 16;
      v8 = *(_DWORD *)v3 << 16;
      *(_DWORD *)(v3 + 4) = v7 | (*(_DWORD *)v3 >> 16);
      *(_DWORD *)v3 = v8;
    }
    while ( is_mul_ok(0x10000u, v6) );
    *(_DWORD *)(v3 + 8) = HIDWORD(v7);
  }
  while ( !(*(_DWORD *)(v3 + 8) & 0x8000) )
  {
    __shl_12(v3);
    v13 += 0xFFFF;
  }
  result = v13;
  *(_WORD *)(v3 + 10) = v13;
  return result;
}
// 41E820: using guessed type _DWORD __cdecl __add_12(_DWORD, _DWORD);
// 41E87E: using guessed type _DWORD __cdecl __shl_12(_DWORD);
// 42DDB4: using guessed type int dword_42DDB4;

//----- (0041EDF7) --------------------------------------------------------
signed int __cdecl sub_41EDF7(__int64 a1, __int16 a2, int a3, char a4, int a5)
{
  unsigned __int16 v5; // dx@1
  unsigned int v6; // ecx@20
  int v7; // esi@20
  int v8; // edi@22
  int v9; // esi@27
  int v10; // esi@30
  int v11; // eax@32
  char v12; // al@34
  _BYTE *v13; // ecx@34
  bool v14; // zf@34
  char *v15; // eax@36
  char v16; // cl@36
  char *v17; // eax@36
  bool v18; // sf@36
  unsigned __int8 v19; // of@36
  char *v20; // ecx@36
  char v21; // al@44
  __int64 v23; // [sp+Ch] [bp-30h]@34
  int v24; // [sp+14h] [bp-28h]@34
  char v25; // [sp+18h] [bp-24h]@1
  char v26; // [sp+19h] [bp-23h]@1
  char v27; // [sp+1Ah] [bp-22h]@1
  char v28; // [sp+1Bh] [bp-21h]@1
  char v29; // [sp+1Ch] [bp-20h]@1
  char v30; // [sp+1Dh] [bp-1Fh]@1
  char v31; // [sp+1Eh] [bp-1Eh]@1
  char v32; // [sp+1Fh] [bp-1Dh]@1
  char v33; // [sp+20h] [bp-1Ch]@1
  char v34; // [sp+21h] [bp-1Bh]@1
  char v35; // [sp+22h] [bp-1Ah]@1
  char v36; // [sp+23h] [bp-19h]@1
  __int64 v37; // [sp+24h] [bp-18h]@20
  int v38; // [sp+2Ch] [bp-10h]@34
  unsigned __int16 v39; // [sp+2Eh] [bp-Eh]@20
  int v40; // [sp+30h] [bp-Ch]@33
  int v41; // [sp+34h] [bp-8h]@1
  unsigned int v42; // [sp+38h] [bp-4h]@1
  unsigned int retaddr; // [sp+40h] [bp+4h]@1
  signed int v44; // [sp+4Ch] [bp+10h]@27
  int v45; // [sp+4Ch] [bp+10h]@32

  v42 = retaddr ^ dword_42DDB4;
  v25 = -52;
  v26 = -52;
  v27 = -52;
  v28 = -52;
  v29 = -52;
  v30 = -52;
  v31 = -52;
  v32 = -52;
  v33 = -52;
  v34 = -52;
  v35 = -5;
  v36 = 63;
  v41 = 1;
  v5 = a2 & 0x7FFF;
  if ( a2 & 0x8000 )
  {
    *(_BYTE *)(a5 + 2) = 45;
  }
  else
  {
    *(_BYTE *)(a5 + 2) = 32;
  }
  if ( v5 || a1 )
  {
    if ( v5 == 0x7FFF )
    {
      *(_WORD *)a5 = 1;
      if ( a1 != 0x8000000000000000i64 && !(HIDWORD(a1) & 0x40000000) )
      {
        strcpy((char *)(a5 + 4), "1#SNAN");
LABEL_19:
        *(_BYTE *)(a5 + 3) = 6;
        return 0;
      }
      if ( a2 & 0x8000 && HIDWORD(a1) == -1073741824 )
      {
        if ( !(_DWORD)a1 )
        {
          strcpy((char *)(a5 + 4), "1#IND");
LABEL_16:
          *(_BYTE *)(a5 + 3) = 5;
          return 0;
        }
      }
      else if ( a1 == 0x8000000000000000i64 )
      {
        strcpy((char *)(a5 + 4), "1#INF");
        goto LABEL_16;
      }
      strcpy((char *)(a5 + 4), "1#QNAN");
      goto LABEL_19;
    }
    LOWORD(v37) = 0;
    v6 = 77 * (((unsigned int)v5 >> 8) + 2 * (HIDWORD(a1) >> 24));
    *(__int64 *)((char *)&v37 + 2) = a1;
    v7 = (signed int)(v6 + 19728 * v5 - 323162868) >> 16;
    v39 = a2 & 0x7FFF;
    sub_41F91F(&v37, -(signed __int16)((v6 + 19728 * v5 - 323162868) >> 16), 1);
    if ( v39 >= 0x3FFFu )
    {
      LOWORD(v7) = v7 + 1;
      __ld12mul(&v37, &v25);
    }
    v8 = a3;
    *(_WORD *)a5 = v7;
    if ( !(a4 & 1) || (v8 = (signed __int16)v7 + a3, v8 > 0) )
    {
      if ( v8 > 21 )
      {
        v8 = 21;
      }
      v9 = v39 - 16382;
      v39 = 0;
      v44 = 8;
      do
      {
        __shl_12(&v37);
        --v44;
      }
      while ( v44 );
      if ( v9 < 0 )
      {
        v10 = -v9 & 0xFF;
        if ( v10 > 0 )
        {
          do
          {
            __shr_12(&v37);
            --v10;
          }
          while ( v10 );
        }
      }
      v11 = a5 + 4;
      v45 = a5 + 4;
      if ( v8 + 1 > 0 )
      {
        v40 = v8 + 1;
        do
        {
          v23 = v37;
          v24 = v38;
          __shl_12(&v37);
          __shl_12(&v37);
          __add_12(&v37, &v23);
          __shl_12(&v37);
          v12 = HIBYTE(v39);
          v13 = (_BYTE *)v45;
          HIBYTE(v39) = 0;
          ++v45;
          v14 = v40-- == 1;
          *v13 = v12 + 48;
        }
        while ( !v14 );
        v11 = v45;
      }
      v15 = (char *)(v11 - 1);
      v16 = *v15;
      v17 = v15 - 1;
      v19 = __OFSUB__(v16, 53);
      v18 = (char)(v16 - 53) < 0;
      v20 = (char *)(a5 + 4);
      if ( v18 ^ v19 )
      {
        while ( v17 >= v20 && *v17 == 48 )
        {
          --v17;
        }
        if ( v17 < v20 )
        {
          *v20 = 48;
          goto LABEL_52;
        }
      }
      else
      {
        while ( v17 >= v20 && *v17 == 57 )
        {
          *v17-- = 48;
        }
        if ( v17 < v20 )
        {
          ++v17;
          ++*(_WORD *)a5;
        }
        ++*v17;
      }
      v21 = (_BYTE)v17 - a5 - 3;
      *(_BYTE *)(a5 + 3) = v21;
      *(_BYTE *)(v21 + a5 + 4) = 0;
      return v41;
    }
  }
  *(_BYTE *)(a5 + 4) = 48;
LABEL_52:
  *(_WORD *)a5 = 0;
  *(_BYTE *)(a5 + 5) = 0;
  *(_BYTE *)(a5 + 2) = 32;
  *(_BYTE *)(a5 + 3) = 1;
  return 1;
}
// 41E820: using guessed type _DWORD __cdecl __add_12(_DWORD, _DWORD);
// 41E87E: using guessed type _DWORD __cdecl __shl_12(_DWORD);
// 41E8AC: using guessed type _DWORD __cdecl __shr_12(_DWORD);
// 41F6E7: using guessed type _DWORD __cdecl __ld12mul(_DWORD, _DWORD);
// 42DDB4: using guessed type int dword_42DDB4;

//----- (0041F0FA) --------------------------------------------------------
int __cdecl sub_41F0FA(LCID Locale, DWORD dwCmpFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpString2, int cchCount2, UINT CodePage)
{
  void *v7; // edi@1
  int v8; // esi@1
  signed int v9; // eax@8
  char *v11; // eax@25
  unsigned __int8 v12; // dl@26
  char *v13; // eax@33
  unsigned __int8 v14; // dl@34
  int v15; // ebx@39
  void *v16; // esp@40
  WCHAR *v17; // eax@40
  int v18; // esi@44
  void *v19; // esp@45
  const WCHAR *v20; // edi@45
  UINT v21; // ebx@57
  __int32 v22; // eax@59
  UINT v23; // esi@59
  int v24; // [sp+0h] [bp-5Ch]@40
  void *v25; // [sp+Ch] [bp-50h]@55
  int *v26; // [sp+10h] [bp-4Ch]@45
  int v27; // [sp+14h] [bp-48h]@44
  LPWSTR lpWideCharStr; // [sp+18h] [bp-44h]@40
  int v29; // [sp+1Ch] [bp-40h]@39
  struct _cpinfo CPInfo; // [sp+20h] [bp-3Ch]@22
  int v31; // [sp+34h] [bp-28h]@13
  int v32; // [sp+38h] [bp-24h]@13
  int v33; // [sp+3Ch] [bp-20h]@13
  unsigned int v34; // [sp+40h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+44h] [bp-18h]@40
  unsigned int retaddr; // [sp+60h] [bp+4h]@1

  v34 = retaddr ^ dword_42DDB4;
  v7 = 0;
  v8 = 1;
  if ( !dword_1BD594C )
  {
    if ( CompareStringW(0, 0, &String1, 1, &String1, 1) )
    {
      dword_1BD594C = 1;
    }
    else if ( GetLastError() == 120 )
    {
      dword_1BD594C = 2;
    }
  }
  if ( cbMultiByte > 0 )
  {
    cbMultiByte = strncnt(cbMultiByte);
  }
  v9 = cchCount2;
  if ( cchCount2 > 0 )
  {
    v9 = strncnt(cchCount2);
    cchCount2 = v9;
  }
  if ( dword_1BD594C == 2 || !dword_1BD594C )
  {
    v25 = 0;
    if ( !Locale )
    {
      Locale = dword_1BD5894;
    }
    v21 = CodePage;
    if ( !CodePage )
    {
      v21 = ::CodePage;
    }
    v22 = sub_41E5E7(Locale);
    v23 = v22;
    if ( v22 == -1 )
    {
      return 0;
    }
    if ( v22 != v21 )
    {
      v7 = sub_41E630(v21, v22, lpMultiByteStr, (int)&cbMultiByte, 0, 0);
      if ( !v7 )
      {
        return 0;
      }
      v25 = sub_41E630(v21, v23, lpString2, (int)&cchCount2, 0, 0);
      if ( !v25 )
      {
        free(v7);
        return 0;
      }
      lpMultiByteStr = (LPCSTR)v7;
      lpString2 = (LPCSTR)v25;
    }
    v8 = CompareStringA(Locale, dwCmpFlags, lpMultiByteStr, cbMultiByte, lpString2, cchCount2);
    if ( !v7 )
    {
      return v8;
    }
    free(v7);
    free(v25);
    return v8;
  }
  if ( dword_1BD594C != 1 )
  {
    return 0;
  }
  v33 = 0;
  v32 = 0;
  v31 = 0;
  if ( !CodePage )
  {
    CodePage = ::CodePage;
  }
  if ( !cbMultiByte || !v9 )
  {
    if ( cbMultiByte == v9 )
    {
      return 2;
    }
    if ( v9 > 1 )
    {
      return v8;
    }
    if ( cbMultiByte > 1 )
    {
      return 3;
    }
    if ( !GetCPInfo(CodePage, &CPInfo) )
    {
      return 0;
    }
    if ( cbMultiByte > 0 )
    {
      if ( CPInfo.MaxCharSize < 2 )
      {
        return 3;
      }
      v11 = (char *)CPInfo.LeadByte;
      if ( CPInfo.LeadByte[0] )
      {
        while ( 1 )
        {
          v12 = v11[1];
          if ( !v12 )
          {
            break;
          }
          if ( *lpMultiByteStr >= (unsigned __int8)*v11 && *lpMultiByteStr <= v12 )
          {
            return 2;
          }
          v11 += 2;
          if ( !*v11 )
          {
            return 3;
          }
        }
      }
      return 3;
    }
    if ( cchCount2 > 0 )
    {
      if ( CPInfo.MaxCharSize < 2 )
      {
        return v8;
      }
      v13 = (char *)CPInfo.LeadByte;
      if ( CPInfo.LeadByte[0] )
      {
        while ( 1 )
        {
          v14 = v13[1];
          if ( !v14 )
          {
            break;
          }
          if ( *lpString2 >= (unsigned __int8)*v13 && *lpString2 <= v14 )
          {
            return 2;
          }
          v13 += 2;
          if ( !*v13 )
          {
            return v8;
          }
        }
      }
      return v8;
    }
  }
  v15 = MultiByteToWideChar(CodePage, 9u, lpMultiByteStr, cbMultiByte, 0, 0);
  v29 = v15;
  if ( !v15 )
  {
    return 0;
  }
  v16 = alloca(2 * v15);
  ms_exc.old_esp = (DWORD)&v24;
  lpWideCharStr = (LPWSTR)&v24;
  ms_exc.registration.TryLevel = -1;
  v17 = (WCHAR *)&v24;
  if ( !&v24 )
  {
    v17 = (WCHAR *)malloc(2 * v15);
    lpWideCharStr = v17;
    if ( !v17 )
    {
      return 0;
    }
    v33 = 1;
    goto LABEL_43;
  }
LABEL_43:
  if ( MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cbMultiByte, v17, v15) )
  {
    v18 = MultiByteToWideChar(CodePage, 9u, lpString2, cchCount2, 0, 0);
    v27 = v18;
    if ( v18 )
    {
      v19 = alloca(2 * v18);
      ms_exc.old_esp = (DWORD)&v24;
      v20 = (const WCHAR *)&v24;
      v26 = &v24;
      ms_exc.registration.TryLevel = -1;
      if ( &v24 )
      {
LABEL_48:
        if ( MultiByteToWideChar(CodePage, 1u, lpString2, cchCount2, (LPWSTR)v20, v18) )
        {
          v31 = CompareStringW(Locale, dwCmpFlags, lpWideCharStr, v15, v20, v18);
        }
        if ( v32 )
        {
          free((void *)v20);
        }
        goto LABEL_52;
      }
      v20 = (const WCHAR *)malloc(2 * v18);
      if ( v20 )
      {
        v32 = 1;
        goto LABEL_48;
      }
    }
  }
LABEL_52:
  if ( v33 )
  {
    free(lpWideCharStr);
  }
  return v31;
}
// 41F0DE: using guessed type _DWORD __cdecl strncnt(_DWORD);
// 42DDB4: using guessed type int dword_42DDB4;
// 1BD5894: using guessed type int dword_1BD5894;
// 1BD594C: using guessed type int dword_1BD594C;

//----- (0041F91F) --------------------------------------------------------
unsigned int __cdecl sub_41F91F(_WORD *a1, signed int a2, int a3)
{
  unsigned int result; // eax@1
  char *v4; // ebx@1
  char v5; // al@7
  int *v6; // esi@8
  int v7; // esi@9
  int v8; // [sp+4h] [bp-10h]@9
  int v9; // [sp+8h] [bp-Ch]@9
  int v10; // [sp+Ch] [bp-8h]@9
  unsigned int v11; // [sp+10h] [bp-4h]@1
  unsigned int retaddr; // [sp+18h] [bp+4h]@1

  result = retaddr ^ dword_42DDB4;
  v4 = (char *)&unk_42E520 - 96;
  v11 = retaddr ^ dword_42DDB4;
  if ( !a2 )
  {
    return result;
  }
  if ( a2 < 0 )
  {
    a2 = -a2;
    v4 = (char *)&unk_42E680 - 96;
  }
  if ( !a3 )
  {
    result = (unsigned int)a1;
    *a1 = 0;
  }
  while ( a2 )
  {
    v5 = a2;
    a2 >>= 3;
    result = v5 & 7;
    v4 += 84;
    if ( result )
    {
      v6 = (int *)&v4[12 * result];
      if ( *(_WORD *)v6 >= 0x8000u )
      {
        v8 = *v6;
        v7 = (int)(v6 + 1);
        v9 = *(_DWORD *)v7;
        v10 = *(_DWORD *)(v7 + 4);
        --*(int *)((char *)&v8 + 2);
        v6 = &v8;
      }
      result = __ld12mul(a1, v6);
    }
  }
  return result;
}
// 41F6E7: using guessed type _DWORD __cdecl __ld12mul(_DWORD, _DWORD);
// 42DDB4: using guessed type int dword_42DDB4;

//----- (0041FBA0) --------------------------------------------------------
int sub_41FBA0()
{
  return unguard();
}

//----- (0041FBC0) --------------------------------------------------------
int sub_41FBC0()
{
  return unguard();
}

//----- (0041FBE0) --------------------------------------------------------
int sub_41FBE0()
{
  return unguard();
}

//----- (0041FC00) --------------------------------------------------------
int sub_41FC00()
{
  return unguard();
}

//----- (0041FC20) --------------------------------------------------------
int sub_41FC20()
{
  return unguard();
}

//----- (0041FC40) --------------------------------------------------------
int sub_41FC40()
{
  return unguard();
}

//----- (0041FC60) --------------------------------------------------------
void sub_41FC60()
{
  LeaveCriticalSection(&CExceptionInit::s_lock);
}

//----- (0041FC80) --------------------------------------------------------
int __usercall sub_41FC80@<eax>(int a1@<ebp>)
{
  return DBConn::DestructorDBConn((DBConn *)(a1 - 1056));
}

//----- (0041FCA0) --------------------------------------------------------
void __usercall sub_41FCA0(MemSmth *a1@<ebp>)
{
  MemSmth::Internal::Destructor((MemSmth *)a1[-1].field_15);
}

//----- (0041FCA8) --------------------------------------------------------
int __cdecl SEH_404800(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041FCC0) --------------------------------------------------------
int __usercall sub_41FCC0@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 - 16) + 4), 0x48u, 49, (void (__thiscall *)(void *))MemSmth::Destructor);
}

//----- (0041FCD6) --------------------------------------------------------
int __usercall sub_41FCD6@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 - 16) + 3532), 0x1Cu, 49, (void (__thiscall *)(void *))CIOCriticalSection::Destructor);
}

//----- (0041FD30) --------------------------------------------------------
void __usercall sub_41FD30(int a1@<ebp>)
{
  exception::~exception(*(_DWORD *)(a1 - 16));
}

//----- (0041FD50) --------------------------------------------------------
int __usercall sub_41FD50@<eax>(int a1@<ebp>)
{
  int v1; // esi@1
  int result; // eax@3

  v1 = a1 - 80;
  if ( *(_DWORD *)(a1 - 80 + 24) >= 0x10u )
  {
    j__free(*(void **)(a1 - 80 + 4));
  }
  result = 0;
  *(_DWORD *)(v1 + 24) = 15;
  *(_DWORD *)(v1 + 20) = 0;
  *(_BYTE *)(v1 + 4) = 0;
  return result;
}

//----- (0041FD58) --------------------------------------------------------
int __cdecl SEH_405920(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041FD70) --------------------------------------------------------
int __usercall sub_41FD70@<eax>(int a1@<ebp>)
{
  char *v1; // esi@1
  int result; // eax@1
  char *v3; // [sp+0h] [bp-4h]@1

  v3 = (char *)&unk_800AC0 + *(_DWORD *)(a1 - 16);
  v1 = v3;
  sub_405C30((int)v3, (int *)&v3, **((_DWORD **)v3 + 1), *((_DWORD *)v3 + 1));
  j__free(*((void **)v1 + 1));
  result = 0;
  *((_DWORD *)v1 + 1) = 0;
  *((_DWORD *)v1 + 2) = 0;
  return result;
}

//----- (0041FD7E) --------------------------------------------------------
void __usercall sub_41FD7E(int a1@<ebp>)
{
  std::vector_HANDLE::Destructor((std::vector_HANDLE *)((char *)&unk_800ACC + *(_DWORD *)(a1 - 16)));
}

//----- (0041FD8C) --------------------------------------------------------
int __cdecl SEH_405D20(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041FDB0) --------------------------------------------------------
int sub_41FDB0()
{
  return unguard();
}

//----- (0041FDBB) --------------------------------------------------------
LONG __usercall sub_41FDBB@<eax>(int a1@<ebp>)
{
  return MMU::Allocator::destroy((std::wstring *)(a1 - 304));
}

//----- (0041FDD0) --------------------------------------------------------
int sub_41FDD0()
{
  return unguard();
}

//----- (0041FDDB) --------------------------------------------------------
int __usercall sub_41FDDB@<eax>(int a1@<ebp>)
{
  return DBConn::DestructorDBConn((DBConn *)(a1 - 2080));
}

//----- (0041FDF0) --------------------------------------------------------
int sub_41FDF0()
{
  return unguard();
}

//----- (0041FDFB) --------------------------------------------------------
int __usercall sub_41FDFB@<eax>(int a1@<ebp>)
{
  return DBConn::DestructorDBConn((DBConn *)(a1 - 1056));
}

//----- (0041FE10) --------------------------------------------------------
int sub_41FE10()
{
  return unguard();
}

//----- (0041FE18) --------------------------------------------------------
int __cdecl SEH_407800(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041FE30) --------------------------------------------------------
int sub_41FE30()
{
  return unguard();
}

//----- (0041FE50) --------------------------------------------------------
int sub_41FE50()
{
  return unguard();
}

//----- (0041FE70) --------------------------------------------------------
int sub_41FE70()
{
  return unguard();
}

//----- (0041FE90) --------------------------------------------------------
int sub_41FE90()
{
  return unguard();
}

//----- (0041FE9B) --------------------------------------------------------
int __cdecl SEH_408310(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041FEB0) --------------------------------------------------------
int sub_41FEB0()
{
  return unguard();
}

//----- (0041FEBB) --------------------------------------------------------
int __cdecl SEH_4084B0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041FED8) --------------------------------------------------------
int __usercall sub_41FED8@<eax>(int a1@<ebp>)
{
  return CIOCriticalSection::Destructor((CIOCriticalSection *)(*(_DWORD *)(a1 - 16) + 24));
}

//----- (0041FEE3) --------------------------------------------------------
int sub_41FEE3()
{
  return unguard();
}

//----- (0041FF00) --------------------------------------------------------
void __usercall sub_41FF00(int a1@<ebp>)
{
  CIOObject::Destructor(*(CIOObject **)(a1 - 16));
}

//----- (0041FF08) --------------------------------------------------------
int __cdecl SEH_409860(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041FF20) --------------------------------------------------------
void __usercall sub_41FF20(int a1@<ebp>)
{
  CIOObject::Destructor(*(CIOObject **)(a1 - 16));
}

//----- (0041FF28) --------------------------------------------------------
int sub_41FF28()
{
  return unguard();
}

//----- (0041FF30) --------------------------------------------------------
int __cdecl SEH_4098D0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041FF40) --------------------------------------------------------
int sub_41FF40()
{
  return unguard();
}

//----- (0041FF48) --------------------------------------------------------
int __cdecl SEH_409940(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041FF60) --------------------------------------------------------
void __usercall sub_41FF60(int a1@<ebp>)
{
  CIOObject::Destructor(*(CIOObject **)(a1 - 16));
}

//----- (0041FF68) --------------------------------------------------------
int __usercall sub_41FF68@<eax>(int a1@<ebp>)
{
  return CIOCriticalSection::Destructor((CIOCriticalSection *)(*(_DWORD *)(a1 - 16) + 24));
}

//----- (0041FF80) --------------------------------------------------------
int sub_41FF80()
{
  return unguard();
}

//----- (0041FF88) --------------------------------------------------------
int sub_41FF88()
{
  return unguard();
}

//----- (0041FF90) --------------------------------------------------------
int sub_41FF90()
{
  return unguard();
}

//----- (0041FF98) --------------------------------------------------------
int __cdecl SEH_409DD0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041FFB0) --------------------------------------------------------
int sub_41FFB0()
{
  return unguard();
}

//----- (0041FFB8) --------------------------------------------------------
int sub_41FFB8()
{
  return unguard();
}

//----- (0041FFC0) --------------------------------------------------------
int __cdecl SEH_40A460(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041FFD0) --------------------------------------------------------
int sub_41FFD0()
{
  return unguard();
}

//----- (0041FFD8) --------------------------------------------------------
int sub_41FFD8()
{
  return unguard();
}

//----- (0041FFF0) --------------------------------------------------------
int sub_41FFF0()
{
  return unguard();
}

//----- (00420010) --------------------------------------------------------
int sub_420010()
{
  return unguard();
}

//----- (00420030) --------------------------------------------------------
void sub_420030()
{
  JUMPOUT(&loc_405490);
}

//----- (00420060) --------------------------------------------------------
int __cdecl SEH_40B370(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00420070) --------------------------------------------------------
int sub_420070()
{
  return unguard();
}

//----- (00420090) --------------------------------------------------------
int sub_420090()
{
  return unguard();
}

//----- (004200B0) --------------------------------------------------------
int sub_4200B0()
{
  return unguard();
}

//----- (004200D0) --------------------------------------------------------
int sub_4200D0()
{
  return unguard();
}

//----- (004200D8) --------------------------------------------------------
int __cdecl SEH_40BF30(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004200F0) --------------------------------------------------------
int sub_4200F0()
{
  return unguard();
}

//----- (00420110) --------------------------------------------------------
int sub_420110()
{
  return unguard();
}

//----- (0042011B) --------------------------------------------------------
int sub_42011B()
{
  int result; // eax@1

  result = *(_DWORD *)(*(_DWORD *)(__readfsdword(44) + 4 * TlsIndex) + 8);
  --CLog::s_stackSizes[result];
  return result;
}
// 1BD5478: using guessed type int TlsIndex;

//----- (00420130) --------------------------------------------------------
int sub_420130()
{
  return unguard();
}

//----- (0042013B) --------------------------------------------------------
void sub_42013B()
{
  JUMPOUT(&loc_40BED0);
}

//----- (00420150) --------------------------------------------------------
int sub_420150()
{
  return unguard();
}

//----- (00420170) --------------------------------------------------------
int sub_420170()
{
  return unguard();
}

//----- (00420178) --------------------------------------------------------
int __usercall sub_420178@<eax>(CLogSocket *a1@<ebp>)
{
  CIOBuffer *v1; // ST00_4@1

  v1 = a1[-1].d.base.m_pReadBuf;
  return CLogSocket::operator_delete();
}

//----- (00420190) --------------------------------------------------------
int sub_420190()
{
  return unguard();
}

//----- (004201B0) --------------------------------------------------------
int sub_4201B0()
{
  return unguard();
}

//----- (004201B8) --------------------------------------------------------
int __cdecl SEH_40D450(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004201D0) --------------------------------------------------------
int __usercall sub_4201D0@<eax>(int a1@<ebp>)
{
  return CIOSocket::Destructor(*(CIOSocket **)(a1 - 16));
}

//----- (004201F0) --------------------------------------------------------
int sub_4201F0()
{
  return unguard();
}

//----- (004201F8) --------------------------------------------------------
int __cdecl SEH_40D570(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00420210) --------------------------------------------------------
int sub_420210()
{
  return unguard();
}

//----- (00420218) --------------------------------------------------------
void __usercall sub_420218(int a1@<ebp>)
{
  j__free(*(void **)(a1 + 4));
}

//----- (00420230) --------------------------------------------------------
int sub_420230()
{
  return unguard();
}

//----- (00420243) --------------------------------------------------------
int __cdecl SEH_40D870(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00420250) --------------------------------------------------------
int sub_420250()
{
  return unguard();
}

//----- (0042025B) --------------------------------------------------------
int __usercall sub_42025B@<eax>(int a1@<ebp>)
{
  return DBConn::DestructorDBConn((DBConn *)(a1 - 2592));
}

//----- (00420266) --------------------------------------------------------
int __cdecl SEH_40E330(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00420270) --------------------------------------------------------
int sub_420270()
{
  return unguard();
}

//----- (0042027B) --------------------------------------------------------
int __usercall sub_42027B@<eax>(int a1@<ebp>)
{
  return DBConn::DestructorDBConn((DBConn *)(a1 - 1568));
}

//----- (00420286) --------------------------------------------------------
int __cdecl SEH_40E680(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00420290) --------------------------------------------------------
int sub_420290()
{
  return unguard();
}

//----- (0042029B) --------------------------------------------------------
int __usercall sub_42029B@<eax>(int a1@<ebp>)
{
  return DBConn::DestructorDBConn((DBConn *)(a1 - 9760));
}

//----- (004202A6) --------------------------------------------------------
int __cdecl SEH_40E980(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004202B0) --------------------------------------------------------
int sub_4202B0()
{
  return unguard();
}

//----- (004202BB) --------------------------------------------------------
int __usercall sub_4202BB@<eax>(int a1@<ebp>)
{
  return DBConn::DestructorDBConn((DBConn *)(a1 - 2592));
}

//----- (004202C6) --------------------------------------------------------
int __cdecl SEH_40ECE0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004202D0) --------------------------------------------------------
int __usercall sub_4202D0@<eax>(CIOServer *a1@<ebp>)
{
  return CIOServer::Destructor((CIOServer *)a1[-1].m_d.base.m_identity);
}

//----- (004202D8) --------------------------------------------------------
int __cdecl SEH_40F080(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004202F0) --------------------------------------------------------
int sub_4202F0()
{
  return unguard();
}

//----- (00420310) --------------------------------------------------------
int __usercall sub_420310@<eax>(int a1@<ebp>)
{
  return CIOSocket::Destructor(*(CIOSocket **)(a1 - 16));
}

//----- (00420318) --------------------------------------------------------
int __usercall sub_420318@<eax>(int a1@<ebp>)
{
  return CIOCriticalSection::Destructor((CIOCriticalSection *)(*(_DWORD *)(a1 - 16) + 172));
}

//----- (00420326) --------------------------------------------------------
int __usercall sub_420326@<eax>(int a1@<ebp>)
{
  return CIOCriticalSection::Destructor((CIOCriticalSection *)(*(_DWORD *)(a1 - 16) + 200));
}

//----- (00420334) --------------------------------------------------------
int sub_420334()
{
  return unguard();
}

//----- (0042033C) --------------------------------------------------------
int __cdecl SEH_40F6B0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00420350) --------------------------------------------------------
int __usercall sub_420350@<eax>(int a1@<ebp>)
{
  return CIOSocket::Destructor(*(CIOSocket **)(a1 - 16));
}

//----- (00420358) --------------------------------------------------------
int __usercall sub_420358@<eax>(int a1@<ebp>)
{
  return CIOCriticalSection::Destructor((CIOCriticalSection *)(*(_DWORD *)(a1 - 16) + 172));
}

//----- (00420366) --------------------------------------------------------
int __usercall sub_420366@<eax>(int a1@<ebp>)
{
  return CIOCriticalSection::Destructor((CIOCriticalSection *)(*(_DWORD *)(a1 - 16) + 200));
}

//----- (00420374) --------------------------------------------------------
int __cdecl SEH_40F890(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00420380) --------------------------------------------------------
int sub_420380()
{
  return unguard();
}

//----- (00420393) --------------------------------------------------------
int __cdecl SEH_40F9A0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004203A0) --------------------------------------------------------
int sub_4203A0()
{
  return unguard();
}

//----- (004203AB) --------------------------------------------------------
int __cdecl SEH_40FAD0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004203C0) --------------------------------------------------------
int sub_4203C0()
{
  return unguard();
}

//----- (004203E0) --------------------------------------------------------
int sub_4203E0()
{
  return unguard();
}

//----- (00420400) --------------------------------------------------------
int sub_420400()
{
  return unguard();
}

//----- (0042040B) --------------------------------------------------------
int __cdecl SEH_410620(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00420420) --------------------------------------------------------
int sub_420420()
{
  return unguard();
}

//----- (0042042B) --------------------------------------------------------
int __cdecl SEH_411020(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00420440) --------------------------------------------------------
int sub_420440()
{
  return unguard();
}

//----- (00420460) --------------------------------------------------------
int sub_420460()
{
  return unguard();
}

//----- (00420473) --------------------------------------------------------
int __cdecl SEH_411280(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00420480) --------------------------------------------------------
int sub_420480()
{
  return unguard();
}

//----- (0042048B) --------------------------------------------------------
int __usercall sub_42048B@<eax>(int a1@<ebp>)
{
  return DBConn::DestructorDBConn((DBConn *)(a1 - 1056));
}

//----- (004204A0) --------------------------------------------------------
void __usercall sub_4204A0(CIOObject *a1@<ebp>)
{
  volatile __int32 v1; // ST04_4@1

  v1 = a1->m_d.base.m_nRefCount;
  CIOObject::OnWaitCallback((CIOObject *)a1[-1].vtable);
}

//----- (004204C0) --------------------------------------------------------
void sub_4204C0()
{
  JUMPOUT(&loc_405490);
}

//----- (004204E0) --------------------------------------------------------
int sub_4204E0()
{
  return unguard();
}

//----- (004204EB) --------------------------------------------------------
int __usercall sub_4204EB@<eax>(int a1@<ebp>)
{
  return DBConn::DestructorDBConn((DBConn *)(a1 - 17440));
}

//----- (004204F6) --------------------------------------------------------
LONG __usercall sub_4204F6@<eax>(int a1@<ebp>)
{
  return MMU::Allocator::destroy((std::wstring *)(a1 - 17736));
}

//----- (00420510) --------------------------------------------------------
void __usercall sub_420510(int a1@<ebp>)
{
  j_std::dequeue_string::Destructor((std::dequeue_string *)(*(_DWORD *)(a1 - 16) + 24));
}

//----- (0042051B) --------------------------------------------------------
int __cdecl SEH_411C90(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 412090: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00420530) --------------------------------------------------------
int sub_420530()
{
  return unguard();
}

//----- (0042053B) --------------------------------------------------------
LONG __usercall sub_42053B@<eax>(int a1@<ebp>)
{
  return MMU::Allocator::destroy((std::wstring *)(a1 - 16692));
}

//----- (00420550) --------------------------------------------------------
void sub_420550()
{
  JUMPOUT(&loc_405490);
}

//----- (00420570) --------------------------------------------------------
int DBConn::s_lock_StaticInit()
{
  CIOCriticalSection::CIOCriticalSection(&DBConn::s_lock1);
  return atexit(DBConn::s_lock_StaticDeInit);
}

//----- (00420590) --------------------------------------------------------
int DBConn::s_lock2::Static_Init()
{
  CIOCriticalSection::CIOCriticalSection(&DBConn::s_lock2);
  return atexit(DBConn::s_lock2::Static_DeInit);
}

//----- (004205B0) --------------------------------------------------------
int CoreDump::s_lock::StaticInit()
{
  CIOCriticalSection::CIOCriticalSection(&CoreDump::s_lock);
  return atexit(CoreDump::s_lock::StaticDeInit);
}

//----- (004205D0) --------------------------------------------------------
int CExceptionInit::Static_Init()
{
  CExceptionInit::CExceptionInit(&g_exeptionHalder);
  return atexit(CExceptionInit::Destructor);
}

//----- (004205F0) --------------------------------------------------------
int __cdecl CQsCheck::StaticInit()
{
  CQsCheck::CQsCheck(&g_qsCheck);
  return atexit(CQsCheck::StaticDeInit);
}

//----- (00420610) --------------------------------------------------------
int CBCPLogFile::Static_Init()
{
  Static_Init_For_Arrays(g_bcpFiles, 520u, 10, (int)CBCPLogFile::CBCPLogFile, (void (__thiscall *)(void *))CBCPLogFile::DestructorCBCPLogFile);
  return atexit(CBCPLogFile::Static_DeInit);
}

//----- (00420640) --------------------------------------------------------
int sub_420640()
{
  int result; // eax@1

  result = Threading::s_ioThreadNumber + 16;
  Config::s_dbConnectionNum3 = Threading::s_ioThreadNumber + 16;
  return result;
}

//----- (00420650) --------------------------------------------------------
int CServer::StaticInit()
{
  CServer::CServer(&g_logServer);
  return atexit(CServer::StaticDeInit);
}

//----- (00420670) --------------------------------------------------------
int g_globalLockTimer::StaticInit()
{
  CIOCriticalSection::CIOCriticalSection(&g_globalLockTimer);
  return atexit(g_globalLockTimer::StaticDeInit);
}

//----- (00420690) --------------------------------------------------------
int timerQueue::Static_Init()
{
  Static_Init_For_Arrays(g_timerQueues, sizeof(std::priority_queue_CIOTimer), 13, (int)std::priority_queue::priority_queue, (void (__thiscall *)(void *))std::vector_HANDLE::Destructor);
  return atexit(g_timerQueue::StaticDeinit);
}
// 1BD3C38: using guessed type std::priority_queue_CIOTimer g_timerQueues[13];

//----- (004206C0) --------------------------------------------------------
int g_vHandle::StaticInit()
{
  std::vector_HANDLE::std::vector_HANDLE(&g_vHandle);
  return atexit(g_vHandle::CallDtor);
}

//----- (004206E0) --------------------------------------------------------
int g_vObject::StaticInit()
{
  std::vector_HANDLE::std::vector_HANDLE((std::vector_HANDLE *)&g_vObject);
  return atexit(g_vObject::CallDtor);
}

//----- (00420700) --------------------------------------------------------
int CIODeadlockChecker::StaticInit()
{
  CIODeadlockChecker::CIODeadlockChecker(&g_deadlock_checker);
  return atexit(CIODeadlockChecker::StaticDeInit);
}

//----- (00420720) --------------------------------------------------------
void __cdecl __CxxSetUnhandledExceptionFilter()
{
  dword_1BD3D70 = InterlockedIncrement(&MemoryObject::s_refCountSlots);
}
// 1BD3D70: using guessed type int dword_1BD3D70;

//----- (00420740) --------------------------------------------------------
void __cdecl __CxxSetUnhandledExceptionFilter()
{
  dword_1BD3D74 = InterlockedIncrement(&MemoryObject::s_refCountSlots);
}
// 1BD3D74: using guessed type int dword_1BD3D74;

//----- (00420760) --------------------------------------------------------
void __cdecl CIODeadlockChecker::s_nAlloc::Init()
{
  CIODeadlockChecker::s_nAlloc = InterlockedIncrement(&MemoryObject::s_refCountSlots);
}

//----- (00420780) --------------------------------------------------------
void __cdecl CIOSocket::s_nAlloc::Init()
{
  CIOSocket::s_nAlloc = InterlockedIncrement(&MemoryObject::s_refCountSlots);
}

//----- (004207A0) --------------------------------------------------------
void __cdecl CIOServer::s_nAlloc::Init()
{
  CIOServer::s_nAlloc = InterlockedIncrement(&MemoryObject::s_refCountSlots);
}

//----- (004207C0) --------------------------------------------------------
CSlot *CPacketPool::CPacketPool()
{
  CSlot *result; // eax@1
  signed int size; // ecx@1

  result = CPacketPool::s_slots;
  size = 16;
  do
  {
    result->m_pPacket = 0;
    result->m_lock.lock = 0;
    ++result;
    --size;
  }
  while ( size );
  return result;
}

//----- (004207E0) --------------------------------------------------------
int CPacketPool::Static_Init()
{
  return atexit(CPacketPool::Destructor);
}

//----- (004207F0) --------------------------------------------------------
void __cdecl CPacket::g_nAlloc::Init()
{
  CPacket::s_nAlloc = InterlockedIncrement(&MemoryObject::s_refCountSlots);
}

//----- (00420810) --------------------------------------------------------
int CLog::StaticInit()
{
  CLog::CLog(&g_winlog, 128);
  return atexit(CLog::Destructor);
}

//----- (00420830) --------------------------------------------------------
int CLogCli::StaticInit()
{
  CLogCli::CLogCli(&g_cliLog);
  return atexit(CLogCli::Destructor);
}

//----- (00420850) --------------------------------------------------------
void __cdecl CLogSocket::s_nAlloc::Init()
{
  CLogSocket::s_nAlloc = InterlockedIncrement(&MemoryObject::s_refCountSlots);
}

//----- (00420870) --------------------------------------------------------
void __cdecl MemoryObject::s_nAlloc::Init()
{
  MemoryObject::s_nAlloc = InterlockedIncrement(&MemoryObject::s_refCountSlots);
}
// 1BD4FC8: using guessed type int MemoryObject::s_nAlloc;

//----- (00420890) --------------------------------------------------------
int PerfMonitor::Static_Init()
{
  PerfMonitor::PerfMonitor(&g_perfMonitor);
  return atexit(PerfMonitor::Destructor);
}

//----- (004208B0) --------------------------------------------------------
int sub_4208B0()
{
  CReadFile::CReadFile(&unk_1BD5020);
  return atexit(unknown_libname_66);
}

//----- (00420910) --------------------------------------------------------
int CSQLQueue::StaticInit()
{
  CSQLQueue::CSQLQueue(&g_sqlPollingQueue);
  return atexit(CSQLQueue::Destructor);
}

//----- (00420930) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
void __cdecl DBConn::s_lock_StaticDeInit()
{
  CIOCriticalSection::Destructor(&DBConn::s_lock1);
}

//----- (00420960) --------------------------------------------------------
void __cdecl CExceptionInit::Destructor()
{
  CExceptionInit::RestoreTopLevelFilter();
  DeleteCriticalSection(&CExceptionInit::s_lock);
}

//----- (00420980) --------------------------------------------------------
void __cdecl CBCPLogFile::Static_DeInit()
{
  `eh vector destructor iterator'(g_bcpFiles, 0x208u, 10, (void (__thiscall *)(void *))CBCPLogFile::DestructorCBCPLogFile);
}

//----- (004209A0) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
void __cdecl CServer::StaticDeInit()
{
  CServer::Destructor(&g_logServer);
}

//----- (00420A00) --------------------------------------------------------
void __cdecl g_timerQueue::StaticDeinit()
{
  `eh vector destructor iterator'(g_timerQueues, sizeof(std::priority_queue_CIOTimer), 13, (void (__thiscall *)(void *))std::vector_HANDLE::Destructor);
}
// 1BD3C38: using guessed type std::priority_queue_CIOTimer g_timerQueues[13];

//----- (00420A20) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
void __cdecl CLog::Destructor()
{
  struct _RTL_CRITICAL_SECTION *lock; // edi@1
  HANDLE *buffer; // esi@1
  FileBuffers buffersCount; // ebx@1
  CLog *this_; // [sp+0h] [bp-4h]@1

  this_ = &g_winlog;
  guard(&this_, L"CLog::~CLog");
  j_j__free(g_winlog.m_outputBuffer);
  DeleteCriticalSection(&g_winlog.m_criticalSection);
  lock = g_winlog.m_bufferLocks;
  buffer = g_winlog.m_fileBuffers;
  buffersCount = FileBuffers_BuffersCount;
  do
  {
    if ( *buffer != (HANDLE)-1 )
    {
      FlushFileBuffers(*buffer);
      CloseHandle(*buffer);
    }
    DeleteCriticalSection(lock);
    ++buffer;
    ++lock;
    --buffersCount;
  }
  while ( buffersCount );
  unguard();
}

//----- (00420A30) --------------------------------------------------------
void __cdecl CLogCli::Destructor()
{
  DeleteCriticalSection(&g_cliLog.m_lock);
}

//----- (00420A40) --------------------------------------------------------
void __cdecl PerfMonitor::Destructor()
{
  PDH_HCOUNTER *v0; // esi@6

  if ( g_perfMonitor.m_initialized && g_perfMonitor.m_pdhCountersNumber > 0 )
  {
    PerfMonitor::Clean(&g_perfMonitor);
  }
  if ( g_perfMonitor.m_counterElements )
  {
    j_j__free(g_perfMonitor.m_counterElements);
  }
  v0 = g_perfMonitor.m_pdhCounters;
  if ( v0 )
  {
    j_j__free(v0);
  }
}

//----- (00420A60) --------------------------------------------------------
void __cdecl CSQLQueue::Destructor()
{
  int v0; // eax@0
  char v1; // [sp+0h] [bp-14h]@1
  CSQLQueue *v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+8h] [bp-Ch]@1
  int (__cdecl *v4)(int, int, int, int); // [sp+Ch] [bp-8h]@1
  int v5; // [sp+10h] [bp-4h]@1

  v4 = SEH_411C90;
  v3 = v0;
  v2 = &g_sqlPollingQueue;
  v5 = 0;
  guard(&v1, L"CSQLQueue::~CSQLQueue()");
  DeleteCriticalSection(&g_sqlPollingQueue.m_lock);
  unguard();
  v5 = -1;
  std::dequeue_string::Destructor(&g_sqlPollingQueue.m_queue);
}

//----- (00420A70) --------------------------------------------------------
void __cdecl sub_420A70()
{
  sub_411F67((int)&dword_1BD5468);
}
// 1BD5468: using guessed type int dword_1BD5468;

// ALL OK, 540 function(s) have been successfully decompiled
